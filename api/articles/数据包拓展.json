{"title":"数据包拓展","uid":"2fe6b220dcca97cedb2f7f37b2f387f3","slug":"数据包拓展","date":"2022-01-23T10:36:42.000Z","updated":"2022-02-13T15:50:10.958Z","comments":true,"path":"api/articles/数据包拓展.json","keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>[TOC]</p>\n<h2 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h2><p>当从浏览器访问时，使用代理(Proxy)可以抓取请求数据包(Request)进行分析，或者从Web Server返回数据包(Response)进行分析；BurpSuit其实就很典型，可以作为代理服务器，实现上述作用。</p>\n<h2 id=\"Http和Https\"><a href=\"#Http和Https\" class=\"headerlink\" title=\"Http和Https\"></a>Http和Https</h2><p>http包抓到后一般都是明文的，https通常是密文的，加密的。</p>\n<p><strong>http简要通信过程：</strong></p>\n<p>1.浏览器建立与web服务器之间的连接</p>\n<p>2.浏览器将请求数据打包（生成请求数据包）并发送到web服务器</p>\n<p>3.web服务器将处理结果打包（生成响应数据包）并发送给浏览器</p>\n<p>4.web服务器关闭连接</p>\n<p><strong>https简要通信过程</strong></p>\n<p>1.https请求</p>\n<p>2.服务器响应</p>\n<p>3.证书校验，生成密码，公钥加密</p>\n<p>4.加密信息</p>\n<p>5.私钥解密，解密握手 消息，验证HASH</p>\n<p>6.加密信息</p>\n<p>7.解密握手消息，验证HASH</p>\n<p>8.正常加密通信</p>\n<h1 id=\"Request请求数据包格式\"><a href=\"#Request请求数据包格式\" class=\"headerlink\" title=\"Request请求数据包格式\"></a>Request请求数据包格式</h1><p>1.请求行：请求类型&#x2F;请求资源路径、协议的版本和类型</p>\n<p> 2.请求头：一些键值对，浏览器与 web 服务器之间都可以发送，特定的某种含义</p>\n<p>3.空行：请求头与请求体之间用一个空行隔开</p>\n<p> 4.请求体：要发送的数据(一般 post 提交会使用)；例：user&#x3D;123&amp;pass&#x3D;123</p>\n<p>###请求行</p>\n<p>请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分享。 </p>\n<p>例如：</p>\n<p>GET &#x2F;index.html HTTP&#x2F;1.1 HTTP 规划定义了 8 种可能的请求方法：</p>\n<p> GET：检索 URL 中标识资源的一个简单请求</p>\n<p> HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档 </p>\n<p>POST：服务器接受被写入客户端输出流中的数据的请求</p>\n<p> PUT：服务器保存请求数据作为指定 URL 新内容的请求</p>\n<p> DELETE：服务器删除 URL 中命令的资源的请求 </p>\n<p>OPTIONS：关于服务器支持的请求方法信息的请求 </p>\n<p>TRACE：web 服务器反馈 Http 请求和其头标的请求 </p>\n<p>CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>由关键字&#x2F;值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。 </p>\n<p><strong>HOST</strong>: 主机或域名地址 </p>\n<p>Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。</p>\n<p>Servlet 可以根据它判断并返回适当的文件格 式。</p>\n<p> User-Agent：是客户浏览器名称</p>\n<p><strong>Host</strong>：对应网址 URL 中的 Web 名称和端口号。 </p>\n<p>Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。 </p>\n<p>connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP&#x2F;1.1 使用 Keep-Alive 为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立 连接</p>\n<p> <strong>Cookie</strong>：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载 和服务器相关的用户信息，也可以用来实现会话功能。 </p>\n<p><strong>Referer</strong> ： 表 明 产 生 请 求 的 网 页 URL 。 如 比 从 网 页 &#x2F;icconcept&#x2F;index.jsp 中 点 击 一 个 链 接 到 网 页 &#x2F;icwork&#x2F;search ， 在 向 服 务 器 发 送 的 GET&#x2F;icwork&#x2F;search 中 的 请 求 中 ， Referer 是 <a href=\"http://hostname:8080/icconcept/index.jsp%E3%80%82%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E8%B7%9F%E8%B8%AA\">http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪</a> Web 请求是从什么网站来的。</p>\n<p> Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。 </p>\n<p>Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1. Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加 速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。</p>\n<p><strong>X-Forwarded-For</strong>： 是一个 HTTP 扩展头部。HTTP&#x2F;1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。</p>\n<p> X-Real-IP：这又是一个自定义头部字段。X-Real-IP 通常被 HTTP 代理用来表示与它产生 TCP 连接的设备 IP，这个设备可能是其他代理，也可能是真正的请求端。需要注意的是，X-Real-IP 目前并不属于任何标准，代理和 Web 应用之间可以约定用任何自定义头来传递这个信息。</p>\n<h3 id=\"请求空行\"><a href=\"#请求空行\" class=\"headerlink\" title=\"请求空行\"></a>请求空行</h3><p>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。</p>\n<p>用于分割POST请求的请求头，和请求体。</p>\n<h3 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a>请求数据</h3><p>使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。</p>\n<p>封装POST请求消息的请求参数。</p>\n<h2 id=\"Response返回数据包数据格式\"><a href=\"#Response返回数据包数据格式\" class=\"headerlink\" title=\"Response返回数据包数据格式\"></a>Response返回数据包数据格式</h2><p>一个响应由四个部分组成；状态行、响应头标、空行、响应数据。</p>\n<p>1.状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔 </p>\n<p>2.响应头标：包含服务器类型、日期、长度、内容类型等 </p>\n<p>3.空行：响应头与响应体之间用空行隔开 </p>\n<p>4.响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面</p>\n<p>HTTP 响应码：</p>\n<p> 1xx：信息，请求收到，继续处理</p>\n<p> 2xx：成功，行为被成功地接受、理解和采纳 </p>\n<p>3xx：重定向，为了完成请求，必须进一步执行的动作 </p>\n<p>4xx：客户端错误 </p>\n<p>5xx：服务器错误</p>\n<p>200  存在文件</p>\n<p>403  存在文件夹</p>\n<p>3xx  均可能存在</p>\n<p>404  不存在文件及文件夹 </p>\n<p>500  均可能存在</p>\n","text":"[TOC] 代理当从浏览器访问时，使用代理(Proxy)可以抓取请求数据包(Request)进行分析，或者从Web Server返回数据包(Response)进行分析；BurpSuit其实就很典型，可以作为代理服务器，实现上述作用。 Http和Httpshttp包抓到后一般都是明...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"基础知识","slug":"基础知识","count":8,"path":"api/categories/基础知识.json"}],"tags":[{"name":"基础知识","slug":"基础知识","count":12,"path":"api/tags/基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">代理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Http%E5%92%8CHttps\"><span class=\"toc-text\">Http和Https</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Request%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">Request请求数据包格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E5%A4%B4\"><span class=\"toc-text\">请求头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E7%A9%BA%E8%A1%8C\"><span class=\"toc-text\">请求空行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">请求数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Response%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%8C%85%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">Response返回数据包数据格式</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"墨者学院-来源页伪造","uid":"495216adb2265f60982c64eb2dfe8dfd","slug":"墨者学院-来源页伪造","date":"2022-01-24T02:45:11.000Z","updated":"2022-03-20T11:50:18.249Z","comments":true,"path":"api/articles/墨者学院-来源页伪造.json","keywords":null,"cover":[],"text":"[TOC] 0x00首先启动靶场 0x01进入靶场后表示只能使用google浏览器访问 0x02首先想到不可能每次都使用Google访问，解题提示使用referer构造google访问的请求数据包 利用Burpsuite进项伪造 二话不说先抓个包 接下来伪造Google访问数据包...","link":"","photos":[],"count_time":{"symbolsCount":244,"symbolsTime":"1 mins."},"categories":[{"name":"靶场","slug":"靶场","count":4,"path":"api/categories/靶场.json"}],"tags":[{"name":"CTF","slug":"CTF","count":19,"path":"api/tags/CTF.json"},{"name":"靶场","slug":"靶场","count":12,"path":"api/tags/靶场.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}